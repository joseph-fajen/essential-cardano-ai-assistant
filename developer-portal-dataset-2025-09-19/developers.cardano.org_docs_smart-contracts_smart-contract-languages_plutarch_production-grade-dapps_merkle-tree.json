{
  "url": "https://developers.cardano.org/docs/smart-contracts/smart-contract-languages/plutarch/production-grade-dapps/merkle-tree",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Merkle Trees\n\n## Introduction[​](#introduction \"Direct link to Introduction\")\n\nWelcome to the definitive guide on leveraging Plutarch Merkle Trees within the Cardano smart contract ecosystem. This comprehensive documentation is designed to equip developers with the knowledge and tools necessary to integrate the robust and efficient data structure of Merkle Trees into their decentralized applications (DApps) using Plutarch, thereby enhancing data integrity and verification processes.\n\nMerkle Trees are a cornerstone of cryptographic and computer science, offering a secure and efficient method to summarize and verify large datasets. Named after Ralph Merkle, this data structure is particularly beneficial in distributed systems like blockchains for its ability to ensure data integrity through cryptographic hashes.\n\nThe source code for these dApps can be found [here](https://github.com/Anastasia-Labs/plutarch-merkle-tree).\n\n### Basic concept[​](#basic-concept \"Direct link to Basic concept\")\n\nA Merkle tree is a type of binary tree, consisting of nodes. Here's how it's structured:\n\n### Construction[​](#construction \"Direct link to Construction\")\n\n**Hashing the Data**: First, each piece of data at the leaf level is hashed.\n\n**Pairing and Hashing Upwards**: These hashes are then paired and concatenated, and the resultant string is hashed again. This process continues until you reach the single hash at the top - the root hash.\n\n**Tree Structure**: This process creates a tree-like structure where each parent node is a hash of its children, providing a secure and efficient means of verifying the contents of the tree.\n\n### Features[​](#features \"Direct link to Features\")\n\n**Efficiency in Verification**: To verify any single data chunk's integrity, you don't need to download the entire tree. You only need the hashes of the nodes along the path from your data chunk to the root.\n\n**Tamper-Proof**: Any change in a leaf node (data) will result in a completely different root hash through a cascading effect of changes in the intermediate hashes. This makes it easy to detect alterations.\n\n**Concurrency Friendly**: Multiple branches of the tree can be processed simultaneously, making Merkle trees highly efficient for parallel processing.\n\n### Example[​](#example \"Direct link to Example\")\n\nConsider a Merkle tree with four leaf nodes (A, B, C, D).\n\nThe Merkle root is a digest of all the data in the leaf nodes.\n\n## Plutarch Merkle Tree implementation[​](#plutarch-merkle-tree-implementation \"Direct link to Plutarch Merkle Tree implementation\")\n\n### Prerequisites[​](#prerequisites \"Direct link to Prerequisites\")\n\nBefore leveraging the Plutarch Merkle Tree library, ensure you're equipped with:\n\nBasic understanding of Haskell and Plutus.\n\nCardano node and Plutus development environment setup.\n\nFamiliarity with Plutarch, an extension of Plutus, designed for more efficient on-chain code.\n\n### Installation[​](#installation \"Direct link to Installation\")\n\nTo integrate the Plutarch Merkle Tree library into your project, start by creating a `cabal.project` file, as this file is not automatically generated during the cabal init process. Then, proceed by including the following:\n\n`cabal.project`\n`source-repository-package  \n type: git  \n location: git://github.com/Anastasia-Labs/plutarch-merkle-tree.git`\n\nThen in the your `[name of your project].cabal` file include the repository under the build-depends section\n\n`[name of your project].cabal`\n`build-depends:  \n base ^>= 4.11.1.0  \n , plutarch-merkle-tree`\n\n### Functions[​](#functions \"Direct link to Functions\")\n\nThe Plutarch Merkle Tree implementation provides several functions to create and manipulate Merkle Trees. Below is a brief overview of each function:\n\n-`fromList`: Constructs a Merkle Tree from a list of serialized data.\n\n`fromList`\n`fromList :: [BuiltinByteString] -> MerkleTree`\n\n-`toList`: Deconstructs a Merkle Tree back into a list of elements.\n\n`toList`\n`toList :: MerkleTree -> [BuiltinByteString]`\n\n-`rootHash`: Retrieves the root hash of a Merkle Tree.\n\n`rootHash`\n`rootHash :: MerkleTree -> Hash`\n\n-`isNull`: Checks if a Merkle Tree is empty.\n\n`isNull`\n`isNull :: MerkleTree -> Bool`\n\n-`size`: Returns the number of leaf nodes in a Merkle Tree.\n\n`size`\n`size :: MerkleTree -> Integer`\n\n-`mkProof`: Generates a proof of membership for an element in the Merkle Tree.\n\n`mkProof`\n`mkProof :: BuiltinByteString -> MerkleTree -> Maybe Proof`\n\n-`member`: Verifies if an element is part of a Merkle Tree using a proof.\n\n`member`\n`member :: BuiltinByteString -> Hash -> Proof -> Bool`\n\n-`hash`: Computes a SHA-256 hash of a given byte string.\n\n`hash`\n`hash :: BuiltinByteString -> Hash`\n\n-`combineHash`: Combines two hashes into a new one.\n\n`combineHash`\n`combineHash :: Hash -> Hash -> Hash`\n\n-`addLeaf`: Adds a new leaf to the Merkle Tree.\n\n`addLeaf`\n`addLeaf :: BuiltinByteString -> MerkleTree -> MerkleTree`\n\n### Utilizing Plutarch Merkle Trees[​](#utilizing-plutarch-merkle-trees \"Direct link to Utilizing Plutarch Merkle Trees\")\n\n#### Step 1: Constructing a Merkle Tree[​](#step-1-constructing-a-merkle-tree \"Direct link to Step 1: Constructing a Merkle Tree\")\n\nBegin by creating a Merkle Tree from your dataset. This is achieved using the fromList function, which takes a list of data items (typically strings or bytes) and organizes them into a Merkle Tree structure:\n\n`import Plutus.MerkleTree (fromList)  \n  \nmyData :: [String]  \nmyData = [\"data1\", \"data2\", \"data3\", \"data4\"]  \n  \nmyMerkleTree = fromList myData`\n\n#### Step 2: Generating Merkle Proofs[​](#step-2-generating-merkle-proofs \"Direct link to Step 2: Generating Merkle Proofs\")\n\nTo verify an item's presence within the tree, generate a cryptographic proof with mkProof. This proof is essential for the verification process:\n\n`import Plutus.MerkleTree (mkProof)  \nimport Data.Maybe (fromJust)  \n  \nmyProof = fromJust $ mkProof \"data1\" myMerkleTree`\n\nCaution: Ensure the item exists within the tree before using fromJust to avoid runtime errors.\n\n#### Step 3: Verifying Data Integrity[​](#step-3-verifying-data-integrity \"Direct link to Step 3: Verifying Data Integrity\")\n\nWith the proof in hand, you can assert the item's presence using the member function. This involves checking the item against the tree's root hash:\n\n`import Plutus.MerkleTree (member, rootHash)  \n  \nisValid = member \"data1\" (rootHash myMerkleTree) myProof`\n\n#### Step 4: Plutarch Integration[​](#step-4-plutarch-integration \"Direct link to Step 4: Plutarch Integration\")\n\nTransitioning to on-chain validation with Plutarch involves converting data and proofs to Plutarch-compatible types and utilizing pmember for verification:\n\n`import Plutarch.MerkleTree (pmember)  \nimport Plutarch (pconstant, pdata, (#$), (#))  \n  \npmyProof = pdata $ pconstant myProof  \n  \npIsValid = pmember # pdata (pconstant \"data1\") # pdata (pconstant $ rootHash myMerkleTree) # pmyProof`\n\n### Best Practices and Considerations[​](#best-practices-and-considerations \"Direct link to Best Practices and Considerations\")\n\n**Data Pre-Hashing**: Maintain data confidentiality and integrity by pre-hashing data before tree insertion.\n\n**Optimization**: Balance the tree's depth and breadth to optimize verification speed and minimize on-chain costs.\n\n**Robust Error Handling**: Implement comprehensive error handling, especially for proof generation, to enhance contract reliability.",
  "images": [],
  "extraction_metadata": {
    "batch_number": 12,
    "extraction_timestamp": "2025-09-19T14:05:17.156321",
    "extraction_time": 1.6163160800933838,
    "source": "tavily_api_raw"
  }
}