{
  "url": "https://developers.cardano.org/docs/get-started/cardano-serialization-lib/generating-keys",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Generating Keys and Addresses\n\n## BIP32 Keys[​](#bip32-keys \"Direct link to BIP32 Keys\")\n\nThere are two main categories of keys in this library. There are the raw `PublicKey` and `PrivateKey` which are used for cryptographically signing/verifying, and `BIP32PrivateKey`/`BIP32PublicKey` which in addition to this have the ability to derive additional keys from them following the [BIP32 derivation scheme](https://en.bitcoin.it/wiki/BIP_0032) variant called BIP32-Ed25519, which will be referred to as BIP32 for brevity. We use the [BIP44 spec](https://en.bitcoin.it/wiki/BIP_0044) variant for Ed25519 as well for the derivation paths using 1852 or 44 as the purpose consant and 1815 for the coin type depending on address type. See [this doc](https://github.com/input-output-hk/implementation-decisions/pull/18) for more details.\n\n`PublicKey`\n`PrivateKey`\n`BIP32PrivateKey`\n`BIP32PublicKey`\n\nThis is demonstrated with the below code\n\n`function harden(num: number): number {  \n return 0x80000000 + num;  \n}  \n  \n  \nconst rootKey = CardanoWasm.BIP32PrivateKey.from_bech32(\"xprv17qx9vxm6060qjn5fgazfue9nwyf448w7upk60c3epln82vumg9r9kxzsud9uv5rfscxp382j2aku254zj3qfx9fx39t6hjwtmwq85uunsd8x0st3j66lzf5yn30hwq5n75zeuplepx8vxc502txx09ygjgx06n0p\");  \nconst accountKey = rootKey  \n .derive(harden(1852)) // purpose  \n .derive(harden(1815)) // coin type  \n .derive(harden(0)); // account #0  \n  \nconst utxoPubKey = accountKey  \n .derive(0) // external  \n .derive(0)  \n .to_public();  \n  \nconst stakeKey = accountKey  \n .derive(2) // chimeric  \n .derive(0)  \n .to_public();`\n\n## BIP39 Entropy[​](#bip39-entropy \"Direct link to BIP39 Entropy\")\n\nTo generate a `BIP32PrivateKey` from a BIP39 recovery phrase it must be first converted to entropy following the [BIP39 protocol]. This library does not directly handle that, but once entropy is created it is possible to use `Bip32PrivateKey.from_bip39_entropy(entropy, password)`. For more information see the [CIP3](https://github.com/cardano-foundation/CIPs/pull/3) Cardano improvement proposal. The code below uses the `bip39` npm package to generate a root `BIP32PrivateKey` from a BIP39 mnemonic.\n\n`BIP32PrivateKey`\n`Bip32PrivateKey.from_bip39_entropy(entropy, password)`\n`bip39`\n`BIP32PrivateKey`\n`import { mnemonicToEntropy } from 'bip39';  \n  \nconst entropy = mnemonicToEntropy(  \n [ \"test\", \"walk\", \"nut\", \"penalty\", \"hip\", \"pave\", \"soap\", \"entry\", \"language\", \"right\", \"filter\", \"choice\" ].join(' ')  \n);  \n  \nconst rootKey = CardanoWasm.Bip32PrivateKey.from_bip39_entropy(  \n Buffer.from(entropy, 'hex'),  \n Buffer.from(''),  \n);`\n\n## Use in Addresses[​](#use-in-addresses \"Direct link to Use in Addresses\")\n\nOnce we have reached the desired derivation path, we must convert the `BIP32PrivateKey` or `BIP32PublicKey` to a `PrivateKey` or `PublicKey` by calling `.to_raw_key()` on them with the exception of Byron addresses.\nFor example, to create an address using the `utxoPubKey` and `stakeKey` in the first example, we can do:\n\n`BIP32PrivateKey`\n`BIP32PublicKey`\n`PrivateKey`\n`PublicKey`\n`.to_raw_key()`\n`utxoPubKey`\n`stakeKey`\n`// base address with staking key  \nconst baseAddr = CardanoWasm.BaseAddress.new(  \n CardanoWasm.NetworkInfo.mainnet().network_id(),  \n CardanoWasm.StakeCredential.from_keyhash(utxoPubKey.to_raw_key().hash()),  \n CardanoWasm.StakeCredential.from_keyhash(stakeKey.to_raw_key().hash()),  \n);  \n  \n// enterprise address without staking ability, for use by exchanges/etc  \nconst enterpriseAddr = CardanoWasm.EnterpriseAddress.new(  \n CardanoWasm.NetworkInfo.mainnet().network_id(),  \n CardanoWasm.StakeCredential.from_keyhash(utxoPubKey.to_raw_key().hash())  \n);  \n  \n// pointer address - similar to Base address but can be shorter, see formal spec for explanation  \nconst ptrAddr = CardanoWasm.PointerAddress.new(  \n CardanoWasm.NetworkInfo.mainnet().network_id(),  \n CardanoWasm.StakeCredential.from_keyhash(utxoPubKey.to_raw_key().hash()),  \n CardanoWasm.Pointer.new(  \n 100, // slot  \n 2, // tx index in slot  \n 0 // cert indiex in tx  \n )  \n);  \n  \n// reward address - used for withdrawing accumulated staking rewards  \nconst rewardAddr = CardanoWasm.RewardAddress.new(  \n CardanoWasm.NetworkInfo.mainnet().network_id(),  \n CardanoWasm.StakeCredential.from_keyhash(stakeKey.to_raw_key().hash())  \n);  \n  \n// bootstrap address - byron-era addresses with no staking rights  \nconst byronAddr = CardanoWasm.ByronAddress.icarus_from_key(  \n utxoPubKey, // Ae2* style icarus address  \n CardanoWasm.NetworkInfo.mainnet().protocol_magic()  \n);`\n\nNote that the byron-era address can only be created in this library from icarus-style addresses that start in `Ae2` and that Daedalus-style addresses starting in `Dd` are not directly supported.\n\n`Ae2`\n`Dd`\n\nThese are all address variant types with information specific to its address type. There is also an `Address` type which represents any of those variants, which is the type use in most parts of the library. For example to create a `TransactionOutput` manually we would have to first convert from one of the address variants by doing:\n\n`Address`\n`TransactionOutput`\n`const address = baseAddress.to_address();  \n  \nconst output = CardanoWasm.TransactionOutput(address, BigNum.from_str(\"365\"));`\n\nIf the address is already a Shelley address in raw bytes or a bech32 string we can create it directly via:\n\n`const addr = CardanoWasm.Address.from_bech32(\"addr1vyt3w9chzut3w9chzut3w9chzut3w9chzut3w9chzut3w9cj43ltf\");`\n\n## Other Key Types[​](#other-key-types \"Direct link to Other Key Types\")\n\nConversion between `cardano-cli` 128-byte `XPrv` keys and `BIP32PrivateKey` is also supported:\n\n`cardano-cli`\n`XPrv`\n`BIP32PrivateKey`\n`const bip32PrivateKey = CardanoWasm.BIP32PrivateKey.from_128_xprv(xprvBytes);  \nassert(xprvBytes == CardanoWasm.BIP32PrivateKey.to_128_xprv());`\n\n96-byte `XPrv` keys are identical to `BIP32PrivateKey`s byte-wise and no conversion is needed.\nFor more details see [this document](https://docs.cardano.org/projects/cardano-node/en/latest/stake-pool-operations/keys_and_addresses.html) regarding legacy keys.\n\n`XPrv`\n`BIP32PrivateKey`\n\nThere is also `LegacyDaedalusPrivateKey` which is used for creating witnesses for legacy Daedalus `Dd`-type addresses.\n\n`LegacyDaedalusPrivateKey`\n`Dd`\n\n## Serialization-Lib Information[​](#serialization-lib-information \"Direct link to Serialization-Lib Information\")\n\nThis page was generated automatically from: [https://github.com/Emurgo/cardano-serialization-lib](https://github.com/Emurgo/cardano-serialization-lib/tree/master/doc/getting-started/generating-keys.md).",
  "images": [],
  "extraction_metadata": {
    "batch_number": 4,
    "extraction_timestamp": "2025-09-19T14:04:34.999822",
    "extraction_time": 3.8223392963409424,
    "source": "tavily_api_raw"
  }
}