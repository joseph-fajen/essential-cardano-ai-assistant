{
  "url": "https://developers.cardano.org/docs/get-started/cardano-wallet-js",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Get Started with cardano-wallet-js\n\n## cardano-wallet-js[​](#cardano-wallet-js \"Direct link to cardano-wallet-js\")\n\n`cardano-wallet-js` is a javascript/typescript SDK for Cardano with several functionalities. You can use it as a client for the official [cardano-wallet](https://github.com/cardano-foundation/cardano-wallet) and also to create Native Tokens and NFTs.\n\n`cardano-wallet-js`\n\n## Table of Contents[​](#table-of-contents \"Direct link to Table of Contents\")\n\n## Introduction[​](#introduction \"Direct link to Introduction\")\n\nThe official cardano-wallet by IOHK exposes a REST api/CLI interface which allows\nclients to perform common tasks on the cardano-blockchain, such as:\n\nOur project aims to provide an easy to use Javascript SDK for programmers, instead of\nexposing the raw REST structure to you.\n\n## Requirements[​](#requirements \"Direct link to Requirements\")\n\nBefore start using the library you will need a `cardano-wallet` server running. If you have docker available you can just\ndownload the `docker-composer.yml` they provide and start it using `docker-compose`:\n\n`cardano-wallet`\n`docker-composer.yml`\n`docker-compose`\n`wget https://raw.githubusercontent.com/input-output-hk/cardano-wallet/master/docker-compose.yml  \nNETWORK=testnet docker-compose up`\n\nYou can find more information about different options to start the cardano-wallet server [here](https://github.com/cardano-foundation/cardano-wallet)\n\n## Installation[​](#installation \"Direct link to Installation\")\n\nUsing npm:\n\n`npm i cardano-wallet-js`\n\n## Usage[​](#usage \"Direct link to Usage\")\n\nTo begin, start with a `WalletServer`. It allows you to connect to some remote `cardano-wallet` service.\n\n`WalletServer`\n`cardano-wallet`\n\n### Connecting to a cardano-wallet service[​](#connecting-to-a-cardano-wallet-service \"Direct link to Connecting to a cardano-wallet service\")\n\n`const { WalletServer } = require('cardano-wallet-js');  \nlet walletServer = WalletServer.init('http://{your-server-host}:{port}/v2');`\n\n### Blockchain Information[​](#blockchain-information \"Direct link to Blockchain Information\")\n\nFirst you can try is getting some blockchain information like: (network parameters, information and clock)\n\nGet network information\n\n`let information = await walletServer.getNetworkInformation();  \nconsole.log(information);`\n\nThis will print out something like this:\n\n`{  \n \"network_tip\": {  \n \"time\": \"2021-04-12T21:59:25Z\",  \n \"epoch_number\": 125,  \n \"absolute_slot_number\": 23895549,  \n \"slot_number\": 265149  \n },  \n \"node_era\": \"mary\",  \n \"node_tip\": {  \n \"height\": {  \n \"quantity\": 0,  \n \"unit\": \"block\"  \n },  \n \"time\": \"2019-07-24T20:20:16Z\",  \n \"epoch_number\": 0,  \n \"absolute_slot_number\": 0,  \n \"slot_number\": 0  \n },  \n \"sync_progress\": {  \n \"status\": \"syncing\",  \n \"progress\": {  \n \"quantity\": 0,  \n \"unit\": \"percent\"  \n }  \n },  \n \"next_epoch\": {  \n \"epoch_start_time\": \"2021-04-14T20:20:16Z\",  \n \"epoch_number\": 126  \n }  \n}`\n\nGet network parameters\n\n`let parameters = await walletServer.getNetworkParameters();  \nconsole.log(parameters);`\n\nThis will print out something like this:\n\n`{  \n \"slot_length\": {  \n \"quantity\": 1,  \n \"unit\": \"second\"  \n },  \n \"decentralization_level\": {  \n \"quantity\": 100,  \n \"unit\": \"percent\"  \n },  \n \"genesis_block_hash\": \"96fceff972c2c06bd3bb5243c39215333be6d56aaf4823073dca31afe5038471\",  \n \"blockchain_start_time\": \"2019-07-24T20:20:16Z\",  \n \"desired_pool_number\": 500,  \n \"epoch_length\": {  \n \"quantity\": 432000,  \n \"unit\": \"slot\"  \n },  \n \"eras\": {  \n \"shelley\": {  \n \"epoch_start_time\": \"2020-07-28T20:20:16Z\",  \n \"epoch_number\": 74  \n },  \n \"mary\": {  \n \"epoch_start_time\": \"2021-02-03T20:20:16Z\",  \n \"epoch_number\": 112  \n },  \n \"byron\": {  \n \"epoch_start_time\": \"2019-07-24T20:20:16Z\",  \n \"epoch_number\": 0  \n },  \n \"allegra\": {  \n \"epoch_start_time\": \"2020-12-15T20:20:16Z\",  \n \"epoch_number\": 102  \n }  \n },  \n \"active_slot_coefficient\": {  \n \"quantity\": 5,  \n \"unit\": \"percent\"  \n },  \n \"security_parameter\": {  \n \"quantity\": 2160,  \n \"unit\": \"block\"  \n },  \n \"minimum_utxo_value\": {  \n \"quantity\": 1000000,  \n \"unit\": \"lovelace\"  \n }  \n}`\n\nGet network clock\n\n`let clock = await walletServer.getNetworkClock();  \nconsole.log(clock);`\n\nThis will print out something like this:\n\n`{  \n \"status\": \"available\",  \n \"offset\": {  \n \"quantity\": 405623,  \n \"unit\": \"microsecond\"  \n }  \n}`\n\n## Useful operations[​](#useful-operations \"Direct link to Useful operations\")\n\n### Generate Recovery Phrases[​](#generate-recovery-phrases \"Direct link to Generate Recovery Phrases\")\n\nThe recovery phrase generation relies on [bip39](https://github.com/bitcoinjs/bip39).\n\n`const { Seed } = require('cardano-wallet-js');  \n   \n// generate a recovery phrase of 15 words (default)  \nlet recoveryPhrase = Seed.generateRecoveryPhrase();  \nconsole.log(recoveryPhrase);  \n  \nOutput:  \n> \"hip dust material keen buddy fresh thank program stool ill regret honey multiply venture imitate\"`\n\nThe recovery phrase is the only way you can restore your wallet and you **SHOULD KEEP IT SECURE AND PRIVATE**. You'll get a completely different recovery phrase each time you execute the method.\n\nFor convenience, you can convert the recovery phrase into an array using this:\n\n`let words = Seed.toMnemonicList(recoveryPhrase);  \nconsole.log(words);  \n  \nOutput:  \n> ['hip', 'dust', 'material', 'keen', 'buddy', 'fresh', 'thank', 'program', 'stool', 'ill', 'regret', 'honey', 'multiply', 'venture', 'imitate']`\n\n### Create or restore a wallet[​](#create-or-restore-a-wallet \"Direct link to Create or restore a wallet\")\n\nIn this example we are going to create a new wallet. Have in mind that the method `createOrRestoreShelleyWallet` creates a new wallet if it doesn't exist or restore an existent wallet:\n\n`createOrRestoreShelleyWallet`\n`const { Seed, WalletServer } = require('cardano-wallet-js');  \n   \nlet walletServer = WalletServer.init('http://you.server.com');  \nlet recoveryPhrase = Seed.generateRecoveryPhrase();  \nlet mnemonic_sentence = Seed.toMnemonicList(recoveryPhrase);  \nlet passphrase = 'tangocrypto';  \nlet name = 'tangocrypto-wallet';  \n   \nlet wallet = await walletServer.createOrRestoreShelleyWallet(name, mnemonic_sentence, passphrase);`\n\nList wallets:\n\n`let wallets = await walletServer.wallets();`\n\nGet wallet by Id:\n\n`let wallets = await walletServer.wallets();  \nlet id = wallets[0].id;  \nlet wallet = await walletServer.getShelleyWallet(id);`\n\nGet wallet's utxo statistics:\n\n`let statistics = await wallet.getUtxoStatistics();`\n\nStatistics will contain the UTxOs distribution across the whole wallet, in the form of a histogram similar to the one below.\n![Utxo Histogram](https://www.tangocrypto.com/images/cardano-wallet-js-utxo-histogram.png)\n\n![Utxo Histogram](https://www.tangocrypto.com/images/cardano-wallet-js-utxo-histogram.png)\n\nRemove wallet:\n\n`await wallet.delete();`\n\nRename wallet:\n\n`let newName = 'new-name';  \nwallet = await wallet.rename(newName);`\n\nChange wallet passphrase:\n\n`let oldPassphrase = 'tangocrypto';  \nlet newPassphrase = 'new-passphrase';  \nwallet = await wallet.updatePassphrase(oldPassphrase, newPassphrase);`\n\nThe wallet itself doesn't hold the passphrase, you can check it's correctly updated trying to call a method needing the passphrase e.g: `sendPayment`\n\n`sendPayment`\n\n### Wallet addresses[​](#wallet-addresses \"Direct link to Wallet addresses\")\n\nCardano wallets are Multi-Account Hierarchy Deterministic that follow a variation of BIP-44 described [here](https://github.com/input-output-hk/implementation-decisions/blob/e2d1bed5e617f0907bc5e12cf1c3f3302a4a7c42/text/1852-hd-chimeric.md). All the addresses are derived from a root key (is like a key factory) which you can get from the recovery phrase. Also the wallets will always have 20 \"consecutive\" unused addresses, so anytime you use one of them new address will be \"discovered\" to keep the rule.\n\n`let addresses = await wallet.getAddresses(); // list will contain at least 20 address`\n\nGet unused addresses:\n\n`let unusedAddresses = await wallet.getUnusedAddresses();`\n\nGet used addresses:\n\n`let usedAddresses = await wallet.getUsedAddresses();`\n\nYou can create/discover next unused address:\n\n`// you'll get the n-th address where n is the current addresses list length   \nlet address = await wallet.getNextAddress();   \n  \n// you can also pass the specific index  \nlet address = await wallet.getAddressAt(45);`\n\n### Wallet balances[​](#wallet-balances \"Direct link to Wallet balances\")\n\nWhen you create a wallet the initial balance is 0. If you are in the Mainnet you can transfer Ada to this address. If you are on a testnet you can request test tokens from the [Faucet](https://testnets.cardano.org/cardano-testnets/tools/faucet/), just input one of the addresses of your wallet and request funds.\n\n`// get available balance. The balance you can expend  \nlet availableBalance = wallet.getAvailableBalance();  \n  \n// get rewards balance. The balance available to withdraw  \nlet rewardBalance = wallet.getRewardBalance();  \n  \n// get total balance. Total balance is the sum of available balance plus reward balance  \nlet totalBalance = wallet.getTotalBalance();`\n\n### Wallet delegation[​](#wallet-delegation \"Direct link to Wallet delegation\")\n\nThe wallet has information about whether already delegate on a stake pool or not\n\n`let delegation = wallet.getDelegation();  \nconsole.log(delegation);`\n\nIt the wallet is not delegate to any stake pool the output should be something similar to this:\n\n`{  \n \"next\": [],  \n \"active\": {  \n \"status\": \"not_delegating\"  \n }  \n}`\n\nIf you start delegating (see [Stake pool section](#stake-pool-operations-with-the-wallet) the action will not take effect immediately but the `next` property will indicate when the delegation will finally take effect.\nThe delegation meanwhile should look like this:\n\n`next`\n`{  \n \"next\": [{  \n \"status\": \"delegating\",  \n \"changes_at\": {  \n \"epoch_start_time\": \"2021-04-15T15:03:27Z\",  \n \"epoch_number\": 10  \n },  \n \"target\": \"pool1as50x0wtumtyqzs7tceeh5ry0syh8jnvpnuu9wlxswxuv48sw4w\"  \n }],  \n \"active\": {  \n \"status\": \"not_delegating\"  \n }  \n}`\n\nProperty `changes_at` will indicate the epoch at the delegation will take effect\n\n`changes_at`\n\nIf we ask again after/during the epoch 10, we should get the delegation in place:\n\n`// refresh the wallet if you are using the same object. This will fetch the info from the blockchain  \nawait wallet.refresh();  \n  \nlet delegation = wallet.getDelegation();  \nconsole.log(delegation);  \n  \nOutput:  \n> {  \n next: [],  \n active: {  \n status: 'delegating',  \n target: 'pool1as50x0wtumtyqzs7tceeh5ry0syh8jnvpnuu9wlxswxuv48sw4w'  \n }  \n }`\n\n### Stake pool operations with the wallet[​](#stake-pool-operations-with-the-wallet \"Direct link to Stake pool operations with the wallet\")\n\nGet stake pool ranking list by member rewards:\n\n`let stake = 1000000000;  \nlet pools = await walletServer.getStakePools(stake);`\n\nYou'll get pool ordered by `non_myopic_member_rewards` which basically means from highest to lower expected rewards. By default the wallet server\nisn't configured to fetch the pool's metadata (e.g. ticker, name, homepage) but you can specify it through the update settings functionality, see Update Settings section below.\n\n`non_myopic_member_rewards`\n\nEstimate delegation fee:\n\n`let fee = await wallet.estimateDelegationFee();`\n\nThe very first time you delegate to a pool you'll be charged an extra 2 ADA. This extra fee won't be included on the response.\n\nDelegate to stake pool:\n\n`let passphrase = 'tangocrypto';  \n// choose the first pool from the previous ranking list, but you can select whatever you want.  \nlet pool = pools[0];   \nlet transaction = await wallet.delegate(pool.id, passphrase);`\n\nThe transaction status initially is set to `pending`, so you should keep tracking the transaction using the `id` in order to make sure the final status (e.g. `in_ledger`). You can learn more about the transaction's life cycle [here](https://github.com/cardano-foundation/cardano-wallet/wiki/About-Transactions-Lifecycle).\nFor delegate to another stake pool use the same method above specifying a different stake pool.\n\n`pending`\n`id`\n`in_ledger`\n\nWithdraw stake pool's rewards:\n\n`let passphrase = 'tangocrypto';  \n  \n// select the address to receive the rewards  \nlet address = (await wallet.getUsedAddresses())[0];  \n// get the reward balance available to withdraw  \nlet rewardBalance = wallet.getRewardBalance();  \n  \nlet transaction = await wallet.withdraw(passphrase, [address], [rewardBalance]);`\n\nYou can send the rewards to multiple addresses splitting up the rewardBalance for each one. Also you can send it to any valid address whether it's in your wallet or not.\n\nStop delegating:\n\n`let transaction = await wallet.stopDelegation(passphrase);`\n\nStake pool maintenance actions:\n\n`let maintenanceActions = await walletServer.stakePoolMaintenanceActions();`\n\nPossible values are:\n\nMaintenance actions will depend on whether or not the wallet server is using a Stakepool Metadata Aggregation Server (SMASH).\n\nManually trigger Garbage Collection:\n\n`await walletServer.triggerStakePoolGarbageCollection();`\n\n### Wallet transactions[​](#wallet-transactions \"Direct link to Wallet transactions\")\n\nGet wallet transactions:\n\n`// get all wallet transactions  \nlet transactions = await wallet.getTransactions();  \n  \n// filter by start and end date  \nlet start = new Date(2021, 0, 1); // January 1st 2021;  \nlet end = new Date(Date.now());  \nlet transactions = await wallet.getTransactions(start, end);`\n\nGet transaction details:\n\n`let transaction = await wallet.getTransaction(tx.id);`\n\nGet payment fees:\n\n`let receiverAddress = new AddressWallet('addr1q99q78gt2898zgu2dcswf2yuxj6vujcqece38rycc7wsncl5lx8y....');  \nlet amount = 5000000; // 5 ADA  \nlet estimatedFees = await senderWallet.estimateFee([receiverAddress], [amount]);`\n\nSend payment transfer. Notice that you don't have to calculate the minimum fee, the SDK does that for you:\n\n`let passphrase = 'tangocrypto';  \n  \nlet receiverAddress = [new AddressWallet('addr1q99q78gt2898zgu2dcswf2yuxj6vujcqece38rycc7wsncl5lx8y....')];  \nlet amounts = [5000000]; // 5 ADA  \nlet transaction = await senderWallet.sendPayment(passphrase, receiverAddress, amounts);`\n\nYou can pass a list of address and amount. We expect both list have the same length where elements on each list is index related to the other.\nYou can think of it as sending `amounts[i]` to `addresses[i]`.\n\n`amounts[i]`\n`addresses[i]`\n\nSend payment transfer with metadata:\n\nMetadata can be expressed as a JSON object with some restrictions:\n\nFor more information check [here](https://github.com/cardano-foundation/cardano-wallet/wiki/TxMetadata).\n\n`let passphrase = 'tangocrypto';  \n  \nlet receiverAddress = [new AddressWallet('addr1q99q78gt2898zgu2dcswf2yuxj6vujcqece38rycc7wsncl5lx8y....')];  \nlet amounts = [5000000]; // 5 ADA  \n  \nlet metadata = ['abc', '2512a00e9653fe49a44a5886202e24d77eeb998f', 123];  \nlet transaction = await senderWallet.sendPayment(passphrase, receiverAddress, amounts, metadata);`\n\nPlease note that metadata provided in a transaction will be stored on the blockchain forever. Make sure not to include any sensitive data, in particular personally identifiable information (PII).\n\nSend a more complex metadata object:\n\n`let passphrase = 'tangocrypto';  \n  \n// receiver address  \nlet receiverAddress = [new AddressWallet('addr1q99q78gt2898zgu2dcswf2yuxj6vujcqece38rycc7wsncl5lx8y....')];  \nlet amounts = [5000000]; // 5 ADA  \n  \nlet metadata: any = {0: 'hello', 1: Buffer.from('2512a00e9653fe49a44a5886202e24d77eeb998f', 'hex'), 4: [1, 2, {0: true}], 5: {'key': null, 'l': [3, true, {}]}, 6: undefined};  \nlet transaction = await senderWallet.sendPayment(passphrase, receiverAddress, amounts, metadata);`\n\nValues like boolean, null and undefined are passed as string (e.g \"true\", \"null\", \"undefined\").\n\nForget transaction:\nIf for some reason your transaction hang on status `pending`, for a long period, you can consider to \"cancel\" it.\n\n`pending`\n`wallet.forgetTransaction(transaction.id)`\n\nA transaction, when sent, cannot be cancelled. One can only request forgetting about it in order to try spending (concurrently) the same UTxO in another transaction. But, the transaction may still show up later in a block and therefore, appear in the wallet.\n\n### Submit external transaction[​](#submit-external-transaction \"Direct link to Submit external transaction\")\n\nYou can pass in a transaction created externally (by other tools) and submit it into the blockchain. You can use this library to create the transaction\noffline as well. Here is an example:\n\n`// recovery phrase, this should be the same you use to create the wallet (see Wallet section)  \nlet recovery_phrase = [...];  \n  \n// blockchain config, this is where you can find protocol params, slotsPerKESPeriod etc.  \n// This lib comes with Mainnet, Testnet and LocalCluster config, but you should pass your own to make sure they are up to date.  \n// You can find the latest config files here: https://hydra.iohk.io/build/6498473/download/1/index.html  \nlet config = { ..., \"protocolParams\": {... \"minFeeA\": 44, ..., \"minFeeB\": 155381, ...} }  \n  \n// get first unused wallet's address  \nlet addresses = (await wallet.getUnusedAddresses()).slice(0, 1);  \nlet amounts = [1000000];  \n  \n// get ttl   \nlet info = await walletServer.getNetworkInformation();  \nlet ttl = info.node_tip.absolute_slot_number * 12000;  \n  \n// you can include metadata  \nlet data: any = {0: 'hello', 1: Buffer.from('2512a00e9653fe49a44a5886202e24d77eeb998f', 'hex'), 4: [1, 2, {0: true}], 5: {'key': null, 'l': [3, true, {}]}, 6: undefined};  \n  \n// get the tx structure with all the necessary components (inputs, outputs, change, etc).  \nlet coinSelection = await wallet.getCoinSelection(addresses, amounts, data);  \n  \n// get the signing keys (can be offline)  \nlet rootKey = Seed.deriveRootKey(recovery_phrase);   \nlet signingKeys = coinSelection.inputs.map(i => {  \n let privateKey = Seed.deriveKey(rootKey, i.derivation_path).to_raw_key();  \n return privateKey;  \n});  \n  \n// build and sign tx (can be offline)  \n// include the metadata in the build and sign process  \nlet metadata = Seed.buildTransactionMetadata(data);  \nlet txBuild = Seed.buildTransaction(coinSelection, ttl, {metadata: metadata, config: config});  \nlet txBody = Seed.sign(txBuild, signingKeys, metadata);  \n  \n// submit the tx into the blockchain  \nlet signed = Buffer.from(txBody.to_bytes()).toString('hex');  \nlet txId = await walletServer.submitTx(signed);`\n\n### Key handling[​](#key-handling \"Direct link to Key handling\")\n\nThere are a couple of methods you can use to derive and get private/public key pairs. For more info check [here](https://github.com/input-output-hk/technical-docs/blob/main/cardano-components/cardano-wallet/doc/About-Address-Derivation.md).\n\nGet root key from recovery phrase\n\n`let phrase = [...];  \nlet rootKey = Seed.deriveRootKey(phrase);  \nconsole.log(rootKey.to_bech32());  \n  \nOutput:  \n> \"xprv...\"`\n\nDerive private/signing key (also known as spending key) from root key\n\n`let rootKey = Seed.deriveRootKey(phrase);  \nlet privateKey = Seed.deriveKey(rootKey, ['1852H','1815H','0H','0','0']).to_raw_key();  \nconsole.log(privateKey.to_bech32());  \n   \nOutput:  \n> \"ed25519e_sk1...\"`\n\nDerive account key from root\n\n`let rootKey = Seed.deriveRootKey(phrase);  \nlet accountKey = Seed.deriveAccountKey(rootKey, 0);  \nconsole.log(accountKey.to_bech32());  \n  \nOutput:  \n> \"xprv...\"`\n\nAll the method mentioned above return a `Bip32PrivateKey` which you can use to keep deriving and generating keys and addresses check [here](/docs/get-started/cardano-serialization-lib/overview) for more info. For example, assuming you have `cardano-serialization-lib` installed,\nyou can get a stake address like this:\n\n`Bip32PrivateKey`\n`cardano-serialization-lib`\n`let rootKey = Seed.deriveRootKey(phrase);  \nlet stakePrvKey = Seed.deriveKey(rootKey, ['1852H','1815H','0H','2','0']).to_raw_key();  \nconst stakePubKey = stakePrvKey.to_public();  \n  \nconst rewardAddr = RewardAddress.new(  \nNetworkInfo.mainnet().network_id(),  \nStakeCredential.from_keyhash(stakePubKey.hash())  \n)  \n.to_address();  \nconsole.log(rewardAddr.to_bech32());  \n  \nOutput:  \n> \"stake...\"`\n\nSign and verify a message using a private/public key pair.\n\n`let message = 'Hello World!!!';  \nconst rootKey = Seed.deriveRootKey(phrase);  \nconst accountKey = Seed.deriveAccountKey(rootKey);`\n`// we'll use the stake private/public key at 0 in this case but you can use whatever private/public key pair.  \nconst stakePrvKey = accountKey  \n .derive(CARDANO_CHIMERIC) // chimeric  \n .derive(0);  \n  \nconst privateKey = stakePrvKey.to_raw_key();  \nconst publicKey = privateKey.to_public();  \n  \nconst signed = Seed.signMessage(privateKey, message);  \nconst verify_result = Seed.verifyMessage(publicKey, message, signed);  \n  \nOutput:  \n> True`\n\n### Native Tokens[​](#native-tokens \"Direct link to Native Tokens\")\n\nYou can create native tokens just creating a transaction with a couple of differences, here is an example:\n\n`// address to hold the minted tokens. You can use which you want.  \nlet addresses = [(await wallet.getAddresses())[0]];  \n  \n// blockchain config, this is where you can find protocol params, slotsPerKESPeriod etc.  \n// This lib comes with Mainnet, Testnet and LocalCluster config (Config.Mainnet, Config.Testnet and Config.LocalCluster), but you may consider provide your own to make sure they are up to date.  \n// You can find the latest config files here: https://hydra.iohk.io/build/6498473/download/1/index.html  \nlet config = { ..., \"protocolParams\": {... \"minFeeA\": 44, ..., \"minFeeB\": 155381, ...} }  \n  \n// policy public/private keypair  \nlet keyPair= Seed.generateKeyPair();  \nlet policyVKey = keyPair.publicKey;  \nlet policySKey = keyPair.privateKey;  \n  \n// generate single issuer native script  \nlet keyHash = Seed.getKeyHash(policyVKey);  \nlet script = Seed.buildSingleIssuerScript(keyHash);  \n  \n//generate policy id  \nlet scriptHash = Seed.getScriptHash(script);  \nlet policyId = Seed.getPolicyId(scriptHash);  \n  \n// metadata  \nlet data: any = {};  \nlet tokenData: any = {}  \ntokenData[policyId] = {  \n Tango: {  \n arweaveId: \"arweave-id\",  \n ipfsId: \"ipfs-id\",  \n name: \"Tango\",  \n description: \"Tango crypto coin\",  \n type: \"Coin\"  \n }  \n};  \ndata[0] = tokenData;  \n  \n// asset  \nlet asset = new AssetWallet(policyId, \"Tango\", 1000000);  \n  \n// token  \nlet tokens = [new TokenWallet(asset, script, [keyPair])];  \n  \n//scripts  \nlet scripts = tokens.map(t => t.script);  \n  \n// get min ada for address holding tokens  \nlet minAda = Seed.getMinUtxoValueWithAssets([asset], config);  \nlet amounts = [minAda];  \n  \n// get ttl info  \nlet info = await walletServer.getNetworkInformation();  \nlet ttl = info.node_tip.absolute_slot_number * 12000;  \n  \n// get coin selection structure (without the assets)  \nlet coinSelection = await wallet.getCoinSelection(addresses, amounts, data);  \n  \n// add signing keys  \nlet rootKey = Seed.deriveRootKey(payeer.mnemonic_sentence);   \nlet signingKeys = coinSelection.inputs.map(i => {  \n let privateKey = Seed.deriveKey(rootKey, i.derivation_path).to_raw_key();  \n return privateKey;  \n});  \n  \n// add policy signing keys  \ntokens.filter(t => t.scriptKeyPairs).forEach(t => signingKeys.push(...t.scriptKeyPairs.map(k => k.privateKey.to_raw_key())));  \n  \nlet metadata = Seed.buildTransactionMetadata(data);  \n  \n// the wallet currently doesn't support including tokens not previously minted  \n// so we need to include it manually.  \ncoinSelection.outputs = coinSelection.outputs.map(output => {  \n if (output.address === addresses[0].address) {  \n output.assets = tokens.map(t => {  \n let asset: WalletsAssetsAvailable = {  \n policy_id: t.asset.policy_id,  \n asset_name: Buffer.from(t.asset.asset_name).toString('hex'),  \n quantity: t.asset.quantity  \n };  \n return asset;  \n });  \n }  \n return output;  \n});  \n  \n// we need to sign the tx and calculate the actual fee and the build again   \n// since the coin selection doesn't calculate the fee with the asset tokens included  \nlet txBody = Seed.buildTransactionWithToken(coinSelection, ttl, tokens, signingKeys, {data: data, config: config});  \nlet tx = Seed.sign(txBody, signingKeys, metadata, scripts);  \n  \n// submit the tx   \nlet signed = Buffer.from(tx.to_bytes()).toString('hex');  \nlet txId = await walletServer.submitTx(signed);`\n\nYou can check more scripts on `test/assets.ts`, this example is the equivalent to \"RequireSignature\" you can create with JSON:\n\n`test/assets.ts`\n`{  \n \"type\": \"sig\",  \n \"keyHash\": \"e09d36c79dec9bd1b3d9e152247701cd0bb860b5ebfd1de8abb6735a\"  \n}`\n\n### Send Native Tokens[​](#send-native-tokens \"Direct link to Send Native Tokens\")\n\nHere you have two options, either rely on cardano-wallet directly or build the tx by yourself.\n\n#### Using Cardano Wallet[​](#using-cardano-wallet \"Direct link to Using Cardano Wallet\")\n\n`// passphrase  \nlet passphrase = \"your passphrase\";  \nlet policyId = \"your policyId\";  \n  \n// passphrase  \nlet passphrase = \"your passphrase\";  \nlet policyId = \"your policyId\";  \n  \n// blockchain config, this is where you can find protocol params, slotsPerKESPeriod etc.  \n// This lib comes with Mainnet, Testnet and LocalCluster config (Config.Mainnet, Config.Testnet and Config.LocalCluster), but you may consider provide your own to make sure they are up to date.  \n// You can find the latest config files here: https://hydra.iohk.io/build/6498473/download/1/index.html  \nlet config = { ..., \"protocolParams\": {... \"minFeeA\": 44, ..., \"minFeeB\": 155381, ...} }  \n  \n// address to send the minted tokens  \nlet addresses = [new AddressWallet(\"addr......\")];  \nlet asset = new AssetWallet(policyId, \"Tango\", 100);  \n  \n// bind the asset to the address  \nlet assets = {};   \nassets[addresses[0].id] = [asset];  \n  \n// calculate the min ADA to send in the tx  \nlet minAda = Seed.getMinUtxoValueWithAssets([asset], config);  \n  \n// send it using the wallet  \nlet tx = await wallet.sendPayment(passphrase, addresses, [minAda], ['send 100 Tango tokens'], assets);`\n\n#### Building the tx[​](#building-the-tx \"Direct link to Building the tx\")\n\n`// passphrase  \nlet passphrase = \"your passphrase\";  \nlet policyId = \"your policyId\";  \n  \n// blockchain config, this is where you can find protocol params, slotsPerKESPeriod etc.  \n// This lib comes with Mainnet, Testnet and LocalCluster config (Config.Mainnet, Config.Testnet and Config.LocalCluster), but you should pass your own to make sure they are up to date.  \n// You can find the latest config files here: https://hydra.iohk.io/build/6498473/download/1/index.html  \nlet config = { ..., \"protocolParams\": {... \"minFeeA\": 44, ..., \"minFeeB\": 155381, ...} }  \n  \n// address to send the minted tokens  \nlet addresses = [new AddressWallet(\"addr......\")];  \nlet asset = new AssetWallet(policyId, \"Tango\", 100);  \n  \n// blockchain config, this is where you can find protocol params, slotsPerKESPeriod etc.  \n// This lib comes with Mainnet, Testnet and LocalCluster config, but you may consider provide your own to make sure they are up to date.  \n// You can find the latest config files here: https://hydra.iohk.io/build/6498473/download/1/index.html  \nlet config = { ..., \"protocolParams\": {... \"minFeeA\": 44, ..., \"minFeeB\": 155381, ...} }  \n  \n// bind the asset to the address  \nlet assets = {};   \nassets[addresses[0].id] = [asset];  \n  \n// calculate the min ADA to send in the tx  \nlet minUtxo = Seed.getMinUtxoValueWithAssets([asset], config)  \n  \n// you can include metadata as well  \nlet data = ['send 100 Tango tokens'];  \nlet coinSelection = await wallet.getCoinSelection(addresses, [minUtxo], data, assets);  \nlet info = await walletServer.getNetworkInformation();  \n  \n//build and sign tx  \nlet rootKey = Seed.deriveRootKey(payeer.mnemonic_sentence);   \nlet signingKeys = coinSelection.inputs.map(i => {  \n let privateKey = Seed.deriveKey(rootKey, i.derivation_path).to_raw_key();  \n return privateKey;  \n});  \nlet metadata = Seed.buildTransactionMetadata(data);  \nlet txBuild = Seed.buildTransaction(coinSelection, info.node_tip.absolute_slot_number * 12000, {metadata: metadata, config: config});  \nlet txBody = Seed.sign(txBuild, signingKeys, metadata);  \nlet signed = Buffer.from(txBody.to_bytes()).toString('hex');  \nlet txId = await walletServer.submitTx(signed);`\n\n## Test[​](#test \"Direct link to Test\")\n\n### Stack[​](#stack \"Direct link to Stack\")\n\nyou'll need to install stak >= 1.9.3\nyou can find it here: <https://docs.haskellstack.org/en/stable/README/>.\nYou may need to install the libsodium-dev, libghc-hsopenssl-dev, gmp, sqlite and systemd development libraries for the build to succeed.\n\nAlso you will need `cardano-node` and `cardano-cli` binaries available on your PATH.\n\n`cardano-node`\n`cardano-cli`\n\nThe setup steps are quite simple:\nclone: `cardano-wallet`\nexecute: `stack install cardano-wallet:exe:local-cluster`\nSet a specific port `export CARDANO_WALLET_PORT=7355` so the wallet always start at the same port.\nrun `~/.local/bin/local-cluster`\n\n`cardano-wallet`\n`stack install cardano-wallet:exe:local-cluster`\n`export CARDANO_WALLET_PORT=7355`\n`~/.local/bin/local-cluster`\n\n## References[​](#references \"Direct link to References\")",
  "images": [],
  "extraction_metadata": {
    "batch_number": 4,
    "extraction_timestamp": "2025-09-19T14:04:34.999822",
    "extraction_time": 3.8223392963409424,
    "source": "tavily_api_raw"
  }
}