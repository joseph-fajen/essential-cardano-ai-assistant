{
  "url": "https://developers.cardano.org/docs/smart-contracts/advanced/design-patterns/transaction-level-validation/stake-validators/stake-validator",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Stake Validator\n\n## Table of Contents[​](#table-of-contents \"Direct link to Table of Contents\")\n\n## How to use this document[​](#how-to-use-this-document \"Direct link to How to use this document\")\n\nThe documentation is organized sequentially, starting with basics and progressing to advanced topics for\nbuilding your smart contract application.\nYou can read it in any order or directly access pages relevant to your use case.\nA table of contents on the top facilitates easy navigation between sections.\n\nIt is important to note that all types and functions will be exclusively defined in PlutusTx.\nThis approach aims to establish a common foundation, especially in the context of the growing variety of languages such as Plutarch, Aiken, etc.\n\n## Introduction[​](#introduction \"Direct link to Introduction\")\n\nIn this comprehensive guide, you will discover how to strategically implement the Staking Validator design pattern to enhance your protocol's performance and introduce composability by employing the innovative \"withdraw zero trick.\"\n\n## Why Staking Validators?[​](#why-staking-validators \"Direct link to Why Staking Validators?\")\n\nConsider a scenario as described in the illustration below, with multiple UTXOs at a `Spending Validator`; if your entire protocol logic resides within it, the logic has to run for each UTXO, quickly reaching transaction limits and increasing CPU and memory usage.\n\n`Spending Validator`\n\nThe solution involves the `Spending Validator` checking that the `Staking validator` is called in the same transaction, consolidating the logic to run once at the `Staking Validator`. This significantly reduces script size and simplifies business logic.\n\n`Spending Validator`\n`Staking validator`\n`Staking Validator`\n\n`Staking Validators` play a crucial role, not only in adding logic to stake control but also in minimizing script size and optimizing CPU and memory usage.\nIt's essential to note that staking validators aren't a one-size-fits-all solution; careful evaluation is needed to determine if this design pattern aligns with your specific purpose.\n\n`Staking Validators`\n\n## What are the main features of the Staking Account?[​](#what-are-the-main-features-of-the-staking-account \"Direct link to What are the main features of the Staking Account?\")\n\nThe Staking Account offers to users the ability to:\n\nTo comprehend the essence of the Staking Account, it is imperative to grasp the two foundational models within Cardano.\n\n### The Cardano Model Demystified[​](#the-cardano-model-demystified \"Direct link to The Cardano Model Demystified\")\n\nCardano operates on two primary models:\n\n### What are the components of an Address?[​](#what-are-the-components-of-an-address \"Direct link to What are the components of an Address?\")\n\nCardano address consists of two crucial components.\n\nLet's explore the representation of an address type in Plutus:\n\nConstructing an Address involves specifying the Credential and optionally the StakingCredential\n\n`data Address =   \n Address   \n { addressCredential :: Credential  \n , addressStakingCredential :: Maybe StakingCredential   \n }`\n\nNote: While it is possible to construct addresses without a staking credential, this document will not delve into that aspect.\n\n### What are the component of a Script Address?[​](#what-are-the-component-of-a-script-address \"Direct link to What are the component of a Script Address?\")\n\nAddresses are not only used in wallet, but also in smart contracts, often referred to as scripts.\n\nFor the purpose of this article we are going to create an Script Address by hashing the Spending Validator and the Staking Validator.\n\n#### Constructing the Script address[​](#constructing-the-script-address \"Direct link to Constructing the Script address\")\n\nIn the below code we can see that our address is composed of the Spending Validator and Staking Validator\n\n`scriptAddress =   \n Address   \n (ScriptCredential $ ScriptHash \"SpendingValidatorHash\")   \n (Just $ StakingHash $ ScriptCredential $ ScriptHash \"StakingValidatorHash\")`\n\nOnce you have the script address and following your business logic, now you can lock assets along with datums into the Script Address, therefore associating the new EUTXO and the Script Address with both components `Payment Credential` and `Staking Credential`\n\n`Payment Credential`\n`Staking Credential`\n\n## Let's dive into the implementation[​](#lets-dive-into-the-implementation \"Direct link to Let's dive into the implementation\")\n\nThe strategy involves enforcing the spending validator to require invocation of staking validator, upon each attempted expenditure of the script input.\nFollowing this, the staking validator assumes the responsibility of validating each spending script input to ensure strict adherence to the protocol specifications.\n\nFrom the transaction we are going to specifically focus on the `ScriptContext`\nThis shared context is accessible to all validators within the transaction, enabling the enforcement of certain conditions, such as the presence of the `Staking Validator`.\n\n`ScriptContext`\n`Staking Validator`\n\nSpecifically, every `Spending Validator` is mandated to verify the existence of the `Staking Validator` within the transaction.\n\n`Spending Validator`\n`Staking Validator`\n\nConsider the definition of the `ScriptContext` data type:\n\n`ScriptContext`\n`data ScriptContext =   \n ScriptContext   \n { scriptContextTxInfo :: TxInfo  \n , scriptContextPurpose :: ScriptPurpose   \n }`\n\nWithin the `TxInfo` type, note the importance of the `txInfoWdrl :: Map StakingCredential Integer` field.\n\n`TxInfo`\n`txInfoWdrl :: Map StakingCredential Integer`\n\nThis field encapsulates a Map where each `StakingCredential` serves as a key, paired with its corresponding withdrawal amount as the associated value.\n\n`StakingCredential`\n\nNote: The `txInfoWdrl` contains all the staking credentials attempting to withdraw rewards from their staking accounts. Also keep in mind that the Map type in Plutus Core is implemented as a list of builtin pairs [1](#user-content-fn-1).\n\n`txInfoWdrl`\n`data TxInfo = TxInfo  \n { txInfoInputs :: [TxInInfo] -- ^ Transaction inputs  \n , txInfoReferenceInputs :: [TxInInfo] -- ^ Transaction reference inputs  \n , txInfoOutputs :: [TxOut] -- ^ Transaction outputs  \n , txInfoFee :: Value -- ^ The fee paid by this transaction.  \n , txInfoMint :: Value -- ^ The 'Value' minted by this transaction.  \n , txInfoDCert :: [DCert] -- ^ Digests of certificates included in this transaction  \n , txInfoWdrl :: Map StakingCredential Integer -- ^ Withdrawals  \n , txInfoValidRange :: POSIXTimeRange -- ^ The valid range for the transaction.  \n , txInfoSignatories :: [PubKeyHash] -- ^ Signatures provided with the transaction, attested that they all signed the tx  \n , txInfoRedeemers :: Map ScriptPurpose Redeemer  \n , txInfoData :: Map DatumHash Datum  \n , txInfoId :: TxId -- ^ Hash of the pending transaction (excluding witnesses)  \n }`\n\n## Create a simple Spending Validator[​](#create-a-simple-spending-validator \"Direct link to Create a simple Spending Validator\")\n\nTo implement this validation requirement, a parameterized `Spending Validator` is created as follows:\n\n`Spending Validator`\n`mkValidator :: StakingCredential -> Datum -> Redeemer -> ScriptContext -> Bool  \nmkValidator stakingCred _datum _redeemer context =  \n case PlutusTx.AssocMap.lookup stakingCred $ txInfoWdrl txinfo of  \n Just _ -> True  \n Nothing -> PlutusTx.Prelude.error ()  \n where  \n txinfo = scriptContextTxInfo context`\n\nThe `Spending Validator` utilizes the lookup function to verify the presence of `StakingCredential` of the required `Staking Validator` in `txInfoWdrl` field of `TxInfo`. This enforces invocation of the `Staking Validator`. If this lookup fails, spending of the corresponding UTXO will result in failure.\n\n`Spending Validator`\n`StakingCredential`\n`Staking Validator`\n`txInfoWdrl`\n`TxInfo`\n`Staking Validator`\n\nIt's important to highlight that this approach is often referred to as the `withdraw zero trick`, but it does not enforce the user to withdraw a specific amount, therefore the logic remains independent of the withdrawal amount\n\n`withdraw zero trick`\n\nNote: Please be aware that this validator serves only as a reference. There might be instances where your protocol does not necessarily require the staking validator to be present. This is particularly applicable in situations where, for example, you aim to facilitate a user's withdrawal of assets from the spending script. In such cases, the primary validation is ensuring that the user is appropriately signing the transaction.\n\n## Validating the business logic at Staking Validator[​](#validating-the-business-logic-at-staking-validator \"Direct link to Validating the business logic at Staking Validator\")\n\nAs illustrated below, the spending script performs validation by ensuring the presence of the staking credential corresponding to the staking validator within the transaction.\nThe staking validator, in turn, is responsible for executing the protocol's business logic, which may vary based on the specific use case.\n\nHowever it is a must to consider key components to ensure the efficiency and that there are no exploits in your protocol.\n\n### Protect against Double Satisfaction exploit[​](#protect-against-double-satisfaction-exploit \"Direct link to Protect against Double Satisfaction exploit\")\n\nIn scenarios where the protocol necessitates spending from the script back to a specific output—such as returning funds from the script to the same script, directing them to another script, or transferring assets to a wallet, it is imperative to ensure that each script input is uniquely associated with an output. This preventive measure is essential for mitigating the risk of [Double Satisfaction Attack](https://plutus.readthedocs.io/en/latest/reference/writing-scripts/common-weaknesses/double-satisfaction.html?highlight=double#unique-outputs).\n\nWe have outlined some patterns\n\nThe simplest implementation to ensure the uniqueness of the script outputs is by tagging the serialized input script outref at the output datum level.\nThis prevents that the outputs remain distinct.\n\nNote: This tagging validation should be done at the spending validator.\n\nConsider taking all the inputs list and making sure each input in unique by folding the list and removing the element use,also within this fold function you must introduce your business logic.The drawback of using this folding pattern is that you input list must be return in the recursion of the computation, increasing the execution of your script.\n\nAnother consideration involves filtering all inputs associated with the same spending script hash. This approach necessitates the parametrization of the staking validator with the spending script hash.\nWhen implementing this filtering mechanism, the staking validator requires the spending script hash as a parameter. Since the spending script inherently depends on the staking credential, introducing the spending script hash into the staking validator may not be possible due to the unidirectional dependency nature of the scripts.\nOne potential solution to this challenge is the implementation of a `Multi Validator`. By consolidating both the spending and staking validators, these dependencies can be unified. In this approach, the script hash and staking hash become identical, eliminating the problem posed by unidirectional dependencies.\nIn addition to this you must introduce a list of unique index at the redeemer level which corresponds to each input, and because this list is unique you can use it to validate unique outputs\n\n`Multi Validator`\n\nLastly you can use a redeemer containing one-to-one correlation between script input UTxOs and output UTxOs. This is provided via ordered lists of input/output indices of inputs/ouputs present in the Script Context.\n\n`data StakeValidatorRedeemer = StakeValidatorRedeemer  \n { inputIdxs :: [Integer]  \n , outputIdxs :: [Integer]  \n }`\n\nFor e.g.\n\n`Inputs : [scriptInputA, scriptInputC, randomInput3, scriptInputB, randomInput1, randomInput2] // random inputs are not the concerned script inputs  \nOutputs : [outputA, outputB, outputC, randomOuput1, randomOutput2, randomOutput3]  \nInputIdxs : [0, 1, 3]  \nOutputIdxs : [0, 1, 2]`\n\nHere the validator needs to check that there are no duplicate indices in either of the lists. While its easy to understand and declare indices of outputs (the order in which outputs appear in the tx builder), we cannot control the order of inputs as seen by the script. As inputs are sorted lexicographically based on their output reference, first by Tx#Id and then by Tx#Idx.\n\n## Footnotes[​](#footnote-label \"Direct link to Footnotes\")\n\n[<https://github.com/input-output-hk/plutus/blob/d6382618ae38ce75cdef432e4974809ec466456e/plutus-tx/src/PlutusTx/Builtins/Internal.hs#L473-L476>] [↩](#user-content-fnref-1)",
  "images": [],
  "extraction_metadata": {
    "batch_number": 10,
    "extraction_timestamp": "2025-09-19T14:05:05.551444",
    "extraction_time": 2.0458879470825195,
    "source": "tavily_api_raw"
  }
}