{
  "url": "https://developers.cardano.org/docs/get-started/cli-operations/simple-scripts/",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Simple scripts\n\nCardano is designed to support multiple script languages, and most features\nthat are related to scripts work the same irrespective of the script language\n(or version of a script language).\n\nSince Shelley era, Cardano supports the **Simple script** language, which can be used for\nmulti-signature addresses.\n\nThe Allegra era extends the simple script language with a feature to make scripts\nconditional on time (token locking). This can be used to make address with \"time locks\",\nwhere the funds cannot be withdrawn from a script address until after a certain point in time.\n\nThe Alonzo era brought support for **Plutus scripts**, these are out of the scope of this section.\n\n## Script addresses[​](#script-addresses \"Direct link to Script addresses\")\n\nIn general, addresses (both payment addresses and stake addresses) specify the *authorisation conditions* that must be\nmet for the address to be used. For payment addresses, this means the authorisation conditions for funds to be\nwithdrawn. For stake addresses, this means the authorisation conditions for setting a delegation choice or rewards withdrawal.\n\nBoth payment and stake addresses come in two flavours: *single-key based* or\n*script based*. The key-based addresses use a single cryptographic key per\naddress. The authorisation condition to use the address is that one holds the\nsecret (signing) part of the cryptographic key (for that address) and thus be\nable to make a cryptographic signature for that key.\n\nThe script-based addresses use a script per address. The authorisation\ncondition to use the address is that the *evaluation* of the script for the\naddress results in success. The script expresses the authorisation conditions\nand evaluation of the script tests if those conditions are met. For example, a\nvery simple script might express the condition that one holds a particular\ncryptographic signing key. The script would express that condition by testing\nif the transaction has a cryptographic signature from the appropriate\ncryptographic verification key. Such a script would, of course, be exactly\nequivalent to an ordinary single-key based address: the authorisation\nconditions would be the same! Thus, we can see that single-key based addresses are\nin some sense just a (very common) special case and that script addresses are\nthe general case.\n\nWhen using an address (payment or stake) in a transaction, the transaction must\ncontain the information needed to show that the authorisation conditions for the\nuse of the address are met. This information is known as a *transaction witness*.\nWe say that it *witnesses* the validity of the transaction using the address.\nThe addresses themselves have a *credential* which is information sufficient to\ncheck that a witness is the right witness.\n\nSpecifically, there are two types of such credentials, for key and script\naddresses:\n\n**Key credential** - a key credential is constructed using a *verification\nkey (vk)* (which has corresponding *signing key (sk)*). The credential is the\ncryptographic hash of the verification key *H(vk)*.\n\nThe transaction witness for a key credential consists of the *verification\nkey vk* and the signature of transaction body hash using the *signing key sk*.\n\n**Script credential** - a script credential is the hash of the script.\n\nThe transaction witness for a script credential is the script itself. There are no\nother inputs for the very simple script language introduced in the Shelley era.\nScripts in the Plutus language (once that is available) will require\nadditional inputs which will also form part of the witness.\n\n## Multi-signature scripts[​](#multi-signature-scripts \"Direct link to Multi-signature scripts\")\n\nIn Shelley and later eras, multisig scripts are used to make script addresses\nwhere the authorisation condition for a transaction to use that address is that\nthe transaction has signatures from multiple cryptographic keys. Examples\ninclude M of N schemes, where a transaction can be authorized if at least *M*\ndistinct keys, from a set of *N* keys, sign the transaction.\n\nAs with all scripts, the transaction witness for a multisig script address\nincludes the script itself. The multisig language is so simple that this is\nthe entire witness: there are no other script data inputs. Although the script\nitself is the witness, the script has *conditions* that must be satisfied. The\nconditions for multisig scripts are that the transaction has other ordinary\nkey witnesses. Which combination of key witnesses are acceptable is, of course,\ndetermined by the script.\n\nThe multisig script language is an expression language. Its scripts form an\nexpression tree. The evaluation of the script produces either `true` or `false`.\n\n`true`\n`false`\n\nIn BNF notation, the script expressions follow the following abstract syntax:\n\n`<script> ::= <RequireSignature> <vkeyhash>  \n | <RequireAllOf> <script>*  \n | <RequireAnyOf> <script>*  \n | <RequireMOf> <num> <script>*`\n\nNote that it is recursive. There are no constraints on the nesting or\nsize, except that imposed by the overall transaction size limit (given that\nthe script must be included in the transaction in a script witnesses).\n\nIn more detail, the four multisig constructors are:\n\nRequireSignature: has the hash of a verification key.\n\nThis expression evaluates to `true` if (and only if) the transaction also\nincludes a valid key witness where the witness verification key hashes to the\ngiven hash. In other words, this checks that the transaction is signed by a\nparticular key, identified by its verification key hash.\n\n`true`\n\nRequireAllOf: has a list of multisig sub-expressions.\n\nThis expression evaluates to `true` if (and only if) *all* the sub-expressions\nevaluate to `true`. Following standard mathematical convention, the degenerate\ncase of an empty list evaluates to `true`.\n\n`true`\n`true`\n`true`\n\nRequireAnyOf: has a list of multisig sub-expressions.\n\nThis expression evaluates to `true` if (and only if) *any* the sub-expressions\nevaluate to `true`. That is, if one or more evaluate to `true`. The degenerate\ncase of an empty list evaluates to `false`.\n\n`true`\n`true`\n`true`\n`false`\n\nRequireMOf: has a number M and a list of multisig sub-expressions.\n\nThis expression evaluates to `true` if (and only if) at least M of the\nsub-expressions evaluate to `true`.\n\n`true`\n`true`\n\n## Time locking[​](#time-locking \"Direct link to Time locking\")\n\nIn the Allegra and later eras, the **simple script** language above is\nextended with two additional terms for expressing conditions on the time.\n\nThis extension can be used to make script addresses where it is not possible\nto spend from them until after a certain time. Or, in combination with the\nexisting features, one could make a script where up until a certain time one\ngroup of keys (perhaps M-of-N) is allowed to spend, but after a time another\ngroup of keys is allowed instead.\n\nOn the Cardano blockchain, time is expressed via slot numbers, since time slots\ncorrespond to time. The extra constructors allow expressing that the current\ntime slot number must be before a certain slot, or after a certain slot.\n\nThe BNF notation for the abstract syntax is:\n\n`<script> ::= <RequireSignature> <vkeyhash>  \n | <RequireTimeBefore> <slotno>  \n | <RequireTimeAfter> <slotno>  \n  \n | <RequireAllOf> <script>*  \n | <RequireAnyOf> <script>*  \n | <RequireMOf> <num> <script>*`\n\nThe interpretation of \"before\" and \"after\" is somewhat subtle, and interacts\nwith another transaction feature: transaction validity intervals.\n\nIn the Allegra and later eras transactions have validity intervals. This is the\nrange of slots in which they are valid; the range of slots in which they may be\nincluded into blocks on the blockchain. The transaction can specify the first\nslot in which the transaction can become valid, and the first slot in which the\ntransaction becomes invalid. This is a \"half-open\" interval: the lower bound is\ninclusive and the upper bound is exclusive. Both the lower and the upper ends of\nthis interval are optional, in which case the interpretation is zero or positive\ninfinity respectively.\n\nWith this in mind, we can understand the interpretation of the new expressions:\n\nRequireTimeBefore: has a slot number X.\n\nThis expression evaluates to `true` if (and only if) the upper bound of the\ntransaction validity interval is a slot number Y, and Y < X.\n\n`true`\n\nThis condition guarantees that the actual slot number in which the transaction\nis included is (strictly) less than slot number X.\n\nRequireTimeAfter: has a slot number X.\n\nThis expression evaluates to `true` if (and only if) the lower bound of the\ntransaction validity interval is a slot number Y, and Y >= X.\n\n`true`\n\nThis condition guarantees that the actual slot number in which the transaction\nis included is greater than or equal to slot number X.\n\nOne might reasonably wonder why use this two-stage check via the validity\ninterval rather than more straightforwardly check the actual slot time. The\nreason is to give deterministic script evaluation, which becomes crucial for\nPlutus scripts. In this context, by *deterministic* we mean that the result of the\nscript evaluation depends only on the transaction itself and not any other\ncontext or state of the system. This property is less crucial for this simple\nscript language, but it is better if all the languages behave the same in this\nregard. Even for the simple script language it does still have the advantage\nthat the script itself can be evaluated without needing to know the current slot\nnumber.\n\n## JSON script syntax[​](#json-script-syntax \"Direct link to JSON script syntax\")\n\nMulti-signature scripts can be written using JSON syntax. This is the format\nthat the `cardano-cli` tool accepts.\n\n`cardano-cli`\n\nThere is a JSON form corresponding to each of the six constructors described\nabove. Of course, for the Shelley era, only the basic four are available.\n\n### Type \"sig\"[​](#type-sig \"Direct link to Type \\\"sig\\\"\")\n\nThis corresponds to the \"RequireSignature\" expression above. It specifies the\ntype \"sig\" and the key hash in hex.\n\n`{  \n \"type\": \"sig\",  \n \"keyHash\": \"e09d36c79dec9bd1b3d9e152247701cd0bb860b5ebfd1de8abb6735a\"  \n}`\n\n### Type \"all\"[​](#type-all \"Direct link to Type \\\"all\\\"\")\n\nThis corresponds to the \"RequireAllOf\" expression above. It specifies the type\n\"all\" and a list of scripts as the sub-expressions.\n\nThis example requires signatures from all of three keys, but remember that the\nsub-expressions could be any script type, not just type \"sig\".\n\n`{  \n \"type\": \"all\",  \n \"scripts\":  \n [  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"e09d36c79dec9bd1b3d9e152247701cd0bb860b5ebfd1de8abb6735a\"  \n },  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"a687dcc24e00dd3caafbeb5e68f97ca8ef269cb6fe971345eb951756\"  \n },  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"0bd1d702b2e6188fe0857a6dc7ffb0675229bab58c86638ffa87ed6d\"  \n },  \n ]  \n}`\n\n### Type \"any\"[​](#type-any \"Direct link to Type \\\"any\\\"\")\n\nThis corresponds to the \"RequireAnyOf\" expression above. It specifies the type\n\"any\" and a list of scripts as the sub-expressions.\n\nThis example requires signatures from any of three keys, but remember that the\nsub-expressions could be any script type, not just type \"sig\".\n\n`{  \n \"type\": \"any\",  \n \"scripts\":  \n [  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"d92b712d1882c3b0f75b6f677e0b2cbef4fbc8b8121bb9dde324ff09\"  \n },  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"4d780ed1bfc88cbd4da3f48de91fe728c3530d662564bf5a284b5321\"  \n },  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"3a94d6d4e786a3f5d439939cafc0536f6abc324fb8404084d6034bf8\"  \n }  \n ]  \n}`\n\n### Type \"atLeast\"[​](#type-atleast \"Direct link to Type \\\"atLeast\\\"\")\n\nThis corresponds to the \"RequireMOf\" expression above. It specifies the type\n\"atLeast\", the required number and a list of scripts as the sub-expressions.\n\nThis example requires signatures from two of three keys, but remember that the\nsub-expressions could be any script type, not just type \"sig\".\n\n`{  \n \"type\": \"atLeast\",  \n \"required\": 2,  \n \"scripts\":  \n [  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"2f3d4cf10d0471a1db9f2d2907de867968c27bca6272f062cd1c2413\"  \n },  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"f856c0c5839bab22673747d53f1ae9eed84afafb085f086e8e988614\"  \n },  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"b275b08c999097247f7c17e77007c7010cd19f20cc086ad99d398538\"  \n },  \n ]  \n}`\n\n### Type \"after\"[​](#type-after \"Direct link to Type \\\"after\\\"\")\n\nThis corresponds to the \"RequireTimeAfter\" expression above. It specifies the\ntype \"after\" and the slot number.\n\nThis example requires a signature from a single key and requires that the time\nbe after slot 1000.\n\n`{  \n \"type\": \"all\",  \n \"scripts\":  \n [  \n {  \n \"type\": \"after\",  \n \"slot\": 1000  \n },  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"966e394a544f242081e41d1965137b1bb412ac230d40ed5407821c37\"  \n }  \n ]  \n}`\n\nNote that transactions spending from scripts that use type `after` must provide\nthe lower bound for the transaction validity interval. See below for examples of\nhow to do this using the `cardano-cli`.\n\n`after`\n`cardano-cli`\n\n### Type \"before\"[​](#type-before \"Direct link to Type \\\"before\\\"\")\n\nThis corresponds to the \"RequireTimeBefore\" expression above. It specifies the\ntype \"before\" and the slot number.\n\nThis example allows a signature from one key at any time, or before slot 3000\nit also allows a signature from a second key. That is, up to slot 3000 either\nkey is acceptable, but at slot 3000 and thereafter only one key is acceptable.\n\n`{  \n \"type\": \"any\",  \n \"scripts\":  \n [  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"b275b08c999097247f7c17e77007c7010cd19f20cc086ad99d398538\"  \n },  \n {  \n \"type\": \"all\",  \n \"scripts\":  \n [  \n {  \n \"type\": \"before\",  \n \"slot\": 3000  \n },  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"966e394a544f242081e41d1965137b1bb412ac230d40ed5407821c37\"  \n }  \n ]  \n }  \n ]  \n}`\n\nNote that transactions spending from scripts that use type `before` must provide\nthe lower bound for the transaction validity interval. See below for examples of\nhow to do this using the `cardano-cli`.\n\n`before`\n`cardano-cli`\n\n### Example of using a script for multi-signatures[​](#example-of-using-a-script-for-multi-signatures \"Direct link to Example of using a script for multi-signatures\")\n\nBelow is an example that shows how to use a script. This is a step-by-step\nprocess involving:\n\nThe example is based on using an `all` script.\n\n`all`\n\n#### Sending ada to a script address[​](#sending-ada-to-a-script-address \"Direct link to Sending ada to a script address\")\n\n#### Step 1 - create a script[​](#step-1---create-a-script \"Direct link to Step 1 - create a script\")\n\nFirst, generate the keys that you require witnesses from using the\n`cardano-cli address key-gen` command. Then, construct a script in JSON syntax\nas described above. For this example, we will describe the process using an\n`all` multisig script (`allMultiSigScript.json`) as follows:\n\n`cardano-cli address key-gen`\n`all`\n`allMultiSigScript.json`\n`{  \n \"type\": \"all\",  \n \"scripts\":  \n [  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"e09d36c79dec9bd1b3d9e152247701cd0bb860b5ebfd1de8abb6735a\"  \n },  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"a687dcc24e00dd3caafbeb5e68f97ca8ef269cb6fe971345eb951756\"  \n },  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"0bd1d702b2e6188fe0857a6dc7ffb0675229bab58c86638ffa87ed6d\"  \n }  \n ]  \n}`\n\n#### Step 2 - create a script address[​](#step-2---create-a-script-address \"Direct link to Step 2 - create a script address\")\n\nA script address is required in order to use a script. Construct this as follows:\n\n`cardano-cli address  \n --payment-script-file allMultiSigScript  \n --out-file script.addr`\n\n#### Step 3 - construct and submit a transaction (tx) to the script address[​](#step-3---construct-and-submit-a-transaction-tx-to-the-script-address \"Direct link to Step 3 - construct and submit a transaction (tx) to the script address\")\n\nTo construct and submit a tx to send ada to the script address, construct the\ntransaction body:\n\n`cardano-cli conway transaction build-raw  \n --invalid-hereafter 1000  \n --fee 0  \n --tx-in utxoinput  \n --tx-out \"$(< script.addr) ${amount}\"  \n --out-file txbody`\n\nWhere `amount` is a shell variable you have defined, or replace it with a\nliteral value.\n\n`amount`\n\nCreate the transaction witness:\n\n`cardano-cli conway transaction witness  \n --tx-body-file txbody  \n --signing-key-file utxoSignKey  \n --out-file utxoWitness`\n\nAssemble the transaction witness and the tx body to create the transaction:\n\n`cardano-cli conway transaction assemble  \n --tx-body-file txbody  \n --witness-file utxoWitness  \n --out-file allWitnessesTx`\n\nAfter submitting the above tx, the inputs associated with the script address\nwill be \"guarded\" by the script.\n\n### Sending ada from a script address[​](#sending-ada-from-a-script-address \"Direct link to Sending ada from a script address\")\n\n#### Step 1 - construct the tx body[​](#step-1---construct-the-tx-body \"Direct link to Step 1 - construct the tx body\")\n\n`cardano-cli conway transaction build-raw \\  \n --invalid-hereafter 1000 \\  \n --fee 0 \\  \n --tx-in (txin of script address)  \n --tx-out yourspecifiedtxout \\  \n --out-file spendScriptTxBody`\n\n#### Step 2 - construct required witnesses[​](#step-2---construct-required-witnesses \"Direct link to Step 2 - construct required witnesses\")\n\nTo construct the script witness and three key witnesses required by the example\n`all` script, run the following commands:\n\n`all`\n`cardano-cli conway transaction witness \\  \n --tx-body-file spendScriptTxBody \\  \n --script-file allMultiSigScript \\  \n --out-file scriptWitness  \n  \ncardano-cli conway transaction witness \\  \n --tx-body-file spendScriptTxBody \\  \n --signing-key-file paySignKey1 \\  \n --out-file key1witness  \n  \ncardano-cli conway transaction witness \\  \n --tx-body-file spendScriptTxBody \\  \n --signing-key-file paySignKey2 \\  \n --out-file key2witness  \n  \ncardano-cli conway transaction witness \\  \n --tx-body-file spendScriptTxBody \\  \n --signing-key-file paySignKey3 \\  \n --out-file key3witness`\n\n#### Step 3 - construct and submit the transaction[​](#step-3---construct-and-submit-the-transaction \"Direct link to Step 3 - construct and submit the transaction\")\n\nTo construct and submit a transaction, you must assemble it with the script\nwitness and all the other required key witnesses.\n\n`cardano-cli conway transaction assemble \\  \n --tx-body-file spendScriptTxBody \\  \n --witness-file scriptWitness \\  \n --witness-file key1witness \\  \n --witness-file key2witness \\  \n --witness-file key3witness \\  \n --out-file spendMultiSig`\n\nYou can now submit this tx via `cardano-cli conway transaction submit`!\n\n`cardano-cli conway transaction submit`\n\n### Example of using a script for time locking[​](#example-of-using-a-script-for-time-locking \"Direct link to Example of using a script for time locking\")\n\nIn this example we will use a script that allows spending from an address\nwith a particular key, but only after a certain time.\n\nIt is important to understand the transaction validity interval and how that\nrelates to the script: make sure you have read the time locking section above.\n\nPreviously in Shelley we had a `--invalid-hereafter` flag in the cli which was an upper bound\non when a transaction can be valid i.e the transaction was valid up until that\nslot number. This has been replaced with the `--invalid-before` and\n`--invalid-hereafter` flags as described below.\n\n`--invalid-hereafter`\n`--invalid-before`\n`--invalid-hereafter`\n\nIf you specify only a lower bound on a transaction, with `--invalid-before=X`,\nit is valid in slot X and thereafter. The valid slot interval is:\n\n`--invalid-before=X`\n `[X, infinity)`\n\nIf you specify an upper bound on a transaction, with `--invalid-hereafter=X`,\nit is valid up to but not including slot X. The valid slot interval is:\n\n`--invalid-hereafter=X`\n `[0, X)`\n\nIf you specify both bounds, with `--invalid-before=X --invalid-hereafter=Y`,\nthen the tx is valid in slot X up to but not including slot Y. The valid slot\ninterval is:\n\n`--invalid-before=X --invalid-hereafter=Y`\n `[X, Y)`\n\nWhatever bounds you specify, the slot number in which you submit your\ntransaction has to be within those bounds. For example if you specify\n`--invalid-before=600` but you submit your transaction in slot 500 then it will\nbe rejected.\n\n`--invalid-before=600`\n\nThis interacts with time locking scripts. If you specify a script with\n`\"after\": 1000` then you must specify a `--invalid-before` of at least 1000\nand therefore also submit that transaction in or after slot 1000.\n\n`\"after\": 1000`\n`--invalid-before`\n\nConversely, if you specify a time lock script with `\"before\": 500` you must\nspecify an `--invalid-hereafter` slot of at most 500 and submit the transaction\nbefore slot 500. Remember the upper bound is exclusive: `before: 500` means the\ntransaction is expired in slot 500.\n\n`\"before\": 500`\n`--invalid-hereafter`\n`before: 500`\n\nOnce you have generated your time lock script you need to follow all the same\nsteps as above in the multi-signature script example but with a slight\nmodification of [step 1](#step-1---construct-the-tx-body) which needs to be\namended as follows:\n\nExample time locking script file:\n\n`{  \n \"type\": \"all\",  \n \"scripts\":  \n [  \n {  \n \"type\": \"after\",  \n \"slot\": 1000  \n },  \n {  \n \"type\": \"sig\",  \n \"keyHash\": \"966e394a544f242081e41d1965137b1bb412ac230d40ed5407821c37\"  \n }  \n ]  \n}`\n\nFor `after` scripts we must provide a `--invalid-before` slot that is greater\nthan or equal to the specified slot number in our simple script. In the example\nabove this means >= 1000.\n\n`after`\n`--invalid-before`\n`cardano-cli conway transaction build-raw \\  \n --invalid-before 1000 \\  \n --fee 0 \\  \n --tx-in (txin of script address)  \n --tx-out yourspecifiedtxout \\  \n --out-file spendScriptTxBody`\n\nA simple example for a before-time script is:\n\n`{  \n \"scripts\": [  \n {  \n \"keyHash\": \"966e394a544f242081e41d1965137b1bb412ac230d40ed5407821c37\",  \n \"type\": \"sig\"  \n },  \n {  \n \"slot\": 3000,  \n \"type\": \"before\"  \n }  \n ],  \n \"type\": \"all\"  \n}`\n\nNote that this is not really time locking in the normal sense, and indeed this\nis a very dangerous script to use because any funds left in a script address\nusing this script after time slot 3000 will be locked there permanently!\n\nFor before scripts we must provide a `--invalid-hereafter` slot that is less\nthan or equal to the specified slot number in our simple script. In the example\nabove this means `<= 3000`:\n\n`--invalid-hereafter`\n`<= 3000`\n`cardano-cli conway transaction build-raw \\  \n --invalid-hereafter 3000\\  \n --fee 0 \\  \n --tx-in (txin of script address)  \n --tx-out yourspecifiedtxout \\  \n --out-file spendScriptTxBody`",
  "images": [],
  "extraction_metadata": {
    "batch_number": 5,
    "extraction_timestamp": "2025-09-19T14:04:40.000976",
    "extraction_time": 1.9930140972137451,
    "source": "tavily_api_raw"
  }
}