{
  "url": "https://developers.cardano.org/docs/get-started/technical-concepts/core-blockchain-fundamentals",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Core Blockchain Fundamentals\n\n## Introduction to Cardano: the big picture[​](#introduction-to-cardano-the-big-picture \"Direct link to Introduction to Cardano: the big picture\")\n\nLearn fundamental terms like blockchain, consensus, decentralization delegation and incentives. Understand the big picture of Cardano and why stake pools are so important.\n\nDeveloping Cardano is no small feat. There is no other project that has ever been built to these parameters, combining peer reviewed cryptographic research with an implementation in highly secure Haskell code.\n\nCardano was designed with input from a large global team including leading experts and professors in the fields of computer programming languages, network design and cryptography.\n\nIf you haven't seen it yet, watch the legendary whiteboard video from 2017. Some details are a bit outdated, but it is still worth seeing to understand what Cardano is and where Cardano came from.\n\n## Extended Unspent Transaction Output (EUTXO)[​](#extended-unspent-transaction-output-eutxo \"Direct link to Extended Unspent Transaction Output (EUTXO)\")\n\nCardano is an Unspent Transaction Output (UTXO)-based blockchain, which utilizes a different accounting model for its ledger from other account-based blockchains like Ethereum. Cardano implements an innovative Extended Unspent Transaction Output (EUTXO) model to support multi-assets and smart contracts while maintaining the core advantages of the UTXO approach.\n\n### Understanding the UTXO Foundation[​](#understanding-the-utxo-foundation \"Direct link to Understanding the UTXO Foundation\")\n\nIn a UTXO model, the movement of assets is recorded as a directed graph where transactions consume some UTXOs and create new ones. Think of UTXOs like physical cash - if you have $50, it might be composed of different bill combinations, but the total remains the same. Similarly, your wallet balance is the sum of all unspent UTXOs from previous transactions.\n\n**Transaction outputs** include an address (spending conditions) and a value (assets). Each output has a unique identifier composed of the transaction hash that created it plus its position within that transaction.\n\n**Transaction inputs** reference previous outputs using this unique identifier: the transaction hash and output index. To spend an input, you must provide witnesses (signatures or script validations) that satisfy the spending conditions.\n\nEach UTXO can only be consumed once and as a whole which introduces the concept of 'change', just like cash transactions where you can't split a bill into smaller pieces.\n\n### Atomic Transactions and Genesis Bootstrap[​](#atomic-transactions-and-genesis-bootstrap \"Direct link to Atomic Transactions and Genesis Bootstrap\")\n\nTransactions are atomic operations - either all changes are applied successfully, or none are applied at all. This all-or-nothing approach ensures consistency and prevents partial state updates that could corrupt the ledger.\n\nThis creates an interesting bootstrapping question: if inputs reference previous outputs, where do the first outputs come from? The answer is the **genesis configuration** - an initial agreed-upon state that creates the first UTXOs without requiring inputs.\n\n### UTXO Set Management[​](#utxo-set-management \"Direct link to UTXO Set Management\")\n\nEvery node maintains a complete record of all currently unspent transaction outputs (UTXOs), called the UTXO set or chainstate. This is stored locally and updated with each new block. Your wallet balance is the sum of all UTXOs you control, and wallet software manages these UTXOs to construct new transactions.\n\n### Cardano's EUTXO Innovation[​](#cardanos-eutxo-innovation \"Direct link to Cardano's EUTXO Innovation\")\n\nEUTXO extends the basic UTXO model in two critical ways:\n\nInstead of restricting addresses to simple public key signatures, EUTXO allows addresses to contain complex logic in the form of scripts that determine spending conditions.\n\nOutputs can carry arbitrary data (datum) in addition to addresses and values, enabling scripts to maintain and access local state of a UTxO.\n\nThe EUTXO model combines:\n\nDeep dive into [Cardano's EUTXO accounting model here](https://ucarecdn.com/3da33f2f-73ac-4c9b-844b-f215dcce0628/EUTXOhandbook_for_EC.pdf).\n\n### eUTxO Advantages for Developers[​](#eutxo-advantages-for-developers \"Direct link to eUTxO Advantages for Developers\")\n\n**Parallelization**: Transactions can be processed in parallel as long as they don't consume the same inputs, offering superior scalability. The level of concurrency is limited only by the degree of contention for shared UTXOs.\n\n**Local State**: Unlike account-based models where every transaction affects global state, EUTXO validation occurs locally, preventing many classes of errors and attacks.\n\n**Predictable Fees**: Transaction costs can be calculated precisely off-chain before submission. Unlike other blockchains where network activity can influence gas costs, Cardano's fees are deterministic and fixed at transaction creation time.\n\n**Deterministic Validation**: Transaction success depends only on the transaction itself and its inputs. Users can predict locally (off-chain) how their transaction will impact the ledger state without encountering unexpected validation failures, fees, or state updates. If inputs are available when validated, the transaction is guaranteed to succeed. This contrasts with account-based models, where a transaction can fail mid-script execution.\n\n**Zero-Knowledge Proof Compatibility**: EUTXO's deterministic nature makes it ideal for zero-knowledge scaling solutions. Since transaction outcomes are deterministic and predictable, you can execute complex computations off-chain and generate proofs against known state. The proof can then be verified on-chain without re-executing the computation. This contrasts with account-based models where global state changes unpredictably, making it difficult to construct valid ZK proofs since the state may change between proof generation and verification.\n\n### TPS vs. eUTxO[​](#tps-vs-eutxo \"Direct link to TPS vs. eUTxO\")\n\nWhich is better, high transactions per second or eUTxO?\n\n### Important Development Considerations[​](#important-development-considerations \"Direct link to Important Development Considerations\")\n\nThe UTXO model's graph structure is fundamentally different from the account-based model used by existing smart-contract enabled blockchains. As a result, **design patterns that work for DApps on account-based blockchains do not translate directly to Cardano**. New design patterns are utilized because the underlying representation of data is different.\n\n#### Concurrency and State Management[​](#concurrency-and-state-management \"Direct link to Concurrency and State Management\")\n\nTo maximize parallelism and scaling benefits, developers must architect DApps using multiple UTXOs rather than relying on single shared state. This fundamental shift requires:\n\n#### Multiple UTXOs Design[​](#multiple-utxos-design \"Direct link to Multiple UTXOs Design\")\n\nSmart contracts should split their on-chain state across many UTXOs rather than concentrating it in a single location. This increases concurrency by allowing multiple users to interact with different parts of the contract simultaneously.\n\n#### Avoiding Contention[​](#avoiding-contention \"Direct link to Avoiding Contention\")\n\nSince each UTXO can only be spent once, multiple users trying to access the same UTXO would create contention just like the account-based system on Ethereum and the UTxO model would lose its meaning. Proper design distributes interactions across different UTXOs to minimize this bottleneck.\n\n#### Parallelization Strategy[​](#parallelization-strategy \"Direct link to Parallelization Strategy\")\n\nBy splitting logic across different branches, applications can achieve greater parallelism. This approach is similar to how Bitcoin services split wallets into sub-wallets for better performance.\n\nThe key insight is that **single on-chain state patterns from account-based systems will not achieve concurrency on Cardano**. Instead, developers embrace the EUTXO model's strengths by designing for distributed state and parallel execution from the ground up.\n\n## Transactions[​](#transactions \"Direct link to Transactions\")\n\nCardano transactions are deterministic by design, meaning their behavior and outcomes can be predicted before execution. This predictability extends to validation results, fees, and ledger state changes.\n\n### Transaction Validation[​](#transaction-validation \"Direct link to Transaction Validation\")\n\nTransaction validation on Cardano uses scripts (pieces of code) that implement pure functions returning True or False. Script validation occurs for several actions:\n\nEach transaction specifies all arguments passed to scripts during validation, including user-provided redeemers that serve different purposes depending on the script logic.\n\n### Deterministic Outcomes[​](#deterministic-outcomes \"Direct link to Deterministic Outcomes\")\n\nThe predictable nature of Cardano transactions is ensured by several key factors:\n\nWhether scripts succeed or fail, the outcome and associated ledger changes are predictable for any given transaction.\n\n### Transaction Anatomy and CBOR Format[​](#transaction-anatomy-and-cbor-format \"Direct link to Transaction Anatomy and CBOR Format\")\n\nAt the lowest level, Cardano transactions are binary data encoded using CBOR (Concise Binary Object Representation), a format similar to \"binary JSON\" that provides compact serialization while maintaining structure.\n\n#### CBOR and Cardano Specifications[​](#cbor-and-cardano-specifications \"Direct link to CBOR and Cardano Specifications\")\n\nCBOR allows Cardano to define precise transaction formats in the ledger specifications using CDDL (Concise Data Definition Language). Each Cardano era has its own specification document that defines the exact structure transactions must follow - any deviation causes rejection.\n\nUnderstanding CBOR becomes crucial when debugging transaction failures, as blockchain explorers typically show processed data rather than the raw transaction structure that nodes actually validate.\n\n#### Transaction Structure[​](#transaction-structure \"Direct link to Transaction Structure\")\n\nA complete transaction consists of four main components:\n\n`transaction = [  \n transaction_body, // Core transaction data  \n transaction_witness_set, // Signatures and scripts   \n validity_flag, // Transaction validity  \n auxiliary_data // Metadata (optional)  \n]`\n\n**Transaction Body** contains:\n\n**Transaction Witness Set** contains:\n\n#### Implications[​](#implications \"Direct link to Implications\")\n\n**Input Ordering**: Inputs are automatically sorted lexicographically by (transaction\\_id, index), not by the order you specify. This affects redeemer indexing.\n\n**Script Data Hash**: Any change to redeemers, datums, or protocol parameters requires recalculating this hash. Transaction libraries handle this automatically.\n\n**Two-Phase Validation**: Phase 1 validates basic transaction structure, Phase 2 executes scripts. If Phase 2 fails, collateral is consumed as penalty.\n\nFor complete technical specifications and debugging tools, see the [Cardano Ledger Specifications](https://github.com/IntersectMBO/cardano-ledger) and [Lace Anatomy](https://laceanatomy.com/) for decoding raw transactions.\n\n### Validity Intervals and Time[​](#validity-intervals-and-time \"Direct link to Validity Intervals and Time\")\n\nSmart contract execution on Cardano is fully deterministic, which raises an interesting challenge: how to handle time-dependent logic? Since asking for \"current time\" would break determinism, Cardano uses **validity intervals** to introduce time constraints.\n\n#### How Validity Intervals Work[​](#how-validity-intervals-work \"Direct link to How Validity Intervals Work\")\n\nTransactions can specify a time window during which they're considered valid:\n\nThese intervals are checked during Phase 1 validation, before script execution. This means validators can assume the transaction is within the specified time bounds, enabling deterministic time-based logic.\n\n#### Practical Applications[​](#practical-applications \"Direct link to Practical Applications\")\n\n**Time-locked contracts**: Record a deadline in the datum and check that the transaction's lower bound exceeds that deadline.\n\n**Auction deadlines**: Set an upper bound so bids can only be placed before the auction ends.\n\n### Transaction Latency vs Finality[​](#transaction-latency-vs-finality \"Direct link to Transaction Latency vs Finality\")\n\nUnderstanding the difference between when a transaction appears on-chain versus when it becomes permanent is crucial for dApp development.\n\n**Latency**: Time for a transaction to appear in a block (~20 seconds average block time).\n\n**Finality**: Time for a transaction to become immutable and irreversible. This depends on:\n\nFor most applications, waiting 6-20 confirmations provides really strong finality guarantees. High-value transactions may require more confirmations, while small transactions might accept fewer.\n\n## Transaction Fees[​](#transaction-fees \"Direct link to Transaction Fees\")\n\nTransaction fees on Cardano are deterministic and predictable, calculated using a simple linear formula based on transaction size and computational resources required. This approach ensures users can calculate exact fees before submitting transactions, avoiding the unpredictable fee spikes seen on other blockchains.\n\n### Fee Structure and Formula[​](#fee-structure-and-formula \"Direct link to Fee Structure and Formula\")\n\nCardano uses a straightforward fee calculation: **fee = a × size(tx) + b**\n\nWhere:\n\n### Protocol Parameters and Economic Security[​](#protocol-parameters-and-economic-security \"Direct link to Protocol Parameters and Economic Security\")\n\nBoth parameters `a` and `b` serve crucial economic and security purposes:\n\n`a`\n`b`\n\n**Parameter `a`** covers the resource costs of processing and storing larger transactions. As transaction size increases, more computational and storage resources are required, making this scaling factor essential for covering operational costs.\n\n`a`\n\n**Parameter `b`** provides a base security layer against economic attacks, particularly Distributed Denial-of-Service (DDoS) attacks. By requiring a minimum fee regardless of transaction size, it becomes prohibitively expensive for attackers to flood the network with millions of small transactions.\n\n`b`\n\n### Fee Distribution Model[​](#fee-distribution-model \"Direct link to Fee Distribution Model\")\n\nUnlike many blockchains where fees go directly to block producers, Cardano uses a unique pooled distribution system. Transaction fees are collected and distributed among all stake pools that produced blocks during an epoch, regardless of which specific pool processed each transaction. This approach promotes network stability and fair reward distribution.\n\n### Economic Attack Prevention[​](#economic-attack-prevention \"Direct link to Economic Attack Prevention\")\n\nThe fee structure prevents economic attacks where system operator costs exceed user fees. Without proper fee alignment, users could impose costs on operators without paying proportionally, potentially leading to reduced participation and system instability. Cardano's parameters are designed to ensure fees cover both processing and long-term storage costs.\n\n## Guaranteed Transaction Delivery[​](#guaranteed-transaction-delivery \"Direct link to Guaranteed Transaction Delivery\")\n\nHow dropped transactions happen on cardano and how to ensure we always deliver them into blocks.\n\n## Addresses[​](#addresses \"Direct link to Addresses\")\n\nCardano addresses are used as destinations to send ada on the blockchain. Understanding their structure and types is fundamental to working with the Cardano ecosystem.\n\n### Address Construction and Structure[​](#address-construction-and-structure \"Direct link to Address Construction and Structure\")\n\nCardano addresses are blake2b-224 hash digests of relevant verifying/public keys concatenated with metadata. They are binary sequences consisting of a one-byte header and variable-length payload:\n\n#### Encoding Formats[​](#encoding-formats \"Direct link to Encoding Formats\")\n\n**Shelley addresses** use Bech32 encoding with human-readable prefixes:\n\n`addr`\n`addr_test`\n`stake`\n`stake_test`\n\n**Byron addresses** use Base58 encoding for backward compatibility, making them easily distinguishable from newer addresses.\n\n#### Key Types and Their Purposes[​](#key-types-and-their-purposes \"Direct link to Key Types and Their Purposes\")\n\nCardano uses two main types of Ed25519 keys, each serving distinct purposes:\n\n**Payment Keys**: Used to sign transactions involving fund transfers, minting tokens, and interacting with smart contracts. The payment verification (public) key is used to derive addresses that can receive and send ada and native tokens.\n\n**Stake Keys**: Used to sign staking-related transactions including stake address registration, delegation to stake pools, and reward withdrawals. Stake keys enable participation in Cardano's proof-of-stake consensus mechanism.\n\n#### Payment and Delegation Components[​](#payment-and-delegation-components \"Direct link to Payment and Delegation Components\")\n\nShelley addresses contain two distinct parts:\n\n**Payment Part**: Controls fund ownership. Spending requires a witness (signature or script validation) proving control over this component. This is typically derived from a payment verification key.\n\n**Delegation Part**: Controls stake rights associated with funds. This can be:\n\n**Franken addresses** allow payment and delegation parts to be controlled by different entities, enabling separation of fund control and staking rights.\n\nFranken Addresses are a way to register additional pledge to a pool without registering a second owner on the blockchain.\n\n### Address Types[​](#address-types \"Direct link to Address Types\")\n\nCardano supports different address types across categories:\n\n#### Shelley Address Types[​](#shelley-address-types \"Direct link to Shelley Address Types\")\n\n**Base Addresses** directly specify the staking key controlling stake rights. The staking rights can be exercised by registering the stake key and delegating to a stake pool. Base addresses can be used in transactions without prior stake key registration.\n\n**Enterprise Addresses** carry no stake rights, allowing users to opt out of proof-of-stake participation. Exchanges and organizations holding ada on behalf of others often use these to demonstrate they don't exercise stake rights. These addresses can still receive, hold, and send native tokens.\n\n**Reward Account Addresses** distribute rewards for proof-of-stake participation. They use account-style (not UTXO-style) accounting, cannot receive funds via transactions, and have a one-to-one correspondence with registered staking keys.\n\n**Pointer Addresses** indirectly specify staking keys by referencing a location on the blockchain where a stake key registration certificate exists. Pointers are considerably shorter than stake key hashes. If the referenced certificate is lost due to rollback, pointer addresses remain valid for payments but lose stake participation rights.\n\nLearn and dive into CPS-0002 which focuses on Pointer Addresses.\n\n#### Legacy Byron Addresses[​](#legacy-byron-addresses \"Direct link to Legacy Byron Addresses\")\n\nByron addresses are legacy addresses from Cardano's Byron era, using CBOR encoding and Base58 representation. They have no stake rights and are maintained for backward compatibility.\n\n**Important Limitation**: Byron addresses are **not allowed in transactions that contain Plutus scripts**. This means smart contracts will never encounter Byron addresses during validation. If you're working with dApps, ensure all addresses are Shelley-era addresses to avoid transaction failures.\n\nFor complete technical specifications including binary format details, see [CIP-19](https://cips.cardano.org/cip/CIP-19).",
  "images": [],
  "extraction_metadata": {
    "batch_number": 6,
    "extraction_timestamp": "2025-09-19T14:04:44.452431",
    "extraction_time": 1.4428989887237549,
    "source": "tavily_api_raw"
  }
}