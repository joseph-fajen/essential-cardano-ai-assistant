{
  "url": "https://developers.cardano.org/docs/integrate-cardano/user-wallet-authentication",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Authenticating users with their Cardano wallet\n\n## Overview[​](#overview \"Direct link to Overview\")\n\nThis guide is a walkthrough on how to implement the *message signing* described in [CIP-08](https://cips.cardano.org/cip/CIP-0008) in order to authenticate users on the web with just their [CIP-30](https://cips.cardano.org/cip/CIP-0030)-compatible wallet app.\n\nThere are 2 components used in this guide — the front-end and the back-end. In order to implement this example, a [nodejs](https://nodejs.org) server is needed to run the back-end component that will receive and process the signed message submitted by the user.\n\n## Use cases[​](#use-cases \"Direct link to Use cases\")\n\nThe following are a just some examples of where this implementation can be used:\n\n## Time to code[​](#time-to-code \"Direct link to Time to code\")\n\nAs mentioned above, there are 2 components in this example - the front-end and the back-end. Our front-end code will handle our interaction with the user, to prompt them to sign some message with their wallet. The signed message will then be submitted to our back-end component which will parse the message and verify the user's signature.\n\nIn this example, we will be asking the user to sign a simple text message containing the string `account:` , followed by their wallet's bech32 stake address. For example:\n\n`account:` \n\n`account: stake1uynpv0vlulhufm8txwry0da9qq6tn9wn42mxltq65pw403qvdcveh`\n\n`account: stake1uynpv0vlulhufm8txwry0da9qq6tn9wn42mxltq65pw403qvdcveh`\n\nOur purpose in this case is for the user to prove their ownership of the given stake address.\n\nAlso for simplicity, we will be interacting with [Typhon Wallet](https://typhonwallet.io) only, in this example. But the concepts shown here should work with any other [CIP-30](https://cips.cardano.org/cip/CIP-0030)-compliant wallet app.\n\n### Front-end[​](#front-end \"Direct link to Front-end\")\n\nFor brevity, our front-end component will just be an HTML page containing a single button which will start the process, when clicked by the user.\n\n`<html>  \n <head>  \n <title>Authenticating users with their Cardano wallet</title>  \n <script src=\"userWalletAuth.js\"></script>  \n </head>  \n <body>  \n <button id=\"login-btn\">Login</button>   \n </body>  \n</html>`\n\nThe logic to handle the click event on the above button will be in a separate Javascript file. This is what we will really be working on for the front-end component. Let's start with the following:\n\n`window.addEventListener(\"load\", () => {  \n const loginBtn = document.querySelector(\"#login-btn\");  \n loginBtn.addEventListener(\"click\", authenticate);  \n})  \n  \nasync function authenticate(){  \n //  \n}`\n\nFor now, we just attached an event listener to our button, which will call the function `authenticate` when clicked.\n\n`authenticate`\n\nBefore we go on to add functionality to `authenticate` and anything else, we have to first import a couple of dependencies. Let's add the following to the top of `userWalletAuth.js`:\n\n`authenticate`\n`userWalletAuth.js`\n`import { Buffer } from \"buffer\";  \nlet csl, wallet;  \n  \nasync function loadCsl(){  \n csl = await import(\"@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib\");  \n};  \nloadCsl();  \n  \n...`\n\nWith the above lines, we just made available to the rest of our script, the [Buffer](https://www.npmjs.com/package/buffer) package and the [Cardano Serialization Library](/docs/get-started/cardano-serialization-lib/overview). Also, we just declared the top-level variable `wallet` there for convenience later. We will set its value in the following steps.\n\n`wallet`\n\nNow, let's make the `authenticate` function actually do some things:\n\n`authenticate`\n`...  \n  \nasync function authenticate(){  \n if (!csl) await loadCsl(); // make sure CSL is loaded before doing anything else.  \n  \n wallet = await window.cardano.typhoncip30.enable();  \n  \n const [stakeAddrHex, stakeAddrBech32] = await getStakeAddress();  \n const messageUtf = `account: ${stakeAddrBech32}`;  \n const messageHex = Buffer.from(messageUtf).toString(\"hex\");   \n const sigData = await wallet.signData(stakeAddrHex, messageHex);  \n const result = await submitToBackend(sigData);  \n alert(result.message);  \n}`\n\nOur `authenticate` function now gets the user's stake address both in hex and bech32 format. It then puts together the message that we'll ask the user to sign. After converting the message into a hex string, we call the `signData` method on the user's wallet to prompt the user to sign. When we get the signed message, we send it to our backend component to be processed and verified.\n\n`authenticate`\n`signData`\n\nYou'll notice that we called two more functions from the `authenticate` function. We have to add them to our code also:\n\n`authenticate`\n`...  \n  \nasync function getStakeAddress(){  \n const networkId = await wallet.getNetworkId();  \n const changeAddrHex = await wallet.getChangeAddress();  \n   \n // derive the stake address from the change address to be sure we are getting  \n // the stake address of the currently active account.  \n const changeAddress = csl.Address.from_bytes( Buffer.from(changeAddrHex, 'hex') );  \n const stakeCredential = csl.BaseAddress.from_address(changeAddress).stake_cred();  \n const stakeAddress = csl.RewardAddress.new(networkId, stakeCredential).to_address();  \n  \n return [stakeAddress.to_hex(), stakeAddress.to_bech32()];  \n}  \n  \nasync function submitToBackend(sigData){  \n const result = await fetch(`http://localhost:8081/login`, {  \n method: \"POST\",  \n headers: {  \n \"Content-Type\": \"application/json\",  \n },  \n body: JSON.stringify(sigData),  \n });  \n return result.json();  \n}`\n\nThat completes our front-end code. It can be viewed in full [here](https://github.com/inimrod/cardano-message-signing-demo/blob/main/frontend/js/userWalletAuth.js).\n\n### Back-end[​](#back-end \"Direct link to Back-end\")\n\nFor our back-end, let's create a file named `server.js` and first, we will import the dependencies we need:\n\n`server.js`\n`const { Buffer } = require(\"buffer\");  \nconst { COSESign1, COSEKey, BigNum, Label, Int } = require(\"@emurgo/cardano-message-signing-nodejs\");  \nconst { Ed25519Signature, RewardAddress, PublicKey, Address } = require(\"@emurgo/cardano-serialization-lib-nodejs\");  \nconst express = require(\"express\");  \nconst cors = require(\"cors\");`\n\nHere, we will be creating just a simple [Express JS](https://expressjs.com) server that can receive our `POST` request from our front-end. Along with the others, we imported a few required classes from the `cardano-message-signing` and `cardano-serialization-lib` packages.\n\n`POST`\n`cardano-message-signing`\n`cardano-serialization-lib`\n\nNow let's add a sample list of \"registered users\" of our app, identified by their stake addresses:\n\n`...  \n  \nconst registeredUsers = [  \n \"stake1uyzu7upg082rqajwasmwgam09fe7yj2cm3fkdfecqgptg8cwuze7s\",  \n \"stake1u8k7mwu8gdqyvgved89996cy6g8d9vw36w7j05qy2etanxgmgl5s7\",  \n \"stake1uynpv0vlulhufm8txwry0da9qq6tn9wn42mxltq65pw403qvdcveh\",  \n \"stake1uxa2x4andawqtcqxw9gy4mamdx6extq5g5grqq6pf7zpxxge4aa7l\",  \n \"stake1ux8yttnhy6qm9lkehvnmlhufnx38ef2q8vl6xyu8gyk0zwc83nvxh\",  \n \"stake1uykkptznwz0jd3flwa442a0cdmfrpwhg8pa9ypytf4cwacqw2085c\"  \n]`\n\nNext, we create our `express` server with one endpoint to receive the request from our front-end:\n\n`express`\n`...  \n  \nconst app = express();  \napp.use(express.json());  \napp.options(\"*\", cors());  \napp.use(cors({  \n origin: \"*\"  \n}));  \n  \napp.post(\"/login\", authenticate);  \napp.listen(8081, () =>  \n console.log(\"Backend component listening on port 8081!\"),  \n);`\n\nThe above code adds the `/login` endpoint which fires up the `authenticate` handler function. Now let's add that function:\n\n`/login`\n`authenticate`\n`...  \n  \nasync function authenticate(req, res) {  \n const sigData = req.body;  \n const decoded = COSESign1.from_bytes( Buffer.from(sigData.signature, \"hex\") );  \n const headermap = decoded.headers().protected().deserialized_headers();  \n const addressHex = Buffer.from( headermap.header( Label.new_text(\"address\") ).to_bytes() )  \n .toString(\"hex\")  \n .substring(4);  \n const address = Address.from_bytes( Buffer.from(addressHex, \"hex\") );  \n  \n const key = COSEKey.from_bytes( Buffer.from(sigData.key, \"hex\") );  \n const pubKeyBytes = key.header( Label.new_int( Int.new_negative(BigNum.from_str(\"2\")) ) ).as_bytes();  \n const publicKey = PublicKey.from_bytes(pubKeyBytes);  \n  \n const payload = decoded.payload();  \n const signature = Ed25519Signature.from_bytes(decoded.signature());  \n const receivedData = decoded.signed_data().to_bytes();  \n  \n const signerStakeAddrBech32 = RewardAddress.from_address(address).to_address().to_bech32();  \n const utf8Payload = Buffer.from(payload).toString(\"utf8\");  \n const expectedPayload = `account: ${signerStakeAddrBech32}`; // reconstructed message  \n  \n // verify:  \n const isVerified = publicKey.verify(receivedData, signature);  \n const payloadAsExpected = utf8Payload == expectedPayload;  \n const signerIsRegistered = registeredUsers.includes(signerStakeAddrBech32);  \n  \n const isAuthSuccess = isVerified && payloadAsExpected && signerIsRegistered;  \n  \n res.send({  \n success: isAuthSuccess,  \n message: isAuthSuccess ? \"✅ Authentication success!\" : \"❌ Authentication failed.\"  \n })  \n}`\n\nLet's unpack what happened there.\n\nFirst, we decoded the serialized signature that was submitted by the user. From the headers of this decoded data, we got the address of the signer. We later convert it back to its bech32 format to reconstruct our expected message string.\n\nWe then created a `PublicKey` instance of the `key` that came together with the signature sent by the user. We later use this to verify the submitted signature.\n\n`PublicKey`\n`key`\n\nWe also parsed the `payload` from the decoded signature data. After reconstructing our expected message string, we compare it with the `payload` we actually received.\n\n`payload`\n`payload`\n\nSince we already have the signer's stake address, we also checked it against our `registeredUsers` list.\n\n`registeredUsers`\n\nLastly, we send a response back to the user with a success message if all three checks where passed and a failure message if otherwise.\n\nThat completes our backend component. The full code can be viewed [here](https://github.com/inimrod/cardano-message-signing-demo/blob/main/backend/server.js).\n\n### Demo project repository[​](#demo-project-repository \"Direct link to Demo project repository\")\n\nFor quick and convenient testing of the above code, a demo project is available [here](https://github.com/inimrod/cardano-message-signing-demo) that can be cloned and quickly run.",
  "images": [],
  "extraction_metadata": {
    "batch_number": 7,
    "extraction_timestamp": "2025-09-19T14:04:49.862174",
    "extraction_time": 2.4011168479919434,
    "source": "tavily_api_raw"
  }
}