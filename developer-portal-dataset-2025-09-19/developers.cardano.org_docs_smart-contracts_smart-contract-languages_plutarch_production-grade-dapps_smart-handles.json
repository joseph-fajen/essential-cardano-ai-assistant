{
  "url": "https://developers.cardano.org/docs/smart-contracts/smart-contract-languages/plutarch/production-grade-dapps/smart-handles",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Smart Handles\n\n## Introduction[​](#introduction \"Direct link to Introduction\")\n\nSmart Handles is an abstract Cardano contract generator for instantiating\nvalidators that are meant to be carried out by incentivised agents to handle\nthe requests in a decentralized and trustless manner.\n\nOne of the simplest use-cases can be an instance for swapping one specific token\nto another without going through a DEX UI directly. This instance will have its\nunique address, which can be complemented with AdaHandles (e.g. `@ada-to-min`)\nand therefore any wallet that supports Smart Handles configurations can send\nsome $ADA directly to this address to be swapped for $MIN.\n\n`@ada-to-min`\n\nThis is not limited to swaps of course. For instance, sending funds to\n`@offer-spacebudz` (which resolves to a router smart contract for SpaceBudz\ncollection offers) could create a collection offer for SpaceBudz.\n\n`@offer-spacebudz`\n\nThe example here uses Smart Handles for swapping any token pairs through Minswap\nexchange.\n\nThe source code for these dApps can be found [here](https://github.com/Anastasia-Labs/smart-handles).\n\n## Documentation[​](#documentation \"Direct link to Documentation\")\n\n### What problems do Smart Beacons solve?[​](#what-problems-do-smart-beacons-solve \"Direct link to What problems do Smart Beacons solve?\")\n\nRight now, most interaction with smart contract protocols is done through\ncentralized front-end services where the transactions are built and submitted\nthrough centralized backend infrastructure. In addition to the negative impact\nthis has on decentralization, it also hampers adoption due to the restrictions\nit imposes. For instance, users with mobile wallets have severely limited\noptions when it comes to interacting with DApps. Also, regular users will be\nunable to interact with most DApps if the DApp front-ends were to become\nunavailable for any reason or if the backend was down.\n\nThere are a few attempts to address this problem, such as\n[DApp Schemas](https://cardano.ideascale.com/c/idea/64468) or\n[Smart Contract Blueprints](https://developers.cardano.org/docs/governance/cardano-improvement-proposals/cip-0057/); however,\nall of these solutions rely on off-chain infrastructure to specify how to\ninterpret a DApp's datums, redeemers, and other on-chain data in order to build\ntransactions. Smart Beacons differ from these other approaches in that it is a\nfully onchain solution that does not rely on offchain infrastructure.\n\nUTxOs locked at a Smart Handles instance can carry datums that determine how a\nrouting agent should reproduce them at their specified destination addresses\n(or route addresses).\n\nIn case of simple datums however, the interaction logic is hard-coded in the\ninstance itself, and their corresponding off-chain agents should provide routers\nwith all they need to handle requests.\n\n## Contract Logic[​](#contract-logic \"Direct link to Contract Logic\")\n\nSmart Handles framework offers two datums:\n\n`data PSmartHandleDatum (s :: S)  \n = PSimple (Term s (PDataRecord '[\"owner\" ':= PAddress]))  \n | PAdvanced  \n ( Term  \n s  \n ( PDataRecord  \n '[ \"mOwner\" ':= PMaybeData PAddress  \n , \"routerFee\" ':= PInteger  \n , \"reclaimRouterFee\" ':= PInteger  \n , \"routeRequiredMint\" ':= PRequiredMint  \n , \"reclaimRequiredMint\" ':= PRequiredMint  \n , \"extraInfo\" ':= PData  \n ]  \n )  \n )`\n`Simple`\n`Advanced`\n`mOwner`\n`Nothing`\n`routerFee`\n`reclaimRouterFee`\n`routerFee`\n`routeRequiredMint`\n`Maybe (PolicyID, TokenName)`\n`reclaimRequiredMint`\n`routeRequiredMint`\n`extraInfo`\n`PData`\n\nOn top of that, each instance can also support a \"single\" variant and a \"batch\"\nvariant: Single will be a spending script that only supports a single\nroute/reclaim per transaction. Batch, on the other hand, is a staking script for\nhandling multiple requests in single transactions.\n\nSingle variants will have 3 redeemers: routing, simple reclaims, and advanced\nreclaims:\n\n`data PSmartHandleRedeemer (s :: S)  \n = PRoute (Term s (PDataRecord '[\"ownIndex\" ':= PInteger, \"routerIndex\" ':= PInteger]))  \n | PReclaim (Term s (PDataRecord '[]))  \n | PAdvancedReclaim (Term s (PDataRecord '[\"ownIndex\" ':= PInteger, \"routerIndex\" ':= PInteger]))`\n\nSimple reclaim only applies to simple datums, and the only requirement is\nimposes on withdrawals is the signature of the owner. Advanced reclaim passes\nthe spending UTxO to instance's underlying validator, and therefore has a\nredeemer similar to the routing endpoint.\n\nBatch variants' scripts (spending and staking) will have 2 redeemers each:\n\n`-- for the staking script  \ndata PRouterRedeemer (s :: S)  \n = PRouterRedeemer  \n ( Term  \n s  \n ( PDataRecord  \n '[ \"inputIdxs\" ':= PBuiltinList (PAsData PInteger)  \n , \"outputIdxs\" ':= PBuiltinList (PAsData PInteger)  \n ]  \n )  \n )  \n  \n-- for the batch spend script  \ndata PSmartRedeemer (s :: S)  \n = PRouteSmart (Term s (PDataRecord '[]))  \n | PReclaimSmart (Term s (PDataRecord '[]))`\n\nThe underlying logic of an instance is shared between the two variants, and\ntherefore utilizing either one will be very similar.\n\nYou may have noticed that both redeemers are using the [UTxO indexer pattern](https://github.com/Anastasia-Labs/design-patterns/blob/main/utxo-indexers/UTXO-INDEXERS.md)\nfor a more optimized performance.\n\n## Off-Chain Tools[​](#off-chain-tools \"Direct link to Off-Chain Tools\")\n\nThere are 2 packages available for working with smart handles instances:\n\n`smart-handles-offchain`\n`smart-handles-agent`\n\n### Using Routing Contract[​](#using-routing-contract \"Direct link to Using Routing Contract\")\n\nHead over to the [off-chain SDK of smart handles](https://github.com/Anastasia-Labs/smart-handles-offchain) to\nlearn how to define your instance's off-chain, or look\nthrough [an example with Minswap V1](https://github.com/Anastasia-Labs/smart-handles-offchain/tree/main/example).",
  "images": [],
  "extraction_metadata": {
    "batch_number": 12,
    "extraction_timestamp": "2025-09-19T14:05:17.156321",
    "extraction_time": 1.6163160800933838,
    "source": "tavily_api_raw"
  }
}