{
  "url": "https://developers.cardano.org/docs/get-started/cardanosharp-wallet",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# CardanoSharp.Wallet\n\n[![Build status](https://ci.appveyor.com/api/projects/status/knh87k86mf7gbxyo?svg=true)](https://ci.appveyor.com/project/nothingalike/cardanosharp-wallet/branch/main) [![Test status](https://img.shields.io/appveyor/tests/nothingalike/cardanosharp-wallet)](https://ci.appveyor.com/project/nothingalike/cardanosharp-wallet/branch/main) [![NuGet Version](https://img.shields.io/nuget/v/CardanoSharp.Wallet.svg?style=flat)](https://www.nuget.org/packages/CardanoSharp.Wallet/) ![NuGet Downloads](https://img.shields.io/nuget/dt/CardanoSharp.Wallet.svg)\n\n![Build status](https://ci.appveyor.com/api/projects/status/knh87k86mf7gbxyo?svg=true)\n![Test status](https://img.shields.io/appveyor/tests/nothingalike/cardanosharp-wallet)\n![NuGet Version](https://img.shields.io/nuget/v/CardanoSharp.Wallet.svg?style=flat)\n![NuGet Downloads](https://img.shields.io/nuget/dt/CardanoSharp.Wallet.svg)\n\nCardanoSharp Wallet is a .NET library for Creating/Managing Wallets and Building/Signing Transactions.\n\n## Getting Started[​](#getting-started \"Direct link to Getting Started\")\n\nCardanoSharp.Wallet is installed from NuGet.\n\n`Install-Package CardanoSharp.Wallet`\n\n## Create Mnemonics[​](#create-mnemonics \"Direct link to Create Mnemonics\")\n\nThe `MnemonicService` has operations tbat help with *generating* and *restoring* Mnemonics. It is built for use in DI containers (ie. the interface `IMnemonicService`).\n\n`MnemonicService`\n`IMnemonicService`\n`IMnemonicService service = new MnemonicService();`\n\n### Generate Mnemonic[​](#generate-mnemonic \"Direct link to Generate Mnemonic\")\n\n`IMnemonicService service = new MnemonicService();  \nMnemonic rememberMe = service.Generate(24, WordLists.English);  \nSystem.Console.WriteLine(rememberMe.Words);`\n\n### Restore Mnemonic[​](#restore-mnemonic \"Direct link to Restore Mnemonic\")\n\n`string words = \"art forum devote street sure rather head chuckle guard poverty release quote oak craft enemy\";  \nMnemonic mnemonic = MnemonicService.Restore(words);`\n\n## Create Private and Public Keys[​](#create-private-and-public-keys \"Direct link to Create Private and Public Keys\")\n\nUse powerful extensions to create and derive keys.\n\n`// The rootKey is a PrivateKey made of up of the   \n// - byte[] Key  \n// - byte[] Chaincode  \nPrivateKey rootKey = mnemonic.GetRootKey();  \n  \n// This path will give us our Payment Key on index 0  \nstring paymentPath = $\"m/1852'/1815'/0'/0/0\";  \n// The paymentPrv is Private Key of the specified path.  \nPrivateKey paymentPrv = rootKey.Derive(paymentPath);  \n// Get the Public Key from the Private Key  \nPublicKey paymentPub = paymentPrv.GetPublicKey(false);  \n  \n// This path will give us our Stake Key on index 0  \nstring stakePath = $\"m/1852'/1815'/0'/2/0\";  \n// The stakePrv is Private Key of the specified path  \nPrivateKey stakePrv = rootKey.Derive(stakePath);  \n// Get the Public Key from the Stake Private Key  \nPublicKey stakePub = stakePrv.GetPublicKey(false);`\n\nIf you want to learn more about key paths, read this article [About Address Derivation](https://github.com/input-output-hk/technical-docs/blob/main/cardano-components/cardano-wallet/doc/About-Address-Derivation.md)\n\n## Create Addresses[​](#create-addresses \"Direct link to Create Addresses\")\n\nThe `AddressService` lets you Create Addresses from Keys. It is built for use in DI containers (ie. the interface `IAddressService`)\n\n`AddressService`\n`IAddressService`\n`IAddressService addressService = new AddressService();`\n\nFrom the public keys we generated above, we can now get the public address.\n\n`// add using  \nusing CardanoSharp.Wallet.Models.Addresses;  \n  \n// Creating Addresses require the Public Payment and Stake Keys  \nAddress baseAddr = addressService.GetAddress(  \n paymentPub,   \n stakePub,   \n NetworkType.Testnet,   \n AddressType.Base);`\n\nIf you already have an address.\n\n`Address baseAddr = new Address(\"addr_test1qz2fxv2umyhttkxyxp8x0dlpdt3k6cwng5pxj3jhsydzer3jcu5d8ps7zex2k2xt3uqxgjqnnj83ws8lhrn648jjxtwq2ytjqp\");`\n\n## Fluent Key Derivation[​](#fluent-key-derivation \"Direct link to Fluent Key Derivation\")\n\nA fluent API helps navigate the derivation paths.\n\n`// Add using  \nusing CardanoSharp.Wallet.Extensions.Models;  \n  \n// Restore a Mnemonic  \nvar mnemonic = new MnemonicService().Restore(words);  \n  \n// Fluent derivation API  \nvar derivation = mnemonic  \n .GetMasterNode(\"password\") // IMasterNodeDerivation  \n .Derive(PurposeType.Shelley) // IPurposeNodeDerivation  \n .Derive(CoinType.Ada) // ICoinNodeDerivation  \n .Derive(0) // IAccountNodeDerivation  \n .Derive(RoleType.ExternalChain) // IRoleNodeDerivation  \n //or .Derive(RoleType.Staking)   \n .Derive(0); // IIndexNodeDerivation  \n  \nPrivateKey privateKey = derivation.PrivateKey;  \nPublicKey publicKey = derivation.PublicKey;`\n\n## Build and Sign Transactions[​](#build-and-sign-transactions \"Direct link to Build and Sign Transactions\")\n\nCardanoSharp.Wallet requires input from the chain in order to build transactions. Lets assume we have gathered the following information.\n\n`uint currentSlot = 40000000;  \nulong minFeeA = 44;  \nulong minFeeB = 155381;  \nstring inputTx = \"0000000000000000000000000000000000000000000000000000000000000000\";`\n\nLets derive a few keys to use while building transactions.\n\n`// Derive down to our Account Node  \nvar accountNode = rootKey.Derive()  \n .Derive(PurposeType.Shelley)  \n .Derive(CoinType.Ada)  \n .Derive(0);  \n  \n// Derive our Change Node on Index 0  \nvar changeNode = accountNode  \n .Derive(RoleType.InternalChain)   \n .Derive(0);  \n  \n// Derive our Staking Node on Index 0  \nvar stakingNode = accountNode  \n .Derive(RoleType.Staking)   \n .Derive(0);  \n  \n// Deriving our Payment Node  \n// note: We did not derive down to the index.  \nvar paymentNode = accountNode  \n .Derive(RoleType.ExternalChain);`\n\n## Simple Transaction[​](#simple-transaction \"Direct link to Simple Transaction\")\n\nLets assume the following...\n\n`m/1852'/1815'/0'/0/0`\n`m/1852'/1815'/0'/0/1`\n\n### Build Transaction Body[​](#build-transaction-body \"Direct link to Build Transaction Body\")\n\n`// Generate the Receiving Address  \nAddress paymentAddr = addressService.GetAddress(  \n paymentNode.Derive(1).PublicKey,   \n stakingNode.PublicKey,   \n NetworkType.Testnet,   \n AddressType.Base);  \n  \n// Generate an Address for changes  \nAddress changeAddr = addressService.GetAddress(  \n changeNode.PublicKey,   \n stakingNode.PublicKey,   \n NetworkType.Testnet,   \n AddressType.Base);  \n  \nvar transactionBody = TransactionBodyBuilder.Create  \n .AddInput(inputTx, 0)  \n .AddOutput(paymentAddr, 25)  \n .AddOutput(changeAddr, 75)  \n .SetTtl(currentSlot + 1000)  \n .SetFee(0)  \n .Build();`\n\n### Build Transaction Witnesses[​](#build-transaction-witnesses \"Direct link to Build Transaction Witnesses\")\n\nFor this simple transaction we really only need to add our keys. This is how we sign our transactions.\n\n`// Derive Sender Keys  \nvar senderKeys = paymentNode.Derive(0);  \n  \nvar witnesses = TransactionWitnessSetBuilder.Create  \n .AddVKeyWitness(senderKeys.PublicKey, senderKeys.PrivateKey);`\n\n### Calculate Fee[​](#calculate-fee \"Direct link to Calculate Fee\")\n\n`// Construct Transaction Builder  \nvar transactionBuilder = TransactionBuilder.Create  \n .SetBody(transactionBody)  \n .SetWitnesses(witnesses);  \n  \n// Calculate Fee  \nvar fee = transaction.CalculateFee(minFeeA, minFeeB);  \n  \n// Update Fee and Rebuild  \ntransactionBody.SetFee(fee);  \nTransaction transaction = transactionBuilder.Build();  \ntransaction.TransactionBody.TransactionOutputs.Last().Value.Coin -= fee;`\n\n## Metadata Transaction[​](#metadata-transaction \"Direct link to Metadata Transaction\")\n\nBuilding the Body and Witnesses are the same as the Simple Transaction.\n\nIf you would like to read more about Metadata, please read this article on [Tx Metadata](https://github.com/input-output-hk/cardano-node-wiki/wiki/tx-metadata)\n\n`// Build Metadata and Add to Transaction  \nvar auxData = AuxiliaryDataBuilder.Create  \n .AddMetadata(1234, new { name = \"simple message\" });  \n  \nvar transaction = TransactionBuilder.Create  \n .SetBody(transactionBody)  \n .SetWitnesses(witnesses)  \n .SetAuxData(auxData)  \n .Build();`\n\n## Minting Transaction[​](#minting-transaction \"Direct link to Minting Transaction\")\n\nBefore we can mint a token, we need to create a policy.\n\nIf you would like to read more about policy scripts, please read this article on [Simple Scripts](https://github.com/input-output-hk/cardano-node-wiki/wiki/simple-scripts).\n\n`// Generate a Key Pair for your new Policy  \nvar keyPair = KeyPair.GenerateKeyPair();  \nvar policySkey = keyPair.PrivateKey;  \nvar policyVkey = keyPair.PublicKey;  \nvar policyKeyHash = HashUtility.Blake2b244(policyVkey.Key);  \n  \n// Create a Policy Script with a type of Script All  \nvar policyScript = ScriptAllBuilder.Create  \n .SetScript(NativeScriptBuilder.Create.SetKeyHash(policyKeyHash))  \n .Build();  \n  \n// Generate the Policy Id  \nvar policyId = policyScript.GetPolicyId();`\n\nNow lets define our token.\n\n`// Create the AWESOME Token  \nstring tokenName = \"AWESOME\";  \nuint tokenQuantity = 1;  \n  \nvar tokenAsset = TokenBundleBuilder.Create  \n .AddToken(policyId, tokenName.ToBytes(), tokenQuantity);`\n\nWhen minting, we will need to add our new token to one of the outputs of our Transaction Body.\n\n`// Generate an Address to send the Token  \nAddress baseAddr = addressService.GetAddress(  \n paymentNode.Derive(1).PublicKey,   \n stakingNode.PublicKey,   \n NetworkType.Testnet,   \n AddressType.Base);  \n  \n// Build Transaction Body with Token Bundle  \nvar transactionBody = TransactionBodyBuilder.Create  \n .AddInput(inputTx, 0)  \n // Sending to Base Address, includes 100 ADA and the Token we are minting  \n .AddOutput(baseAddr, 100, tokenAsset)  \n .SetTtl(currentSlot + 1000)  \n .SetFee(0)  \n .Build();`\n\n## Handling Token Bundles[​](#handling-token-bundles \"Direct link to Handling Token Bundles\")\n\nWhen building transaction, we need to ensure we handle tokens properly.\n\n`var tokenBundle = TokenBundleBuilder.Create  \n .AddToken(policyId, \"Token1\".ToBytes(), 100)  \n .AddToken(policyId, \"Token2\".ToBytes(), 200);  \n  \nAddress baseAddr = addressService.GetAddress(  \n paymentNode.Derive(1).PublicKey,   \n stakingNode.PublicKey,   \n NetworkType.Testnet,   \n AddressType.Base);  \n  \nvar transactionBody = TransactionBodyBuilder.Create  \n .AddInput(inputTx, 0)  \n .AddOutput(baseAddr, 2, tokenBundle)  \n .AddOutput(changeAddr, 98)  \n .SetTtl(currentSlot + 1000)  \n .SetFee(0)  \n .Build();`",
  "images": [],
  "extraction_metadata": {
    "batch_number": 4,
    "extraction_timestamp": "2025-09-19T14:04:34.999822",
    "extraction_time": 3.8223392963409424,
    "source": "tavily_api_raw"
  }
}