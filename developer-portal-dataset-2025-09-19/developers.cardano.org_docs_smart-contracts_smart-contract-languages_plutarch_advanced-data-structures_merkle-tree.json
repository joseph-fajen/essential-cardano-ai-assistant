{
  "url": "https://developers.cardano.org/docs/smart-contracts/smart-contract-languages/plutarch/advanced-data-structures/merkle-tree",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Merkle Tree\n\n## Introduction[​](#introduction \"Direct link to Introduction\")\n\nThe Plutarch Merkle Tree project provides a Plutarch-based implementation of Merkle Trees for the Cardano blockchain. This project allows developers to leverage the security and efficiency of Merkle Trees in their Cardano smart contracts, ensuring data integrity and efficient data verification.\n\nThe github repository introducing these data structures can be found [here](https://github.com/Anastasia-Labs/plutarch-merkle-tree).\n\n## Documentation[​](#documentation \"Direct link to Documentation\")\n\n### Merkle Tree[​](#merkle-tree \"Direct link to Merkle Tree\")\n\nA Merkle tree, named after its inventor Ralph Merkle, is a fundamental data structure in computer science and cryptography. It's particularly well-suited for managing and verifying large data structures, especially in distributed systems like blockchain technologies. Here's a detailed explanation:\n\n#### Basic concept[​](#basic-concept \"Direct link to Basic concept\")\n\nA Merkle tree is a type of binary tree, consisting of nodes. Here's how it's structured:\n\n#### Hash function[​](#hash-function \"Direct link to Hash function\")\n\nThe core of a Merkle tree is the hash function (like SHA-256 in Bitcoin). This function takes digital data of any size and produces a fixed-size string of bytes, typically a unique digital fingerprint of the input data.\n\n#### Construction[​](#construction \"Direct link to Construction\")\n\n#### Features[​](#features \"Direct link to Features\")\n\n#### Example[​](#example \"Direct link to Example\")\n\nConsider a Merkle tree with four leaf nodes (A, B, C, D).\n\n `Merkle Root  \n |  \n +-----------+-----------+  \n | |  \n Hash(A+B) Hash(C+D)  \n | |  \n +---+---+ +---+---+  \n | | | |  \n Hash(A) Hash(B) Hash(C) Hash(D)`\n\nThus, the Merkle root is a digest of all the data in the leaf nodes.\n\nIn conclusion, Merkle trees offer a secure and efficient way to summarize and verify large data sets.\n\n### Plutarch Merkle Tree implementation[​](#plutarch-merkle-tree-implementation \"Direct link to Plutarch Merkle Tree implementation\")\n\nThe Plutarch Merkle Tree implementation provides several functions to create and manipulate Merkle Trees. Below is a brief overview of each function:\n\n-`fromList`: Constructs a Merkle Tree from a list of serialized data.\n\n`fromList`\n\n-`toList`: Deconstructs a Merkle Tree back into a list of elements.\n\n`toList`\n\n-`rootHash`: Retrieves the root hash of a Merkle Tree.\n\n`rootHash`\n\n-`isNull`: Checks if a Merkle Tree is empty.\n\n`isNull`\n\n-`size`: Returns the number of leaf nodes in a Merkle Tree.\n\n`size`\n\n-`mkProof`: Generates a proof of membership for an element in the Merkle Tree.\n\n`mkProof`\n\n-`member`: Verifies if an element is part of a Merkle Tree using a proof.\n\n`member`\n\n-`hash`: Computes a SHA-256 hash of a given byte string.\n\n`hash`\n\n-`combineHash`: Combines two hashes into a new one.\n\n`combineHash`\n\n-`addLeaf`: Adds a new leaf to the Merkle Tree.\n\n`addLeaf`",
  "images": [],
  "extraction_metadata": {
    "batch_number": 12,
    "extraction_timestamp": "2025-09-19T14:05:17.156321",
    "extraction_time": 1.6163160800933838,
    "source": "tavily_api_raw"
  }
}