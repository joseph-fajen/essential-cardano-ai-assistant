{
  "url": "https://developers.cardano.org/docs/smart-contracts/advanced/design-patterns/transaction-level-validation/stake-validators/merkelized-validators",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Merkelized Validators\n\nThere are very tight execution budget constraints imposed on Plutus script evaluation; this, in combination with the fact that a higher execution budget\nequates to higher transaction fees for end-users makes it such that ex-unit optimization is an extremely important component of smart contract development on Cardano.\n\nOften the most impactful optimization techniques involve trade-offs between ex-units and script size. This results in a tight balancing act where you want to minimize the\nex-units while keeping the script below the ~16kb limit (script size that you can store as a reference script is limited by transaction size limit). Powerful ExUnit\noptimizations such as unrolling recursion, inlining functions and preferring constants over variables all can drastically reduce ExUnit consumption at the cost of increasing\nscript size.\n\nWe can take advantage of reference scripts and the withdraw-zero trick to separate the logic (and code) of our validator across a number of stake scripts (which we provide as reference inputs). Then our main validator simply checks for the presence of the associated staking script in the `txInfoRedeemers` (and verify that the redeemer to the scripts are as expected) where necessary to execute the branch of logic.\n\n`txInfoRedeemers`\n\nYou can use the withdraw zero trick to prove arbitrary computation was done in a separate script execution (to effectively create merkleized smart contracts):\nRedeemer of stake validator:\n\n`data MerkelizedFunctionRedeemer = MerkelizedFunctionRedeemer {inputState :: [BuiltinData], outputState :: [BuiltinData]}`\n\nArbitrary computation to prove:\n\n`f :: [BuiltinData] -> [BuiltinData]  \nf inputState = ... -- perform computation on x`\n\nStake Validator Logic:\n\n`-- PlutusTx Implementation  \nstakeValidator :: MerkelizedFunctionRedeemer -> ScriptContext -> ()   \nstakeValidator MerkelizedFunctionRedeemer{inputState, outputState} ctx =  \n if (f inputState == outputState) then () else ( error () )`\n`-- Plutarch implementation  \nstakeValidator redeemer ctx = P.do  \n redF <- pletFields @'[\"inputState\", \"outputState\"] redeemer  \n pif (f # redF.inputState #== redF.outputState) (popaque $ pconstant ()) error`\n\nThen in the actual validator where we would like to outsource the computation to the stake validator:\n\n`-- PlutusTx implementation  \nmerkelizedValidator:: StakingCredential -> BuiltinData -> BuiltinData -> ScriptContext -> ()  \nmerkelizedValidator outsourcedFunctionCred _dat _redeemer ctx =   \n ...  \n -- verify that the computation was outsourced to the stake validator  \n -- arg1, arg2, arg3 are any arbitrary values from this validator that we want   \n -- to perform the computation on.  \n let ourInputState = [arg1, arg2, arg3]   \n (Just functionRdmr') = AssocMap.lookup (Rewarding outsourcedFunctionCred) redeemers)  \n functionRdmr = unsafeFromBuiltinData @MerkelizedFunctionRedeemer (getRedeemer functionRedeemer)  \n if (ourInputState == (inputState functionRdmr))   \n then   \n let functionResult = outputState functionRdmr   \n -- from here on out we know that `functionResult` contains the application of the arbitrary function `f` to our inputs `[arg1, arg2, arg3]`   \n -- so we now have access to the result of `f ([arg1, arg2, arg3])` without actually executing `f` in this validator.  \n else ( error () )  \n   \n   \n where   \n info = txInfo ctx   \n redeemers = txInfoRedeemers info`\n`--- Plutarch implementation  \nmerkelizedValidator stakeCred ... = P.do  \n ...  \n -- verify that the computation was outsourced to the stake validator  \n -- arg1, arg2, arg3 are any arbitrary variables from this validator that we want   \n -- to perform the computation on.  \n let ourInputState = [arg1, arg2, arg3]   \n stakeRed =   \n pmustFind   \n # plam (\\red ->   \n pmatch (pfstBuiltin # red) $ \\case   \n PRewarding ((pfield @\"_0\" #) -> scred) ->   \n pand' # (scred #== stakeCred)  \n # pfield @\"inputState\" # (punsafeCoerce @StakeRedeemer (psndBuiltin # red)) #== ourInputState   \n _ -> pconstant False  \n )  \n # pto (pfield @\"redeemers\" # (pfield @\"txInfo\" # ctx))  \n  \n -- from here on out we know that (psndBuiltin # stakeRed).outputState contains the application of the arbitrary function `f` to our inputs `[arg1, arg2, arg3]`   \n -- so we have proved that f # (psndBuiltin # stakeRed) #== (psndBuiltin # stakeRed).outputState without actually running f in this validator`\n\nThis is useful because with reference scripts this essentially gives us the ability to create scripts with near infinite size which means optimization strategies that involve increasing script size to reduce mem / CPU (ie loop unrolling) now are available to us at nearly zero cost.\n\nConsider a batching architecture, with a very large `processOrders` function. Normally it would not be feasible to perform recursion unrolling / inlining optimizations with such a function since it would quickly exceed the max script size limit; however, with this design pattern we simply move `processOrders` into its own validator script which we can fill with 16kb of loop unrolling and other powerful optimizations which increase script size in order to reduce ExUnits. We provide this new script as a reference script when executing our main validator. Then in our main validator we verify that the `processOrders` validator was executed with the expected redeemer (`inputState` must match the arguments we want to pass to `processOrders`) after which have access to the result of the optimized `processOrders` function applied to our inputs.\n\n`processOrders`\n`processOrders`\n`processOrders`\n`inputState`\n`processOrders`\n`processOrders`\n\nYou can find a sample implementation of a merkelized validator written in Aiken in this[repository](https://github.com/keyan-m/aiken-delegation-sample/blob/main/validators/main-contract.ak).",
  "images": [],
  "extraction_metadata": {
    "batch_number": 10,
    "extraction_timestamp": "2025-09-19T14:05:05.551444",
    "extraction_time": 2.0458879470825195,
    "source": "tavily_api_raw"
  }
}