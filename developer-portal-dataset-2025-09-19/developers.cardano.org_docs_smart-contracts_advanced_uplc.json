{
  "url": "https://developers.cardano.org/docs/smart-contracts/advanced/uplc",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Untyped Plutus Core\n\n## Untyped Plutus Core: The Execution Layer[​](#untyped-plutus-core-the-execution-layer \"Direct link to Untyped Plutus Core: The Execution Layer\")\n\nAt the lowest level, all Cardano smart contracts execute as **Untyped Plutus Core** (UPLC) programs. Understanding UPLC provides crucial insight into how your high-level smart contract code actually runs on-chain.\n\n### What is UPLC?[​](#what-is-uplc \"Direct link to What is UPLC?\")\n\nUPLC is the \"assembly language\" of Cardano smart contracts. Every smart contract language (Aiken, Plutus Haskell, OpShin, etc.) compiles down to UPLC before execution. Think of it as the intermediate representation that the Cardano virtual machine actually executes.\n\n**Why Multiple Languages?** The diverse ecosystem of languages targeting UPLC reflects different development philosophies. This diversity allows developers to choose tools that match their background and project needs while all compiling to the same execution target.\n\n**Compilation Pipeline:**\n\n`High-level Code → Typed Plutus Core → UPLC → Binary Encoding → On-chain Execution`\n\n### Properties[​](#properties \"Direct link to Properties\")\n\nWhile UPLC has no explicit types, it preserves the implicit type structure from the original typed program. Type mismatches still cause runtime errors, but the execution model is simpler.\n\nUPLC uses lambda calculus with functions, variables, constants, and application. Everything is a function or can be applied to a function. Variables use DeBruijn indices instead of names, referring to bound variables by their position in ancestor lambdas.\n\nUPLC can express any computation that can be performed by a computer, making it powerful enough to handle complex smart contract logic.\n\nSince there are no operators, all operations (even basic arithmetic) use built-in functions like `addInteger`, `appendByteString`, or `verifyEd25519Signature`.\n\n`addInteger`\n`appendByteString`\n`verifyEd25519Signature`\n\n### Basic UPLC Components[​](#basic-uplc-components \"Direct link to Basic UPLC Components\")\n\n#### Primitive Types[​](#primitive-types \"Direct link to Primitive Types\")\n\nUPLC supports seven primitive types:\n\n`(con unit ())`\n`(con bool True)`\n`(con integer 42)`\n`(con bytestring #41696b656e)`\n`(con string \"Hello\")`\n`(con pair<bool, integer> [True, 42])`\n`(con list<integer> [1, 2, 3])`\n\n#### Functions and Application[​](#functions-and-application \"Direct link to Functions and Application\")\n\nFunctions use lambda syntax:\n\n`(lam x x) // Identity function  \n[ (lam x x) (con integer 42) ] // Apply identity to 42`\n\n#### Built-in Functions[​](#built-in-functions \"Direct link to Built-in Functions\")\n\nEssential operations use built-ins:\n\n`[ [ (builtin addInteger) (con integer 16) ] (con integer 26) ] // 16 + 26  \n[ [ (builtin equalsByteString) #hello ] #world ] // Compare bytes`\n\n#### Data Type[​](#data-type \"Direct link to Data Type\")\n\nThe generic `Data` type is crucial for smart contracts, representing arbitrary structured data used in datums and redeemers. It supports five constructors:\n\n`Data`\n`data Data =   \n Constr Integer [Data] -- Tagged constructors with data  \n | Map [(Data, Data)] -- Key-value mappings   \n | List [Data] -- Homogeneous lists  \n | I Integer -- Integer values  \n | B ByteString -- Binary data`\n\n**Working with Data**: Built-in functions help construct and access Data values:\n\n`constrData`\n`unConstrData`\n`listData`\n`unListData`\n`mapData`\n`unMapData`\n`iData`\n`unIData`\n`bData`\n`unBData`\n\nThis type system allows high-level languages to serialize complex data structures into a format that UPLC can process uniformly.\n\n### Binary Encoding and Execution[​](#binary-encoding-and-execution \"Direct link to Binary Encoding and Execution\")\n\nOn-chain, UPLC programs are stored as compact binary data using the \"flat\" encoding format. This binary representation is what validators actually receive and execute.\n\n**Size Implications**: UPLC programs can be large, which is why transaction size limits (16KB) become important for complex smart contracts. Recent improvements like reference scripts help mitigate this.\n\n**Execution Costs**: Every UPLC operation has precise memory and CPU costs defined by the protocol's cost model. These costs enable predictable fee calculation and execution budgets.\n\n### Why This Matters for Developers[​](#why-this-matters-for-developers \"Direct link to Why This Matters for Developers\")\n\nWhen smart contracts fail, understanding UPLC helps interpret low-level error messages and execution traces for debugging.\n\nKnowing how high-level constructs compile to UPLC helps write more efficient smart contracts.\n\nUPLC is the common target for all smart contract languages, enabling cross-language compatibility.\n\nUnderstanding the compilation pipeline helps minimize the size of on-chain scripts and optimize your contracts to their last bits.\n\nWhile you won't write UPLC directly, understanding it as the execution foundation helps you write better smart contracts in any high-level language.\n\nFor complete technical details including formal syntax and semantics, see the [Formal Specification of the Plutus Core Language](https://plutus.cardano.intersectmbo.org/resources/plutus-core-spec.pdf).",
  "images": [],
  "extraction_metadata": {
    "batch_number": 11,
    "extraction_timestamp": "2025-09-19T14:05:12.534540",
    "extraction_time": 3.978458881378174,
    "source": "tavily_api_raw"
  }
}