{
  "url": "https://developers.cardano.org/docs/smart-contracts/advanced/smart-contract-vulnerabilities/invariant0-blog/1-double-satisfaction",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Double Satisfaction\n\nFollowing sections can be found also at this [blog](https://medium.com/@invariant0/cardano-vulnerabilities-1-double-satisfaction-219f1bc9665e)\n\nCardano smart contracts are very different from the ones on Ethereum. To represent its blockchain, Cardano uses the Unspent Transaction Output (UTxO) model. A simplification is that the blockchain is a list of unspent transactions, and the only thing we can do is spend them (though since the Vasil fork, we can also reference inputs without spending them).\n\nA transaction can be seen as a change of some already existing UTxOs into some new UTxOs. Each UTxO has some rules attached to it that detail what transaction can spend it. Cardano blockchain only validates a transaction if it follows rules for every single of its inputs. There are some additional rules imposed by the Cardano blockchain — for example, the sum of Ada on inputs and outputs must match (except for the fees which we will omit for simplicity).\n\nThis model is pretty simple to understand if we disregard smart contracts. For usual UTxOs, there are explicit rules on how to spend them. The most common rule is the public-key hash UTxO — the transaction that spends it needs to be signed by a corresponding private key. This can be seen in the next image:\n\n![DS-1](/assets/images/ds-1-8ebfa6c50e0330990d372db8964415a4.png)\n\n![DS-1](/assets/images/ds-1-8ebfa6c50e0330990d372db8964415a4.png)\n\nAlice pays Bob 20 ADA so she uses 2 of her UTxOs and signs the transaction.\n\nCardano brings an extension to this UTxO model in the form of smart contracts. While UTxOs on a public-key hash address can be spent by signing the transaction with the owner’s private key, UTxOs at smart contract addresses can be spent only by transactions that follow rules written in the smart contracts. These rules are called validators and can be written in programming languages such as Plutus, Plutarch, or Aiken. The validator is a pure function — its result depends only on the inputs to the function. The inputs to validators are:\n\nLet us introduce a simple smart contract that will be used in all of the following examples — smart contract BuyNFT. The purpose of the contract is to sell an NFT to any buyer who is willing to pay the price to the seller. From this purpose, we see that the datum of the smart contract can be viewed as a pair of:\n\nThe seller of the NFT — an address, the contract needs to know who the buyer should pay.\nThe price to pay — an integer, the contract needs to know how much the buyer should pay.\nHaving the datum defined as pair of price and seller, we can write a simple validation rule for our smart contract:\n\nAt least price ADA went to the address seller.\nMore formally, the validator of BuyNFT checks that the transaction spending it contains an output UTxO to the address seller with the value of at least price ADA. We will say that a transaction that follows this rule satisfies the contract.\n\n![DS-2](/assets/images/ds-2-595306970df93550d35d1a74a922df02.png)\n\n![DS-2](/assets/images/ds-2-595306970df93550d35d1a74a922df02.png)\n\nThe BuyNFT UtxO can only be spent if 100ADA goes to Alice.\n\nA small detail to notice is that the contract doesn’t force anything on the NFT or what should be done with it. It doesn’t need to, as the only thing that Alice is interested in is getting the money when Eve spends the BuyNFT UTxO. What Eve does with the NFT doesn’t need to be specified in the contract. On the other hand, if Alice creates the BuyNFT contract and doesn’t put any NFT into it, Eve can see that the contract is empty and does not spend the BuyNFT UTxO.\n\n#### The Double Satisfaction[​](#the-double-satisfaction \"Direct link to The Double Satisfaction\")\n\nThe classic double satisfaction vulnerability stems from using multiple contracts in the same transaction when they do not expect it. Each contract’s validator validates the transaction independently and they all must be satisfied for the transaction to be validated by the blockchain.\n\nImagine that Alice wants to sell 2 different NFTs, so she creates 2 different BuyNFT contracts. If someone wants to buy both NFTs, Alice would expect them to use the contract this way:\n\n![DS-3](/assets/images/ds-3-1b7a487d76403ea6765f88c287993fb8.png)\n\n![DS-3](/assets/images/ds-3-1b7a487d76403ea6765f88c287993fb8.png)\n\nAlice would expect Eve to use multiple BuyNFT UTxOs only if Eve pays for each of them.\n\nHowever, because each validator validates the transaction independently of the second validator, if Eve pays just 120 ADA, both validators still pass:\n\n![DS-4](/assets/images/ds-4-6857b0247fd222cae0445533d3ba2123.png)\n\n![DS-4](/assets/images/ds-4-6857b0247fd222cae0445533d3ba2123.png)\n\nBoth validators see the same output UTxO with 120 ADA going to Alice so they are satisfied.\n\nSo by paying just 120 ADA, Eve could buy both NFTs. We call this vulnerability double satisfaction because Eve satisfies two conditions where she should have satisfied only one.\n\n#### Forbidding multiple script inputs[​](#forbidding-multiple-script-inputs \"Direct link to Forbidding multiple script inputs\")\n\nBob’s first idea for disallowing such an attack is a simple one. The problem occurs when there are two UTxOs of the same script on the input, and such a situation can be prevented by the smart contract. He adds a new rule into the BuyNFT smart contract:\n\nThe inputs of the transaction contain only a single BuyNFT script UTxO\nEach BuyNFT validator now checks that no other script with the same validator hash (a hash of the validator’s code contained in the address of the UTxO) is on the input of the transaction. This is great as we no longer can be vulnerable to double satisfaction between two BuyNFT scripts! Alice therefore happily creates her NFT offers.\n\nAfter a while, the smart contract is updated with a minor change and Alice starts using the new one — BuyNFTv2 . The minor change, however, changed the script hash of the contract, and all the old NFTs that Alice offered are still locked in the original BuyNFT. These two scripts have different hashes, and therefore can be used in the following transaction by Eve:\n\n![DS-5](/assets/images/ds-5-27864ddf96196b658343b59dbaa75488.png)\n\n![DS-5](/assets/images/ds-5-27864ddf96196b658343b59dbaa75488.png)\n\nEve uses scripts with two different script hashes to perform the double satisfaction attack.\n\nThis is where Bob starts to understand that the problem he’s dealing with is more difficult than he originally thought. Not only can an attacker utilize previous versions of the BuyNFT script, but the attacker can also utilize any script that Alice uses. Bob must therefore forbid all but one script among the inputs — now each BuyNFT validator checks that it’s the only script among the inputs, and doesn’t even look at the validator hashes of the other scripts.\n\nThis might seem like an overkill, but actually, it’s still not enough.\n\n#### Minting policies & Rewarding scripts[​](#minting-policies--rewarding-scripts \"Direct link to Minting policies & Rewarding scripts\")\n\nWe did not yet mention two other types of smart contracts on Cardano.\n\nThe workings of minting policies is very similar to the validators shown in the previous blog, except for a few minor changes (e.g. the minting policies do not contain any datum). We can write complex rules about the transaction. Only transactions fulfilling the rules in a minting policy can mint tokens. For example, Alice makes a minting policy that allows anyone who sends her 100 Ada to mint a single AToken. At the same time, she uses BuyNFT to sell some of her NFTs. The reader should now know exactly where this is going;\n\n![DS-6](/assets/images/ds-6-406a26cf9ff898420ed03c08462f88de.png)\n\n![DS-6](/assets/images/ds-6-406a26cf9ff898420ed03c08462f88de.png)\n\nEve exploits the double satisfaction vulnerability, but this time it’s between the script UTxO and the minting policy for AToken.\n\nThe same applies to staking scripts — if Alice had a staking credential that allows anyone to withdraw the rewards if the rewards are sent to her address, Eve could withdraw the rewards and buy the NFT with them.\n\n#### Double satisfaction in the same script[​](#double-satisfaction-in-the-same-script \"Direct link to Double satisfaction in the same script\")\n\nBob’s head now really starts to hurt and so he forbids all the scripts, minting policies and staking withdrawals. He also adds a fee for himself from each NFT sale. New contract rules are:\n\nAt least 0.9 *price Ada go to the address of the seller.\nAt least 0.1* price Ada go to the address of Bob.\nThere are no smart contracts, minting policies or rewarding scripts in the same transaction.\nWhen Alice now sells an NFT, the transaction looks like this:\n\n![DS-7](/assets/images/ds-7-8626fbb07fb65ff054b3b640b77616d1.png)\nBob gets 10% of the price of each sold NFT.\n\n![DS-7](/assets/images/ds-7-8626fbb07fb65ff054b3b640b77616d1.png)\n\nThere is yet another variant of double satisfaction in this script. If Bob decides to sell an NFT, he should get both the fee and the NFT price. However, Eve doesn’t need to pay him the fee, as she can satisfy the condition by just paying him the NFT price.\n\n![DS-8](/assets/images/ds-8-68354a03f5b791313affbeec30bd9f46.png)\nEve pays only 90 Ada for the NFT which should cost her 100 Ada.\n\n![DS-8](/assets/images/ds-8-68354a03f5b791313affbeec30bd9f46.png)\n\nThis is, strictly speaking, not a double satisfaction as the exploit does not satisfy two scripts. But the principle of the attack is so similar that we feel this is the best place to mention it. A simple way to prevent this attack is to compute how much Ada should go to which address by summing the different datum fields, and then comparing the result with how much Ada actually goes there. In this case, we would compute that at least 100 Ada should go to Bob and Eve’s malicious attempt would fail.\n\n#### Remediation[​](#remediation \"Direct link to Remediation\")\n\nIn general, scripts that expect a payment to be made should:\n\nBan all other scripts from the transaction inputs.\nBan all staking withdrawals.\nBan the minting of all tokens in the transaction.\nAs you can see, this is very restricting for the scripts. In many cases, we need multiple smart contracts to interact. Some other ways include:\n\nOrdering of the inputs and the outputs. The first input’s validator only checks the first corresponding output, the second only checks the second, etc. This prevents double satisfaction as each script checks its output independently.\nTxT pattern — the whole validation logic is offloaded from the input validators to the minting policy of a single token. The double satisfaction is more easily prevented because the minting policy is the single point that validates the whole transaction. It can pair the inputs and outputs in any way necessary. Read more about the TxT pattern here.\nTagging the outputs in some way — this can be done with datums of the output UTxOs or by a mapping of the inputs to the outputs passed via a redeemer.\nHowever, no amount of prevention can ensure safe interaction of multiple scripts that do not know about each other straight away. That’s because each of the scripts can choose a different way to deal with double satisfaction — while a script A can use the ordering of the inputs and the outputs, a script B can use the tagging of outputs. An attacker can then tag the first output and trick both scripts into thinking it’s their output.\n\n![DS-9](/assets/images/ds-9-db8555bf9f408c10094066ff87ebf006.png)\nBoth scripts check double satisfaction differently so they can both be satisfied.\n\n![DS-9](/assets/images/ds-9-db8555bf9f408c10094066ff87ebf006.png)\n\nUntil a solution is standardized, any interaction between multiple Cardano smart contracts is either forbidden or possibly vulnerable. For now, users can also help prevent double satisfaction themselves by using a unique address for each usage of the script. If Alice did so, Eve could never have exploited the contract as there would never have been two contracts expecting payment to the same address in the first place. This is, however, not always possible in this simple form — for example, when we want to chain an output of a script to be an input into another.\n\n#### Conclusion[​](#conclusion \"Direct link to Conclusion\")\n\nIf you are currently developing a Cardano smart contract, our recommendation is to forbid any other scripts, minting policies and staking withdrawals in the transaction. However, this prevents any interoperability with other scripts. To prevent double satisfaction in more complex scenarios, a case-by-case solution may need to be thought of. Feel free to reach out to us if that is the case.",
  "images": [],
  "extraction_metadata": {
    "batch_number": 10,
    "extraction_timestamp": "2025-09-19T14:05:05.551444",
    "extraction_time": 2.0458879470825195,
    "source": "tavily_api_raw"
  }
}