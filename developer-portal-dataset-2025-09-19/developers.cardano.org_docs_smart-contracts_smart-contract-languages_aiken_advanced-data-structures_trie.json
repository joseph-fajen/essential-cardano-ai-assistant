{
  "url": "https://developers.cardano.org/docs/smart-contracts/smart-contract-languages/aiken/advanced-data-structures/trie",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Trie\n\n## Introduction[​](#introduction \"Direct link to Introduction\")\n\nThe Aiken Trie project provides a Aiken-based implementation of Distributed Tries for the Cardano blockchain. This project allows developers to leverage the security and efficiency of Tries in their Cardano smart contracts, ensuring data integrity and efficient data verification. This project uniquely allows scalable data structures across multiple utxos, with a developer-friendly typescript api.\n\nThe github repository introducing these data structures can be found [here](https://github.com/Anastasia-Labs/aiken-trie).\n\n## Documentation[​](#documentation \"Direct link to Documentation\")\n\n### Trie[​](#trie \"Direct link to Trie\")\n\nA trie, also known as a prefix tree or digital tree, is a kind of search tree—an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. This makes tries extremely useful for applications like autocomplete systems, spell checkers, and IP routing. Here's a detailed explanation:\n\n#### Basic concept[​](#basic-concept \"Direct link to Basic concept\")\n\nA Trie is a type of search tree, an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings. Here's how it's structured:\n\n#### Key Encoding[​](#key-encoding \"Direct link to Key Encoding\")\n\nThe core of a Trie is its key encoding mechanism. This mechanism takes input keys of any size and encodes them into a path through the Trie. Each character or byte of the key represents a step down the Trie, from the root towards the leaves.\n\n#### Construction[​](#construction \"Direct link to Construction\")\n\n#### Features[​](#features \"Direct link to Features\")\n\n#### Example[​](#example \"Direct link to Example\")\n\nConsider a Trie with the keys \"car\", \"cat\", and \"dog\":\nThe structure of the Trie after inserting the keys \"car\", \"cat\", and \"dog\" would look something like this:\n\nImagine the Trie as a tree where each node represents a character. The root node is empty and branches out to three paths: one for \"c\", one for \"d\", and potentially others for different starting letters of keys not shown in this example. The \"c\" node branches into \"a\", which further branches into \"r\" and \"t\" to form the words \"car\" and \"cat\". Each of these nodes, \"r\" and \"t\", would be leaf nodes for \"car\" and \"cat\", respectively, possibly containing values or simply marking the end of the word. Similarly, the \"d\" node branches into \"o\", which then branches into \"g\", forming the word \"dog\" with \"g\" as its leaf node. This structure allows for efficient searching, adding, and deleting of keys by following the branches corresponding to each character in the key.\n\nThis visual representation helps understand how Tries optimize space and search time, especially with a large number of keys sharing common prefixes. By sharing the initial \"ca\" in \"car\" and \"cat\", the Trie saves space compared to storing each word independently. This efficiency becomes more pronounced with a larger dataset with more shared prefixes.\n\n## Validator Logic[​](#validator-logic \"Direct link to Validator Logic\")\n\n`use aiken/dict  \nuse aiken/list  \nuse aiken/transaction.{  \n Input, Mint, Output, ScriptContext, Spend, Transaction, WithdrawFrom,  \n}  \nuse aiken/transaction/credential.{Inline, ScriptCredential}  \nuse aiken_trie/trie  \nuse aiken_trie/types  \n  \nvalidator {  \n fn spend(_d: Data, _r: Data, ctx: ScriptContext) {  \n expect ScriptContext {  \n transaction: Transaction { inputs, withdrawals, .. },  \n purpose: Spend(own_oref),  \n } = ctx  \n expect Some(self) =  \n inputs |> list.find(fn(inp) { inp.output_reference == own_oref })  \n withdrawals  \n |> dict.has_key(Inline(self.output.address.payment_credential))  \n }  \n  \n fn main(r: Data, ctx: ScriptContext) {  \n let ScriptContext { transaction, purpose } = ctx  \n when purpose is {  \n Mint(policy_id) ->  \n // validation happens in staking  \n transaction.withdrawals  \n |> dict.has_key(Inline(ScriptCredential(policy_id)))  \n WithdrawFrom(stake_cred) -> {  \n expect redeemer: types.TrieAction = r  \n trie.trie_handler(stake_cred, redeemer, transaction)  \n }  \n _ -> fail  \n }  \n }  \n}`\n\n## Offchain Logic[​](#offchain-logic \"Direct link to Offchain Logic\")\n\nFor a guide demonstrating how to use the Trie for blockchain applications using a transaction builder please refer to the [codebase](https://github.com/Anastasia-Labs/aiken-trie).",
  "images": [],
  "extraction_metadata": {
    "batch_number": 11,
    "extraction_timestamp": "2025-09-19T14:05:12.534540",
    "extraction_time": 3.978458881378174,
    "source": "tavily_api_raw"
  }
}