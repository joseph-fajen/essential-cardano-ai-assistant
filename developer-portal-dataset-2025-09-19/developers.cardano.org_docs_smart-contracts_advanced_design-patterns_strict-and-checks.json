{
  "url": "https://developers.cardano.org/docs/smart-contracts/advanced/design-patterns/strict-and-checks",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Strict `&&` Checks\n\n## Introduction[​](#introduction \"Direct link to Introduction\")\n\nIn the realm of Cardano smart contracts, the offchain component plays a pivotal role. These\ncomponents are essentially pure functions that evaluate based on transaction-related details fed as\nparameters. Typically, the implementation of these checks follows a two-step process:\n\nA common practice in writing this part of the code is represented as:\n\n `...  \n check1 && check2 && check3  \n ...`\n\n## The Problem[​](#the-problem \"Direct link to The Problem\")\n\nAlthough Haskell inherently operates under lazy semantics, a notable shift occurs when validator\ncode is compiled to UPLC (Untyped Plutus Core), which adheres to strict evaluation principles. For a\nvalidator to pass, it is imperative that all conditions are met successfully. However, certain\nlanguage compilers, in an attempt to mimic Haskell's lazy evaluation, end up introducing superfluous\n`force` and `delay` operations into the generated UPLC code.\n\n`force`\n`delay`\n\nConsider the following illustration where a Haskell code segment akin to the one above could be\ntranslated into this UPLC code by some compilers:\n\n `Force (Force (  \n Builtins.IfTheElse  \n check1  \n (Delay Builtins.IfThenElse  \n check2  \n (Delay check3)  \n (con False)  \n )  \n (con False)  \n ))`\n\nAlthough this representation is semantically accurate, it poses efficiency issues, particularly in\nsuccessful (fully evaluated) scenarios. The optimization of evaluating validator functions is\ncrucial, especially in the context of successful transactions, as no transaction costs are incurred\nwhen a validator fails, but costs do apply when it passes.\n\n## The Solution[​](#the-solution \"Direct link to The Solution\")\n\nGiven the inconsistent implementation of the boolean binary operator `&&` across various languages\nlike Plutus, Plutarch, and Aiken, we propose a dual-operation set in this library. This set is\ndesigned to ensure predictable compilation outcomes, producing code devoid of extraneous `force` and\n`delay` expressions. Additionally, it includes an alternate operation set that does incorporate\nthese expressions, catering to scenarios where such behavior is desirable for debugging or other\nspecific purposes.\n\n`&&`\n`force`\n`delay`\n\n## Conclusion[​](#conclusion \"Direct link to Conclusion\")\n\nIn conclusion, this library addresses a critical aspect of Cardano smart contract development by\noffering a reliable solution to a common problem encountered during the compilation process. By\nproviding a clear and predictable way to handle boolean operations, we enhance the efficiency and\nreliability of smart contract execution on the Cardano blockchain. This approach not only optimizes\ntransaction costs but also simplifies the development process, allowing developers to focus more on\nthe functional aspects of their smart contracts rather than getting entangled in the intricacies of\ncompilation semantics.",
  "images": [],
  "extraction_metadata": {
    "batch_number": 10,
    "extraction_timestamp": "2025-09-19T14:05:05.551444",
    "extraction_time": 2.0458879470825195,
    "source": "tavily_api_raw"
  }
}