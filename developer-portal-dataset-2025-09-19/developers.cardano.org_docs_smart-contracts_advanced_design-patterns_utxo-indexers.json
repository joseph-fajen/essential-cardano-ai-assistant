{
  "url": "https://developers.cardano.org/docs/smart-contracts/advanced/design-patterns/utxo-indexers",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Redeemer Indexing\n\n## Introduction[​](#introduction \"Direct link to Introduction\")\n\nThe Redeemer Indexing design pattern leverages the deterministic script evaluation property of the Cardano ledger to achieve substantial performance gains in onchain code. This pattern allows smart contracts to eliminate the need for linear searches and costly on-chain operations by utilizing deterministic indexing in the redeemer, thereby enabling O(1) lookups and drastically reducing validation costs.\n\n## Deterministic Script Evaluation Property[​](#deterministic-script-evaluation-property \"Direct link to Deterministic Script Evaluation Property\")\n\nThe deterministic script evaluation property, also stated as \"script interpreter arguments are fixed\", is a property of the Cardano ledger that guarantees that the outcome of Plutus script evaluation in a (phase-1 valid) transaction depends only on the contents of that transaction, and not on when, by who, or in what block that transaction was submitted.\n\nSimply put, all the inputs to Plutus scripts are known during transaction construction.\n\nThis property can be leveraged to take advantage of powerful smart contract optimizations. Because all inputs to Plutus scripts are known at the time of transaction construction, a large number of traditionally on-chain operations can be performed off-chain. This ensures that on-chain operations can be minimized to a series of verifications, thereby maintaining the integrity of the transaction.\n\n## Zero On-Chain Linear Search[​](#zero-on-chain-linear-search \"Direct link to Zero On-Chain Linear Search\")\n\nOne of the most potent applications of this pattern is the complete elimination of the need to perform linear search operations on-chain. Normally, to find an input, output, or other transaction component (i.e. a specific token within a value), a linear search is required, these operations can become expensive very quickly due to the heavily constrained smart contract execution budget in blockchains. The Redeemer Indexing design pattern allows us to perform these lookup operations offchain.\n\nIn PlutusV3, there is only a single argument to Plutus scripts, namely, the `ScriptContext`.\n\n`ScriptContext`\n\nRoughly the design pattern works as follows:\n\n`elemAt`\n\nFor instance, if you want your validator to have access to a specific tx output you first build your transaction then you search the built transaction to obtain the index of the output, and then you add that index to the redeemer. In your onchain code, instead of searching for the element, you can simply get the `elemAt` the index provided by your redeemer and check that it does indeed satisfy the search criteria.\n\n`elemAt`\n\nThus, lookups are reduced to O(1) checks, where the on-chain code simply confirms that the indexed element is as expected.\n\n## List Length Operations[​](#list-length-operations \"Direct link to List Length Operations\")\n\nYou can also use this design pattern to avoid the need to perform expensive traversals of dynamic data-structures like `Lists` and `Maps` in your onchain code to determine the number of elements they contain. Instead, you can calculate the number of elements offchain, and provide it to the validator via the redeemer, then onchain you only need to check that the length your provided in the redeemer is correct. To perform this check, you apply the builtin `tail` function n times, where n is the `expectedLength` you passed via the redeemer and then you check that the result equals the empty list.\n\n`Lists`\n`Maps`\n`tail`\n`expectedLength`\n\nHere is a non-optimized implementation of a length function that calculates and returns the number of elements in a `BuiltinList`.\n\n`BuiltinList`\n`builtinListLength :: Integer -> BI.BuiltinList a -> Integer  \nbuiltinListLength l =  \n go :: Integer -> BI.BuiltinList a -> Integer  \n go acc xs =   \n -- matchList is a builtin function that takes a list and branches depending on whether the list is empty or not  \n -- it expects the non-empty branch argument to be a function (\\x xs -> ..) where x is the head of the list and xs is the tail.  \n BI.matchList xs  \n -- if the list is empty we return `acc`   \n acc  \n -- if the list is non-empty we increase the counter and recurse  \n (\\_ ys -> go (acc + 1) ys)`\n\nAs an exercise in this design pattern, try to design an optimized version of the length function that accepts as an argument the expected list length (computed offchain and passed to the onchain code via the redeemer) and uses that argument to reduce unnecessary recursion / null checks on the list. (hint: think about how you can replace `matchList`).\n\n`matchList`\n\n### Example 2 - List Length[​](#example-2---list-length \"Direct link to Example 2 - List Length\")\n\n`import qualified PlutusTx.Builtins as BI  \nimport qualified PlutusTx.Builtins.Internal as BI  \nimport Language.Haskell.TH  \n  \n-- A template haskell function that generates `n` inlined tail applications ie:  \n-- $(genInlinedTails 3 'xs)  \n--  \n-- compiles into:  \n--  \n-- (BI.tail (BI.tail (BI.tail xs)))  \n--   \ngenInlinedTails :: Int -> Name -> Q Exp  \ngenInlinedTails n xs = foldr (\\_ acc -> [| BI.tail $acc |]) (varE xs) [1..n]  \n  \n-- Recursively compute the count of elements in a list (the count starts at `acc`)  \n-- ie: builtinListLength 3 [1,2] == 5   \n-- the list has a length of 2 and `acc` is 3, so we have 2 + 3 = 5.  \nbuiltinListLength :: Integer -> BI.BuiltinList a -> Integer  \nbuiltinListLength acc xs =   \n -- matchList is a builtin function that takes a list and branches depending on whether the list is empty or not  \n -- it expects the non-empty branch argument to be a function (\\x xs -> ..) where x is the head of the list and xs is the tail.  \n BI.matchList xs  \n -- if the list is empty we return `acc`   \n acc  \n -- if the list is non-empty we increase the counter and recurse  \n (\\_ ys -> go (acc + 1) ys)  \n  \n-- An efficient length function that takes as a parameter the expected length and uses that knowledge  \n-- to avoid unnecessary recursion and checks.   \nbuiltinListLengthFast :: forall a. Integer -> BI.BuiltinList a -> Integer  \nbuiltinListLengthFast n xs = go n 0 xs   \n where   \n go :: Integer -> Integer -> BI.BuiltinList a -> Integer  \n go remainingExpected currentCount xs   \n | 30 <= remainingExpected = go (remainingExpected - 30) (currentCount + 30) $(genInlinedTails 30 'xs)  \n | 20 <= remainingExpected = go (remainingExpected - 20) (currentCount + 20) $(genInlinedTails 20 'xs)  \n | 10 <= remainingExpected = go (remainingExpected - 10) (currentCount + 10) $(genInlinedTails 10 'xs)  \n -- with less than 10 elements we revert to chooseList because the overhead of builtinAddInteger, builtinIfThenElse and builtinLessThanEquals  \n -- is more inefficient than simply recursing with matchList. Although it may be more efficient to falling back to a function that   \n -- drops multiple elements at a time (3-4) at which point the aforementioned overhead might be compensated for by the reduced number of recursive calls.  \n | otherwise = builtinListLength currentCount xs`\n\n## General Use[​](#general-use \"Direct link to General Use\")\n\nMore generally, this design pattern can be used to improve performance in any situation where checking the correctness of a result is more efficient than calculating the result.\n\n### Example 1: Enforce that the transaction includes exactly `n` script inputs[​](#example-1-enforce-that-the-transaction-includes-exactly-n-script-inputs \"Direct link to example-1-enforce-that-the-transaction-includes-exactly-n-script-inputs\")\n\n`n`\n\nHere is a non-optimized implementation of a function that counts the amount of `Spend` redeemers in `txInfoRedeemers`, thus it tells us the total number of spending script executions\nin the transaction (this will also be the total number of script inputs in the transaction).\n\n`Spend`\n`txInfoRedeemers`\n`{-# INLINE countSpendRedeemersSkipFirst #-}  \ncountSpendRedeemersSkipFirst :: BuiltinData -> Integer  \ncountSpendRedeemersSkipFirst b = go (BI.tail $ BI.unsafeDataAsMap b) 0  \n where  \n go :: BI.BuiltinList (BI.BuiltinPair BI.BuiltinData BI.BuiltinData) -> Integer -> Integer  \n go redeemers i = if BI.fst (BI.unsafeDataAsConstr (BI.fst $ BI.head redeemers)) == 1 then go (BI.tail redeemers) (i + 1) else i`\n\nAs an exercise in this design pattern, try to design a variant of this function that takes as an argument the expected number of `Spend` redeemers (computed offchain and passed to the onchain code via the redeemer), and use it to efficiently compute the actual number of `Spend` redeemers (erroring if the actual differs from the expected).\n\n`Spend`\n`Spend`\n\n## Singular Input Processing[​](#singular-input-processing \"Direct link to Singular Input Processing\")\n\nThe foundational concept of smart contract validation in Cardano begins with singular input\nprocessing. In its simplest form, validators, or smart contracts, are designed to validate\ntransactions that consist of a single input and optionally a single output. The following\nillustrates this basic structure:\n\nThis straightforward scenario provides a clear validation path, making it relatively simple for the\nsmart contract to verify and process the transaction.\n\nThe code for the validator in this case would be something like this:\n\n`validatorA :: Datum -> Redeemer -> ScriptContext -> Bool  \nvalidatorA datum redeemer context =  \n let input = findOwnInput context  \n [output] = getContinuingOutputs context  \n in validateWithInputOutput input output  \n where  \n findOwnInput :: ScriptContext -> Maybe TxInInfo  \n findOwnInput ScriptContext{scriptContextTxInfo=TxInfo{txInfoInputs},   \n scriptContextPurpose=Spending txOutRef} =  \n find (\\TxInInfo{txInInfoOutRef} -> txInInfoOutRef == txOutRef) txInfoInputs  \n findOwnInput _ = Nothing`\n\nNote that `findOwnInput` checks the `TxOutRef` of each input to identify the one currently being validated. In this case, the check (comparing `TxOutRef`) is relatively cheap, even so, the actual search is very expensive since in the worst-case we traverse the entire list of inputs and check each one. Furthermore, often you will want to search for an input / output with more complex criteria ie:\n\n`findOwnInput`\n`TxOutRef`\n`TxOutRef`\n`validatorB :: AssetClass -> BuiltinData -> BuiltinData -> ScriptContext -> Bool  \nvalidatorB stateToken _ _ ctx =  \n let authInput = findAuth ctx   \n goodOutput = findOutputWithCriteria ctx  \n in validate authInput goodOutput  \n where  \n findAuth :: ScriptContext -> Maybe TxInInfo  \n findAuth ScriptContext{scriptContextTxInfo=TxInfo{txInfoInputs}} =  \n find (\\TxInInfo{txInOutput} -> assetClassValueOf stateToken (txOutValue txInOutput) == 1) txInfoInputs  \n  \n findOutputWithCriteria :: ScriptContext -> Maybe TxInInfo  \n findOutputWithCriteria ScriptContext{scriptContextTxInfo=TxInfo{txInfoOutputs}} =  \n find (\\txOut -> criteria txOut) txInfoOutputs`\n\nUsing the redeemer indexing design pattern we can avoid needing to make these checks for each input / output, instead we pass the index of the input / output we are looking into the redeemer then we just make our checks for the element at that index:\n\n`validatorA :: AssetClass -> BuiltinData -> Integer -> ScriptContext -> Bool   \nvalidatorA stateToken _ tkIdx ctx =  \n assetClassValueOf stateToken (txInInfoResolved (elemAt tkIdx (txInfoInputs (txInfo ctx)))) == 1`\n\nThis design pattern can complicate the construction of the redeemer in off-chain code because the input index (corresponding to a given UTxO) that you define in the redeemer often will not index the correct UTxO after balancing / coin-selection since new inputs will be added to the transaction. Luckily [lucid-evolution](https://github.com/Anastasia-Labs/lucid-evolution) provides a high-level interface that abstracts all the complexity away and makes writing offchain code for this design pattern extremely simple!\n\nTo construct the redeemer for `validatorA` with [lucid-evolution](https://github.com/Anastasia-Labs/lucid-evolution):\n\n`validatorA`\n`import { Data } from \"@lucid-evolution/plutus\";  \nimport {  \n Blockfrost,  \n Lucid,  \n RedeemerBuilder,  \n SpendingValidator  \n} from \"@lucid-evolution/lucid\";  \nimport { toUnit } from \"@lucid-evolution/utils\";  \n  \nconst network = \"Preview\";  \n  \nconst lucid = await Lucid(  \n new Blockfrost(  \n `https://cardano-preview.blockfrost.io/api/v0`,  \n CONFIG.API_KEY  \n ),  \n network  \n );  \n  \nconst api = await window.cardano.nami.enable();  \nlucid.selectWallet.fromAPI(api);  \n  \nconst validatorA : SpendingValidator = {  \n type: \"PlutusV2\",  \n script: validatorACBOR,  \n };  \nconst contractAddress = validatorToAddress(network, validator);  \n  \n// policy id and asset name in Hex of the state token.  \nconst stateToken = toUnit(STATE_TOKEN_CS, STATE_TOKEN_NAME)   \n// Get the UTxO that contains the state token  \nconst authUTxO = await lucid.utxoByUnit(stateTokenId);  \n  \nconst validatorARedeemer: RedeemerBuilder = {  \n kind: \"selected\",  \n // the function that constructs the redeemer using inputIndices, the list of indices  \n // corresponding to the UTxOs defined as inputs below.   \n makeRedeemer: (inputIndices: bigint[]) => {  \n return Data.to(inputIndices[0]);  \n },  \n // the inputs that are relevant to the construction of the redeemer in this case our  \n // redeemer only cares about the index of the input that contains the auth token.   \n inputs: [authUTxO],  \n};  \n  \n// Get the UTxO at validatorA that we want to spend  \nconst [utxoAtValidatorA] = await lucid.utxosAt(contractAddress)  \n  \n// Transaction that uses the redeemer  \nlet tx = await lucid  \n .newTx()  \n .collectFrom([utxoAtValidatorA], validatorARedeemer)  \n .collectFrom([authUTxO])  \n .attach.SpendingValidator(validatorA)  \n .complete();  \n  \n// Sign the transaction  \nconst signedTx = await tx.sign.withWallet().complete();  \n// Submit the transaction  \nconst txHash = await signedTx.submit();`\n\nFor a complete example check the examples included in the current directory.\n\n## Multiple Inputs and Outputs[​](#multiple-inputs-and-outputs \"Direct link to Multiple Inputs and Outputs\")\n\nHowever, as the need for increased throughput arises, smart contracts may require the ability to\nhandle multiple inputs and outputs within a single transaction. This batch processing capability can\nsignificantly improve efficiency. Consider the following example:\n\nWhile this approach enhances throughput, it introduces a challenge for the validator. Determining\nhow inputs and outputs are paired and the order in which they should be processed becomes complex\nand potentially costly.\n\nTo avoid unintended consequences, the following vulnerabilities must be considered:\n\n## UTxO Indices in Redeemer[​](#utxo-indices-in-redeemer \"Direct link to UTxO Indices in Redeemer\")\n\nTo address the challenges posed by multiple inputs and outputs, the UTxO Indexer design pattern\nintroduces the use of UTxO indices within the redeemer. The redeemer is a component of a transaction\nthat carries additional data required for smart contract validation. In this context, the indices of\nscript inputs and their corresponding outputs are included within the redeemer.\n\n`data MyRedeemer = MyRedeemer  \n { ioIndices :: [(Integer, Integer)] -- [(inputIndex, outputIndex)]  \n }  \n  \nvalidator :: Datum -> MyRedeemer -> ScriptContext -> Bool  \nvalidator datum redeemer context =  \n all validateWithIndices indices && allIndicesAccountedFor indices  \n where  \n indices = ioIndices redeemer  \n txInfo = scriptContextTxInfo context  \n inputs = txInfoInputs txInfo  \n outputs = txInfoOutputs txInfo  \n validateWithIndices (inputIndex, outputIndex) =  \n let input = inputs `elemAt` inputIndex  \n output = outputs `elemAt` outputIndex  \n in validateWithInputOutput input output`\n\nBy incorporating UTxO indices in the redeemer, the validator gains the ability to more effectively\nsort and pair inputs and outputs during the validation process. Additionally, the validator needs to\nensure that no input or output is used more than once, and that indices are not missing.\n\nTo achieve this, the implementation to be presented in this repository aims to tackle all the checks\nmentioned above, and the pattern is integrated with a transaction level validation pattern\n(\"Transaction level validation for spending validators via stake validators using the withdraw zero\ntrick\" or \"Transaction level validation for spending validators via minting policies\") to achieve\nthe best possible throughput.\n\nAlso, while the ordering of outputs are preserved (the validator gets them in the same order, in\nwhich the builder of the transaction provided them), the inputs are re-ordered before the validator\nreceives them. The good news is that this re-ordering is deterministic, it can be taken into account\nby the transaction builder before sending the transaction to a node for inclusion in the blockchain.\nThe inputs are ordered by the id of the UTxO (which consists of the creating transaction hash and the\nindex of its output) lexicographically, first by transaction hash and then by output index. For the\ntransaction builder to determine the indices of the inputs, it needs to order them in the same way\nbefore creating the redeemer.\n\nWhen using this design pattern to index multiple elements in the same data-structure there is a dangerous\nfootgun that can lead to vulnerabilites. You have to account for the fact that since there redeemer\ncan contain arbitrary information, a malicious user may attempt to provide duplicate indices in their\nredeemer, which if unaccounted for, could trick the smart contract validation logic into believing\nall the relevant inputs have been processed and validated against (when in actuality the contract has\nprocessed and validated the same inputs multiple times thus allowing other inputs to be spent without being validated against).\n\nA common way to avoid this potential attack vector is to add checks to your onchain code to enforce that all the\nindices provided by the redeemer are unique (ie. there are no duplicates). Another way is to introduce checks\nto your onchain code to enforce that the provided indices list is sorted and then instead of using `elemAt` (which\ngets the element at the provided index and discards the list of untraversed elements) you use a variant that\nkeeps the untraversed elements and continues on to find the next element. In this solution you should provide the\nrelative indices in the redeemer (the number of elements between the current element and the previous element) instead of\nproviding their absolute indexes.\n\n`elemAt`\n\n### Example 3 - Expected Redeemers[​](#example-3---expected-redeemers \"Direct link to Example 3 - Expected Redeemers\")\n\n`import qualified PlutusTx.Builtins as BI  \nimport qualified PlutusTx.Builtins.Internal as BI  \nimport PlutusTx.Builtins.Internal (BuiltinData)  \n  \n  \n-- Plinth (formerly PlutusTx) implementation:  \n{-# INLINE enforceNSpendRedeemersSkipFirst #-}  \nenforceNSpendRedeemersSkipFirst :: Integer -> BuiltinData -> Bool  \nenforceNSpendRedeemersSkipFirst n b = isLastSpend (dropN (n - 1) (BI.unsafeDataAsMap b))  \n where  \n dropN :: Integer -> BI.BuiltinList a -> BI.BuiltinList a  \n dropN 0 xs = xs  \n dropN i xs = dropN (i - 1) (BI.tail xs)  \n  \n isNonSpend :: BuiltinData -> Bool  \n isNonSpend red = BI.fst (BI.unsafeDataAsConstr (BI.fst $ BI.unsafeDataAsConstr red)) /= 1  \n  \n isLastSpend :: BI.BuiltinList (BI.BuiltinPair BI.BuiltinData BI.BuiltinData) -> Bool  \n isLastSpend redeemers =  \n let constrPair = BI.fst $ BI.head redeemers  \n constrIdx = BI.fst (BI.unsafeDataAsConstr constrPair)  \n in if constrIdx == 1  \n then go (BI.tail redeemers)  \n else False  \n  \n go :: BI.BuiltinList (BI.BuiltinPair BI.BuiltinData BI.BuiltinData) -> Bool  \n go redeemers =  \n if BI.fromOpaque $ BI.null redeemers  \n then True  \n else isNonSpend (BI.fst $ BI.head redeemers)  \n  \n-- Plutarch implementation  \npenforceNSpendRedeemers :: forall {s :: S}. Term s PInteger -> Term s (AssocMap.PMap 'AssocMap.Unsorted PScriptPurpose PRedeemer) -> Term s PBool  \npenforceNSpendRedeemers n rdmrs =  \n let isNonSpend :: Term _ (PAsData PScriptPurpose) -> Term _ PBool  \n isNonSpend red = pnot # (pfstBuiltin # (pasConstr # (pforgetData red)) #== 1)  \n   \n isLastSpend :: Term _ (PBuiltinList (PBuiltinPair (PAsData PScriptPurpose) (PAsData PRedeemer)) :--> PBool)  \n isLastSpend = plam $ \\redeemers ->   \n let constrPair :: Term s (PAsData PScriptPurpose)  \n constrPair = pfstBuiltin # (phead # redeemers)  \n constrIdx = pfstBuiltin # (pasConstr # (pforgetData constrPair))  \n in pif   \n (constrIdx #== 1)   \n (pelimList (\\x _ -> isNonSpend (pfstBuiltin # x)) (pconstant True) (ptail # redeemers))  \n perror  \n in isLastSpend # (pdropFast # (n - 1) # (pto rdmrs))`\n\n## Conclusion[​](#conclusion \"Direct link to Conclusion\")\n\nThe UTxO Indexer design pattern offers a powerful solution to the challenges posed by transactions\nwith multiple inputs and outputs. By leveraging UTxO indices within the redeemer, smart contracts on\nthe Cardano blockchain can achieve greater throughput without compromising on the efficiency and\nintegrity of the validation process. This pattern exemplifies the adaptability and scalability of\nsmart contract design in the evolving landscape of blockchain technologies.\n\n`n`",
  "images": [],
  "extraction_metadata": {
    "batch_number": 10,
    "extraction_timestamp": "2025-09-19T14:05:05.551444",
    "extraction_time": 2.0458879470825195,
    "source": "tavily_api_raw"
  }
}