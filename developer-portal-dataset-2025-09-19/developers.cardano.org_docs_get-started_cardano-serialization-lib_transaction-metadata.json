{
  "url": "https://developers.cardano.org/docs/get-started/cardano-serialization-lib/transaction-metadata",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Metadata\n\n## Transaction Metadata format[​](#transaction-metadata-format \"Direct link to Transaction Metadata format\")\n\nTransaction after the Shelley hardfork can contain arbitrary transaction meta (**note:** this is NOT the same as pool metadata)\n\nTransaction metadata takes the form of a map of metadatums, which are recursive JSON-like structures.\n\nIt is defined in [CDDL](https://tools.ietf.org/html/rfc8610), a schema grammar for representing [CBOR](https://tools.ietf.org/html/rfc7049) binary encoding as:\n\n`transaction_metadatum =  \n { * transaction_metadatum => transaction_metadatum }  \n / [ * transaction_metadatum ]  \n / int  \n / bytes .size (0..64)  \n / text .size (0..64)  \n  \ntransaction_metadatum_label = uint  \n  \ntransaction_metadata =  \n { * transaction_metadatum_label => transaction_metadatum }`\n\nFor each use we use a metadatum label specific to our use into the `TransactionMetadatum` map. If we had a JSON object such as\n\n`TransactionMetadatum`\n`{  \n \"receiver_id\": \"SJKdj34k3jjKFDKfjFUDfdjkfd\",  \n \"sender_id\": \"jkfdsufjdk34h3Sdfjdhfduf873\",  \n \"comment\": \"happy birthday\",  \n \"tags\": [0, 264, -1024, 32]  \n}`\n\nThere are 4 ways we can achieve this with different trade-offs:\n\nEach section will give examples of how to encode a similar structure. Understanding CDDL is only necessary for the last 2 options, but it is fairly simple to understand.\n\nIf your metadata schema is fixed and will be used frequently you should consider the CDDL spec option.\nIf your schema is not often used or used from many languages, the JSON option can be good as it is low set-up and fairly tech agnostic.\nIf your schema is very dynamic or non-existent, the direct use or JSON options are likely best.\nThe raw bytes option is only recommended if your data does not conform to the metadata format.\n\n## Metadata limitations[​](#metadata-limitations \"Direct link to Metadata limitations\")\n\nThese limitations are mentioned in the CDDL definition, but are worth also mentioning in prose:\n\n## Direct use[​](#direct-use \"Direct link to Direct use\")\n\nUpsides:\n\nDownsides:\n\nAs the metadatum structure is fairly expressive, we can directly use it using the structs in the metadata module of this library. These directly represent the types given in the CDDL. Namely:\n\nThe variants for numbers, bytes and text are not specific to metadata and are directly used with the general `Int` type representing a signed or unsigned number, byte arrays accepting byte arrays/`Buffer`, and strings being JS strings.\n\n`Int`\n`Buffer`\n\nWe could construct the JSON example above with the following code:\n\n`const map = CardanoWasm.MetadataMap.new();  \nmap.insert(  \n CardanoWasm.TransactionMetadatum.new_text(\"receiver_id\"),  \n CardanoWasm.TransactionMetadatum.new_text(\"SJKdj34k3jjKFDKfjFUDfdjkfd\"),  \n);  \nmap.insert(  \n CardanoWasm.TransactionMetadatum.new_text(\"sender_id\"),  \n CardanoWasm.TransactionMetadatum.new_text(\"jkfdsufjdk34h3Sdfjdhfduf873\"),  \n);  \nmap.insert(  \n CardanoWasm.TransactionMetadatum.new_text(\"comment\"),  \n CardanoWasm.TransactionMetadatum.new_text(\"happy birthday\"),  \n);  \nconst tags = CardanoWasm.MetadataList.new();  \ntags.add(CardanoWasm.TransactionMetadatum.new_int(CardanoWasm.Int.new(CardanoWasm.BigNum.from_str(\"0\"))));  \ntags.add(CardanoWasm.TransactionMetadatum.new_int(CardanoWasm.Int.new(CardanoWasm.BigNum.from_str(\"264\"))));  \ntags.add(CardanoWasm.TransactionMetadatum.new_int(CardanoWasm.Int.new_negative(CardanoWasm.BigNum.from_str(\"1024\"))));  \ntags.add(CardanoWasm.TransactionMetadatum.new_int(CardanoWasm.Int.new(CardanoWasm.BigNum.from_str(\"32\"))));  \nmap.insert(  \n CardanoWasm.TransactionMetadatum.new_text(\"tags\"),  \n CardanoWasm.TransactionMetadatum.new_list(tags),  \n);  \nconst metadatum = CardanoWasm.TransactionMetadatum.new_map(map);`\n\nWe could then parse the information back as such:\n\n`try {  \n const map = metadatum.as_map();  \n const receiver = map.get(CardanoWasm.TransactionMetadatum.new_text(\"receiver_id\"));  \n const sender = map.get(CardanoWasm.TransactionMetadatum.new_text(\"sender_id\"));  \n const comment = map.get(CardanoWasm.TransactionMetadatum.new_text(\"comment\"));  \n const tags = map.get(CardanoWasm.TransactionMetadatum.new_text(\"tags\"));  \n} catch (e) {  \n // structure did not match  \n}`\n\nFor decoding in a more exploratory manner we can check the types first as such:\n\n`function parseMetadata(metadata) {  \n // we must check the type first to know how to handle it  \n switch (metadata.kind()) {  \n case CardanoWasm.TransactionMetadatumKind.MetadataMap:  \n const mapRet = new Map();  \n const map = metadata.as_map();  \n const keys = maps.keys();  \n for (var i = 0; i < keys.len(); i += 1) {  \n const key = keys.get(i);  \n const value = parseMetadata(map.get(key);  \n mapRet.set(key, value);  \n }  \n return mapRet;  \n case CardanoWasm.TransactionMetadatumKind.MetadataList:  \n let arrRet = [];  \n const arr = metadata.as_list();  \n for (var i = 0; i < arr.len(); i += 1) {  \n const elem = parseMetadata(arr.get(i));  \n arrRet.push(elem);  \n }  \n return arrRet;  \n case CardanoWasm.TransactionMetadatumKind.Int:  \n const x = metadata.as_int();  \n // If the integer is too big as_i32() returns undefined  \n // to handle larger numbers we need to use x.as_positive() / x.as_negative() and  \n // convert from BigNums after checking x.is_positive() first  \n return x.as_i32();  \n case CardanoWasm.TransactionMetadatumKind.Bytes:  \n return Buffer.from(metadata.as_bytes());  \n case CardanoWasm.TransactionMetadatumKind.Text:  \n return metadata.as_text();  \n }  \n}`\n\nwhich recursively parses the `TransactionMetadatum` struct and transforms it into a JS `Map` / JS `object` structure by manually checking the types.\n\n`TransactionMetadatum`\n`Map`\n`object`\n\n## JSON conversion[​](#json-conversion \"Direct link to JSON conversion\")\n\nUpsides:\n\nDownsides:\n\n`-2^64 + 1`\n`-2^63`\n`const obj = {  \n receiver_id: \"SJKdj34k3jjKFDKfjFUDfdjkfd\",  \n sender_id: \"jkfdsufjdk34h3Sdfjdhfduf873\",  \n comment: \"happy birthday\",  \n tags: [0, 264, -1024, 32]  \n};  \nconst metadata = CardanoWasm.encode_json_str_to_metadatum(JSON.stringify(obj), CardanoWasm.MetadataJsonSchema.NoConversions);  \nconst metadataString = CardanoWasm.decode_metadatum_to_json_str(metadata, CardanoWasm.MetadataJsonSchema.NoConversions);`\n\nTo support an extended set of metadata we also support 3 additional modes for JSON conversion following IOHK's [cardano-node JSON schemas](https://github.com/input-output-hk/cardano-node/blob/master/cardano-api/src/Cardano/Api/TxMetadata.hs).\n\nThe three modes are:\n\n`NoConversions`\n`BasicConversions`\n`DetailedSchema`\n\nDetails on the formats can be found in our library's metadata module or in the `cardano-node` file linked above. `DetailedSchema` is likely most useful if you need to parse any possible kind of metadata into JSON specifically, possibly to display or for debugging.\nFor most reasonable schemas `NoConversions` should suffice, or `BasicConversions` if byte/string keys and byte values are needed.\nIf you are in charge of your own schema and you do not need arbitrary keys, it is recommended not to use `DetailedSchema` as it is significantly more complicated to use.\n\n`cardano-node`\n`DetailedSchema`\n`NoConversions`\n`BasicConversions`\n`DetailedSchema`\n\nThe additions of `BasicConversions` are demonstrated below\n\n`BasicConversions`\n`{  \n \"0x8badf00d\": \"0xdeadbeef\",  \n \"9\": 5,  \n \"obj\": {  \n \"a\":[  \n {  \n \"5\": 2  \n },  \n {  \n }  \n ]  \n }  \n}`\n\nwhich creates a map with 3 elements:\n\nAll bytestrings must be prefixed with \"0x\" or they will be treated as regular strings.\nAll strings that parse as an integer such as \"125\" will be treated as a metadata integer.\n\nThe `DetailedSchema` is here:\n\n`DetailedSchema`\n`{\"map\":[  \n {  \n \"k\":{\"bytes\":\"8badf00d\"},  \n \"v\":{\"bytes\":\"deadbeef\"}  \n },  \n {  \n \"k\":{\"int\":9},  \n \"v\":{\"int\":5}  \n },  \n {  \n \"k\":{\"string\":\"obj\"},  \n \"v\":{\"map\":[  \n {  \n \"k\":{\"string\":\"a\"},  \n \"v\":{\"list\":[  \n {\"map\":[  \n {  \n \"k\":{\"int\":5},  \n \"v\":{\"int\":2}  \n }  \n ]},  \n {\"map\":[  \n ]}  \n ]}  \n }  \n ]}  \n }  \n]}`\n\nAll values are represented as an object with 1 field with the key tagging the type and the value being the value itself.\nThis is the exact same metadata as the `BasicConversions` example which should illustrate that it is much more verbose to use this format,\nbut it can represent every kind of metadata possible, including non-string/byte/int keys.\nDo note that byte strings do not start with \"0x\", unlike with `BasicConversions`.\n\n`BasicConversions`\n`BasicConversions`\n\nThis additional freedom in keys can be seen here:\n\n`{\"map\":[  \n {  \n \"k\":{\"list\":[  \n {\"map\": [  \n {  \n \"k\": {\"int\": 5},  \n \"v\": {\"int\": 7}  \n },  \n {  \n \"k\": {\"string\": \"hello\"},  \n \"v\": {\"string\": \"world\"}  \n }  \n ]},  \n {\"bytes\": \"ff00ff00\"}  \n ]},  \n \"v\":{\"int\":5}  \n }  \n]}`\n\nhas a 1-element map with a value of just 5, but with a very complicated key consisting of a list with 2 elements:\n\nMost reasonable metadata formats, however, likely do not use map/key/compound keys and thus this is more of a fringe use or when all possible metadata must be examined from JSON (almost) without exception.\nDue to library implementation details it can still fail to decode if there is a very negative number between `-2^64 + 1` and `-2^63`.\n\n`-2^64 + 1`\n`-2^63`\n\n## Using a CDDL Subset[​](#using-a-cddl-subset \"Direct link to Using a CDDL Subset\")\n\nUpsides:\n\nDownsides:\n\nFor static or relatively static types this is probably the best choice, especially if you care about structural validation or need the binary types or more complex keys.\n\nAs we saw in the other examples, most reasonable structures can be encoded using the standard metadata CDDL as it is almost a superset of JSON outside of true/false/null. Not only this, but if we represent a struct using an array in CDDL such as:\n\n`foo = [  \n receiver_id: text,  \n sender_id: text,  \n comment: text,  \n tags: [*int]  \n]`\n\nthere is space savings as the keys are not stored as it is represented as an ordered array of 4 elements instead of a direct map encoding of:\n\n`foo = {  \n receiver_id: text,  \n sender_id: text,  \n comment: text,  \n tags\": [*int]  \n}`\n\nwhich would serialize the keys as strings inside the resulting CBOR. Using these CDDL definitions for the example JSON structure we had results in sizes of 89 bytes for the array definition and 124 bytes for the map one. Using the JSON encoding would also result in a metadata size of 124 bytes. Maps however do have the advantage of easy optional fields and a more readable metadata for external users who don't have access to the CDDL as the field names will be stored directly.\n\nAfter you have created your CDDL definition, if you need to check that your CDDL conforms to the metadata CDDL we have a tool located in the `/tools/metadata-cddl-checker/` directory. Move to this directory and put your CDDL in a file called `input.cddl` there first, then run\n\n`/tools/metadata-cddl-checker/`\n`input.cddl`\n`cargo build  \ncargo run`\n\nOnce we have the CDDL file and it has passed metadata format validation we can use the [cddl-codegen](https://github.com/Emurgo/cddl-codegen) tool that we used to initially generate the serialization/deserialization/structural code for the core Shelley structures from the [shelley cddl spec](https://github.com/input-output-hk/cardano-ledger-specs/blob/master/shelley/chain-and-ledger/shelley-spec-ledger-test/cddl-files/shelley.cddl).\n\nAssuming we are in the `cddl-codegen` root directory and have created a `input.cddl` file in that directory containing the CDDL we wish to generate we can build and code-generate with\n\n`cddl-codegen`\n`input.cddl`\n`cargo build  \ncargo run`\n\nwhich should generate a wasm-convertible rust library for parsing our CDDL definition in the `/export/` directory.\nAfter this we need to generate a wasm package from the rust code by running the following (you can do `--target=browser` too)\n\n`/export/`\n`--target=browser`\n`cd export  \nwasm-pack build --target=nodejs  \nwasm-pack pack`\n\nwhich should give you the library as a package in the `/pkg/` directory.\n\n`/pkg/`\n\nOnce we have imported the library we can then use it as such:\n\n`const tags = OurMetadataLib.Ints.new();  \n// if we have smaller (32-bit signed) numbers we can construct easier  \ntags.add(OurMetadataLib.Int.new_i32(0));  \n// but for bigger (>= 2^32) numbers we must use BigNum and specify the sign ourselves  \ntags.add(OurMetadataLib.Int.new(CardanoWasm.Int.from_str(\"264\")));  \n// and for negative large (< -2^32) numbers (here we construct -1024)  \ntags.add(OurMetadataLib.Int.new_negative(CardanoWasm.Int.from_str(\"1024\")));  \ntags.add(OurMetadataLib.Int.new_i32(32));  \nconst map = OurMetadataLib.Foo.new(\"SJKdj34k3jjKFDKfjFUDfdjkfd\", \"jkfdsufjdk34h3Sdfjdhfduf873\", \"happy birthday\", tags)  \nlet metadata;  \ntry {  \n metadata = CardanoWasm.TransactionMetadata.from_bytes(map.to_bytes());  \n} catch (e) {  \n // this should never happen if OurMetadataLib was generated from compatible CDDL with the metadata definition  \n}`\n\nlikewise you can parse the metadata back very simply with:\n\n`let cddlMetadata;  \ntry {  \n cddlMetadata = OurMetadataLib.Foo.from_bytes(metadata.to_bytes());  \n} catch (e) {  \n // this should never happen if OurMetadataLib was generated from compatible CDDL with the metadata definition  \n}  \n// we can now directly access the fields with cddlMetadata.receiver_id(), etc`\n\nIf we take advantage of the additional primitives not defined in CDDL but defined for `cddl-codegen`, then we can specify precisions of `u32`, `u64`, `i64`, `i32` for specifying 32 or 64 bits instead of just a general purpose `uint`/`nint`/`int`.\nIf you know your metadata will always be within one of these ranges it can be much more convenient to work with, and if you have signed data this will also make it easier to work with instead of the `Int` class that CDDL `int` might generate, since that is either an up to 64-bit positive or an up to 64 negative numbers.\nThis is particularly useful here as lists of CDDL primitives can be exposed directly as `Vec<T>` to wasm from rust, but when we have `int` (converts to `Int` struct) or `uint` (converts to `BigNum` struct) a separate structure like that `Ints` one used above is used. Using the 32-bit versions allows direct js `number` conversions to/from wasm.\n\n`cddl-codegen`\n`u32`\n`u64`\n`i64`\n`i32`\n`uint`\n`nint`\n`int`\n`Int`\n`int`\n`Vec<T>`\n`int`\n`Int`\n`uint`\n`BigNum`\n`Ints`\n`number`\n\nIf we simply change the `tags` field to `tags: [+i32]` our code becomes:\n\n`tags`\n`tags: [+i32]`\n`// notice how we can directly work with js numbers here now!  \n// but remember they must fit into a 32-bit number now - no 64-bit numbers like are allowed in the metadata  \nconst tags = [0, 264, -1024, 32];  \nconst map = OurMetadataLib.Foo.new(\"SJKdj34k3jjKFDKfjFUDfdjkfd\", \"jkfdsufjdk34h3Sdfjdhfduf873\", \"happy birthday\", tags)`\n\nand deserializaing likewise is much simpler as `metadata.tags()` will return a JS array or numbers rather than a rust-wasm struct that must be accessed via the wasm boundary.\n\n`metadata.tags()`\n\n## Raw Bytes Encoding[​](#raw-bytes-encoding \"Direct link to Raw Bytes Encoding\")\n\nUpsides:\n\nDownsides:\n\nWhile most data would likely conform to the metadata CDDL subset (or JSON), if your data does not fit there then this encoding style will be necessary.\n\nIf you still want to take advantage of CDDL type-checking it is possible to create a library just as in the CDDL subset section but without running the checker tool. This could be useful if you are using CDDL outside of the metadata CDDL structure. Otherwise, you can store whatever bytes you want.\n\n*Note*: To conform with the 64-byte limitation on metadata binary values, this method will split the bytes into 64-byte chunks\n\n`const bytes = /* whatever method you want - you can use the CDDL solution in the 3rd option here */  \nconst metadata = CardanoWasm.encode_arbitrary_bytes_as_metadatum(bytes);  \nconst decoded_bytes = CardanoWasm.decode_arbitrary_bytes_from_metadatum(metadata);  \nassertEquals(bytes, decoded_bytes);`\n\n## Serialization-Lib Information[​](#serialization-lib-information \"Direct link to Serialization-Lib Information\")\n\nThis page was generated automatically from: [https://github.com/Emurgo/cardano-serialization-lib](https://github.com/Emurgo/cardano-serialization-lib/tree/master/doc/getting-started/metadata.md).",
  "images": [],
  "extraction_metadata": {
    "batch_number": 4,
    "extraction_timestamp": "2025-09-19T14:04:34.999822",
    "extraction_time": 3.8223392963409424,
    "source": "tavily_api_raw"
  }
}