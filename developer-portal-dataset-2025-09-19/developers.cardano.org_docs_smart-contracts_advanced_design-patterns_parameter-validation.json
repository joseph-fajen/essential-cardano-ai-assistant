{
  "url": "https://developers.cardano.org/docs/smart-contracts/advanced/design-patterns/parameter-validation",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Onchain Parameter Application\n\n## Introduction[​](#introduction \"Direct link to Introduction\")\n\nWhen writing onchain code you might encounter a situation where you want to be able to check that a script hash is an instantiation of a unparameterised script.\nIt is common for smart contracts to accept parameters (e.g. fees, references to other scripts, magical numbers). Perhaps the most well known example of such a script is the\none-shot minting policy script, that enforces that the minting policy can only ever succeed once (ie. for NFTs, or fixed-supply fungible tokens).\n\n`-- Check that a specific UTxO was spent in the transaction.  \noneShotValidate :: TxOutRef -> ScriptContext -> ()  \noneShotValidate oref ctx = any (\\input -> txInInfoOutRef input == oref) inputs   \n where  \n txInfo = scriptContextTxInfo ctx  \n inputs = txInfoInputs txInfo`\n\nTo determine that a `CurrencySymbol`, for instance `scriptHashToCheck`, is derived from the result of applying a given `TxOutRef` to the `oneShotValidate` script (and thus must be a fixed-supply token):\n\n`CurrencySymbol`\n`scriptHashToCheck`\n`TxOutRef`\n`oneShotValidate`\n`let plutusVersion = 3  \n versionHeader = integerToByteString True 1 plutusVersion  \n scriptHeader = versionHeader <> prefix <> param  \n final_res = scriptHeader <> postfix  \nin hash final_res == scriptHashToCheck`\n\nWhere `param` is `serialiseData TX_OUT_REF_PARAM`, `prefix` is the cbor script bytes of `oneShotValidator` before the argument, and `postfix` is the cbor script bytes of the `oneShotValidator` after the argument.\n\n`param`\n`serialiseData TX_OUT_REF_PARAM`\n`prefix`\n`oneShotValidator`\n`postfix`\n`oneShotValidator`\n\nParameterized scripts used in this design pattern should have the form:\n\n`[ (lam x …) PARAMHERE]`\n\nSo that if the param is used multiple times it doesn't need to be spliced in everywhere.\n\nGiven a plutus script that accepts parameters (in the above example, a `TxOutRef`), with this design pattern you can verify onchain that a given script hash is an instance of that script with a specific parameter applied.\n\n`TxOutRef`\n\n## Examples and Implementation[​](#examples-and-implementation \"Direct link to Examples and Implementation\")\n\nWe maintain a standard library that provides a high-level abstraction for onchain parameter validation and many other design patterns. You can explore the implementation of this design pattern in our [aiken-design-patterns](https://github.com/Anastasia-Labs/aiken-design-patterns/blob/develop/lib/aiken-design-patterns/parameter-validation.ak) repository.\n\n## Considerations[​](#considerations \"Direct link to Considerations\")\n\nThis design pattern only works under the assumption that the parameter is constant size (this holds true for `TxOutRef`). If a script accepts parameters with dynamic size (ie. arbitrary size integer / bytestring) then to use it with this\ndesign pattern you should modify the parameter to be the hash of the original parameter, and then allow the pre-image to be provided in the tx and verify that it matches the hash.\n\n`TxOutRef`\n\nIf you found this design pattern useful, please consider supporting the [builtinApplyParams CIP](https://github.com/cardano-foundation/CIPs/pull/934) which proposes the introduction of a new builtin that would make this pattern much more accessible and robust.",
  "images": [],
  "extraction_metadata": {
    "batch_number": 10,
    "extraction_timestamp": "2025-09-19T14:05:05.551444",
    "extraction_time": 2.0458879470825195,
    "source": "tavily_api_raw"
  }
}