{
  "url": "https://developers.cardano.org/docs/smart-contracts/smart-contract-languages/aiken/advanced-data-structures/merkle-tree",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Merkle Tree\n\n## Introduction[​](#introduction \"Direct link to Introduction\")\n\nThe Aiken Merkle Tree project provides a Plutarch-based implementation of Merkle Trees for the Cardano blockchain. This project allows developers to leverage the security and efficiency of Merkle Trees in their Cardano smart contracts, ensuring data integrity and efficient data verification.\n\nThe github repository introducing these data structures can be found [here](https://github.com/Anastasia-Labs/aiken-merkle-tree).\n\n## Documentation[​](#documentation \"Direct link to Documentation\")\n\n### Merkle Tree[​](#merkle-tree \"Direct link to Merkle Tree\")\n\nA Merkle tree, named after its inventor Ralph Merkle, is a fundamental data structure in computer science and cryptography. It's particularly well-suited for managing and verifying large data structures, especially in distributed systems like blockchain technologies. Here's a detailed explanation:\n\n#### Basic concept[​](#basic-concept \"Direct link to Basic concept\")\n\nA Merkle tree is a type of binary tree, consisting of nodes. Here's how it's structured:\n\n#### Hash function[​](#hash-function \"Direct link to Hash function\")\n\nThe core of a Merkle tree is the hash function (like SHA-256 in Bitcoin). This function takes digital data of any size and produces a fixed-size string of bytes, typically a unique digital fingerprint of the input data.\n\n#### Construction[​](#construction \"Direct link to Construction\")\n\n#### Features[​](#features \"Direct link to Features\")\n\n#### Example[​](#example \"Direct link to Example\")\n\nConsider a Merkle tree with four leaf nodes (A, B, C, D).\n\n `Merkle Root  \n |  \n +-----------+-----------+  \n | |  \n Hash(A+B) Hash(C+D)  \n | |  \n +---+---+ +---+---+  \n | | | |  \n Hash(A) Hash(B) Hash(C) Hash(D)`\n\nThus, the Merkle root is a digest of all the data in the leaf nodes.\n\nIn conclusion, Merkle trees offer a secure and efficient way to summarize and verify large data sets.\n\n### Aiken Merkle Tree implementation[​](#aiken-merkle-tree-implementation \"Direct link to Aiken Merkle Tree implementation\")\n\nThe Aiken Merkle Tree implementation provides several functions to create and manipulate Merkle Trees. Below is a brief overview of each function:\n\n-`from_list`: Constructs a Merkle Tree from a list of serialized data.\n\n`from_list`\n\n-`to_list`: Deconstructs a Merkle Tree back into a list of elements.\n\n`to_list`\n\n-`root`: Retrieves the root hash of a Merkle Tree.\n\n`root`\n\n-`is_empty`: Checks if a Merkle Tree is empty.\n\n`is_empty`\n\n-`size`: Returns the number of leaf nodes in a Merkle Tree.\n\n`size`\n\n-`get_proof`: Generates a proof of membership for an element in the Merkle Tree.\n\n`get_proof`\n\n-`is_member`: Verifies if an element is part of a Merkle Tree using a proof.\n\n`is_member`\n\n-`combine`: Combines two hashes into a new one.\n\n`combine`\n\n## Validator Logic[​](#validator-logic \"Direct link to Validator Logic\")\n\n`// /**  \n// * This file contains the implementation of a spend_validator function that validates a spend transaction  \n// * using a Merkle tree. It also includes a test case for the spend_validator function.  \n// */  \n  \nuse aiken/transaction.{OutputReference, ScriptContext, Spend, TransactionId}  \nuse aiken_merkle_tree/mt.{Proof, Root, from_list, get_proof, is_member, root}  \n  \ntype MyDatum {  \n merkle_root: Root,  \n}  \n  \ntype MyRedeemer {  \n my_proof: Proof<ByteArray>,  \n user_data: ByteArray,  \n}  \n  \n// /**  \n// * The spend_validator function validates a spend transaction by checking if the user data is a member of  \n// * the Merkle tree with the given Merkle root and proof.  \n// *  \n// * @param datum - The MyDatum object containing the Merkle root.  \n// * @param redeemer - The MyRedeemer object containing the proof and user data.  \n// * @param _ctx - The ScriptContext.  \n// */  \nvalidator {  \n fn spend_validator(datum: MyDatum, redeemer: MyRedeemer, _ctx: ScriptContext) {  \n let MyDatum { merkle_root } = datum  \n let MyRedeemer { my_proof, user_data } = redeemer  \n is_member(merkle_root, user_data, my_proof, identity)  \n }  \n}  \n  \n// /**  \n// * Test case for the spend_validator function.  \n// */  \ntest spend_validator_1() {  \n let data =  \n [\"dog\", \"cat\", \"mouse\"]  \n let merkle_tree = from_list(data, identity)  \n let datum = MyDatum { merkle_root: root(merkle_tree) }  \n expect Some(proof) = get_proof(merkle_tree, \"cat\", identity)  \n let redeemer = MyRedeemer { my_proof: proof, user_data: \"cat\" }  \n let placeholder_utxo =  \n OutputReference { transaction_id: TransactionId(\"\"), output_index: 0 }  \n let context =  \n ScriptContext {  \n purpose: Spend(placeholder_utxo),  \n transaction: transaction.placeholder(),  \n }  \n spend_validator(datum, redeemer, context)  \n}`\n\n### Library[​](#library \"Direct link to Library\")\n\n`// This code is sourced from https://github.com/aiken-lang/trees/blob/main/lib/aiken/trees/mt.ak  \n//  \n// A purely functional implementation of MerkleTrees that is suitable for  \n// usage on-chain. Note, however, that the construction of 'MerkleTree' and  \n// membership proofs are still expected to happen *off-chain* while only the  \n// proof verification should be done on-chain.  \n//  \n// This implementation uses exclusively SHA-256 as a hashing algorithm.  \n//  \n// The code ported to Aiken from [Hydra](https://github.com/input-output-hk/hydra/blob/master/plutus-merkle-tree/src/Plutus/MerkleTree.hs)  \n  \nuse aiken/bytearray  \nuse aiken/hash.{Hash, Sha2_256, sha2_256}  \nuse aiken/list  \nuse aiken/option.{choice, is_none}  \n  \n/// An opaque representation of a [MerkleTree](#MerkleTree). See  \n/// [from_list](#from_list) to construct a tree from a list of elements.  \npub opaque type MerkleTree<a> {  \n Empty  \n Leaf { value: a, hash: Hash<Sha2_256, a> }  \n Node { root: Root, left: MerkleTree<a>, right: MerkleTree<a> }  \n}  \n  \n/// A proof of existence in the tree. See:  \n///  \n/// - [`get_proof`](#get_proof) to construct a proof from a given element.  \n/// - [`is_member`](#is_member) to verify a given proof against a known root.  \n///  \npub type Proof<a> =  \n List<ProofItem<a>>  \n  \n/// An opaque proof element.  \npub opaque type ProofItem<a> {  \n Left(Root)  \n Right(Root)  \n}  \n  \n/// An opaque root. Use [to_hash](#to_hash) and  \n/// [from_hash](#from_hash) to convert back-and-forth between this and  \n/// classic hashes. This type exists mainly to disambiguate between standard  \n/// value (leaf) hash from tree hashes.  \npub opaque type Root {  \n inner: ByteArray,  \n}  \n  \n/// Convert a [Root](#Root) into a simple [Hash](https://aiken-lang.github.io/stdlib/aiken/hash.html#Hash), when possible.  \n///  \n/// Roots from empty trees have no hash whatsoever.  \npub fn to_hash(self: Root) -> Option<Hash<Sha2_256, a>> {  \n if self.inner == \"\" {  \n None  \n } else {  \n Some(self.inner)  \n }  \n}  \n  \n/// Convert any [Hash](https://aiken-lang.github.io/stdlib/aiken/hash.html#Hash) into a merkle [Root](#Root).  \n///  \n/// This operation is _unsafe_ unless you are sure that the given hash digest was produced from a valid merkle tree.  \npub fn from_hash(hash: Hash<alg, a>) -> Root {  \n Root(hash)  \n}  \n  \n/// Deconstruct a [MerkleTree](#MerkleTree) back to a list of elements.  \npub fn to_list(self: MerkleTree<a>) -> List<a> {  \n when self is {  \n Empty ->  \n []  \n Leaf { value, .. } ->  \n [value]  \n Node { left, right, .. } -> list.concat(to_list(left), to_list(right))  \n }  \n}  \n  \ntest to_list_1() {  \n let items =  \n []  \n to_list(from_list(items, identity)) == items  \n}  \n  \ntest to_list_2() {  \n let items =  \n [\"dog\"]  \n to_list(from_list(items, identity)) == items  \n}  \n  \ntest to_list_3() {  \n let items =  \n [\"dog\", \"cat\", \"mouse\"]  \n to_list(from_list(items, identity)) == items  \n}  \n  \n/// Returns the [Root](#Root) of a given [MerkleTree](#MerkleTree).  \npub fn root(self: MerkleTree<a>) -> Root {  \n when self is {  \n Empty -> Root(\"\")  \n Leaf { hash, .. } -> Root(hash)  \n Node { root, .. } -> root  \n }  \n}  \n  \ntest root_1() {  \n from_list([], identity)  \n |> root  \n |> to_hash  \n |> is_none  \n}  \n  \ntest root_2() {  \n let dog = \"dog\"  \n let mt = from_list([dog], identity)  \n root(mt) == from_hash(sha2_256(dog))  \n}  \n  \ntest root_3() {  \n let dog = \"dog\"  \n let cat = \"cat\"  \n let mouse = \"mouse\"  \n  \n let hash =  \n \"mouse\"  \n |> sha2_256  \n |> bytearray.concat(sha2_256(cat), _)  \n |> sha2_256  \n |> bytearray.concat(sha2_256(dog), _)  \n |> sha2_256  \n  \n to_hash(root(from_list([dog, cat, mouse], identity))) == Some(hash)  \n}  \n  \n/// Cheap equality of two [MerkleTrees](#MerkleTree) by comparing their root  \n/// hashes. For large trees, this is much faster than using `==`.  \npub fn equals(left: MerkleTree<a>, right: MerkleTree<a>) -> Bool {  \n root(left) == root(right)  \n}  \n  \n/// Returns a total numbers of elements in the tree.  \npub fn size(self: MerkleTree<a>) -> Int {  \n when self is {  \n Empty -> 0  \n Leaf { .. } -> 1  \n Node { left, right, .. } -> size(left) + size(right)  \n }  \n}  \n  \ntest size_1() {  \n let items =  \n []  \n size(from_list(items, identity)) == 0  \n}  \n  \ntest size_2() {  \n let items =  \n [\"dog\"]  \n size(from_list(items, identity)) == 1  \n}  \n  \ntest size_3() {  \n let items =  \n [\"dog\", \"cat\", \"mouse\"]  \n size(from_list(items, identity)) == 3  \n}  \n  \n/// Returns `True` when the tree has no elements. False otherwise.  \npub fn is_empty(self: MerkleTree<a>) -> Bool {  \n when self is {  \n Empty -> True  \n _ -> False  \n }  \n}  \n  \ntest is_empty_1() {  \n is_empty(from_list([], identity))  \n}  \n  \ntest is_empty_2() {  \n !is_empty(from_list([\"dog\"], identity))  \n}  \n  \n/// Construct a membership [Proof](#Proof) from an element and a [MerkleTree](#MerkleTree).  \n///  \n/// Returns 'None' when the element isn't a member of the tree to begin with.  \n///  \n/// Note that the proof is empty (i.e. []) for trees that have a single element.  \npub fn get_proof(  \n self: MerkleTree<a>,  \n item: a,  \n serialise: fn(a) -> ByteArray,  \n) -> Option<Proof<a>> {  \n do_get_proof(self, sha2_256(serialise(item)), [])  \n}  \n  \nfn do_get_proof(  \n self: MerkleTree<a>,  \n item_hash: Hash<Sha2_256, a>,  \n proof: Proof<a>,  \n) -> Option<Proof<a>> {  \n when self is {  \n Empty -> None  \n Leaf { hash, .. } ->  \n if hash == item_hash {  \n Some(proof)  \n } else {  \n None  \n }  \n Node { left, right, .. } -> {  \n let try_left =  \n do_get_proof(left, item_hash, [Right(root(right)), ..proof])  \n let try_right =  \n do_get_proof(right, item_hash, [Left(root(left)), ..proof])  \n choice([try_left, try_right])  \n }  \n }  \n}  \n  \ntest get_proof_1() {  \n from_list([], identity)  \n |> get_proof(\"dog\", identity)  \n |> is_none  \n}  \n  \ntest get_proof_2() {  \n from_list([\"dog\", \"cat\", \"mouse\", \"horse\", \"pig\", \"bull\"], identity)  \n |> get_proof(\"parrot\", identity)  \n |> is_none  \n}  \n  \ntest get_proof_3() {  \n let mt = from_list([\"dog\"], identity)  \n expect Some(proof) = get_proof(mt, \"dog\", identity)  \n proof == [] && is_member(root(mt), \"dog\", proof, identity)  \n}  \n  \nfn do_from_list(  \n items: List<a>,  \n len: Int,  \n serialise: fn(a) -> ByteArray,  \n) -> MerkleTree<a> {  \n when items is {  \n [] -> Empty  \n [value] -> Leaf { value, hash: sha2_256(serialise(value)) }  \n _ -> {  \n let cutoff: Int = len / 2  \n let left =  \n items  \n |> list.take(cutoff)  \n |> do_from_list(cutoff, serialise)  \n let right =  \n items  \n |> list.drop(cutoff)  \n |> do_from_list(len - cutoff, serialise)  \n let root = combine(root(left), root(right))  \n Node { root, left, right }  \n }  \n }  \n}  \n  \n/// Construct a 'MerkleTree' from a list of values.  \n///  \n/// Note that, while this operation is doable on-chain, it is expensive and  \n/// preferably done off-chain.  \npub fn from_list(items: List<a>, serialise: fn(a) -> ByteArray) -> MerkleTree<a> {  \n do_from_list(items, list.length(items), serialise)  \n}  \n  \ntest from_list_1() {  \n from_list([], identity) == Empty  \n}  \n  \ntest from_list_2() {  \n let dog = \"dog\"  \n from_list([dog], identity) == Leaf { value: dog, hash: sha2_256(dog) }  \n}  \n  \ntest from_3() {  \n let dog = \"dog\"  \n let cat = \"cat\"  \n  \n from_list([dog, cat], identity) == Node {  \n root: combine(Root(sha2_256(dog)), Root(sha2_256(cat))),  \n left: Leaf { value: dog, hash: sha2_256(dog) },  \n right: Leaf { value: cat, hash: sha2_256(cat) },  \n }  \n}  \n  \ntest from_list_4() {  \n let dog = \"dog\"  \n let cat = \"cat\"  \n let mouse = \"mouse\"  \n  \n let root_hash =  \n sha2_256(mouse)  \n |> bytearray.concat(sha2_256(cat), _)  \n |> sha2_256  \n |> bytearray.concat(sha2_256(dog), _)  \n |> sha2_256  \n  \n root(from_list([dog, cat, mouse], identity)) == from_hash(root_hash)  \n}  \n  \n/// Check whether an element is part of a [MerkleTree](#MerkleTree) using only  \n/// its [root_hash](#root_hash) and a [Proof](#Proof).  \n///  \n/// The proof (and verification) is guaranteed to be in log(n) of the size of  \n/// the tree, which is / why such data-structures are interesting.  \npub fn is_member(  \n root: Root,  \n item: a,  \n proof: Proof<a>,  \n serialise: fn(a) -> ByteArray,  \n) -> Bool {  \n verify_proof(root, sha2_256(serialise(item)), proof)  \n}  \n  \n/// An alternative version of [is_member](#is_member) where the element to  \n/// check is directly provided as hash. This assumes the hash preimage was  \n/// produced using same serialization method as for constructing the tree.  \n///  \n/// Returns `True` when the `Proof` is valid for the provided element hash  \n/// digest and tree root. Said differently, returns `True` when the  \n/// original element is indeed part of the tree. Returns `False` otherwise.  \npub fn verify_proof(  \n root: Root,  \n item_hash: Hash<Sha2_256, a>,  \n proof: Proof<a>,  \n) -> Bool {  \n when proof is {  \n [] -> root == Root(item_hash)  \n [head, ..tail] ->  \n when head is {  \n Left(left) ->  \n verify_proof(root, combine(left, Root(item_hash)).inner, tail)  \n Right(right) ->  \n verify_proof(root, combine(Root(item_hash), right).inner, tail)  \n }  \n }  \n}  \n  \ntest get_proof_is_member_1() {  \n let dog = \"dog\"  \n let cat = \"cat\"  \n let mouse = \"mouse\"  \n let mt = from_list([dog, cat, mouse], identity)  \n  \n expect Some(dog_proof) = get_proof(mt, dog, identity)  \n expect Some(cat_proof) = get_proof(mt, cat, identity)  \n expect Some(mouse_proof) = get_proof(mt, mouse, identity)  \n  \n let all_members =  \n is_member(root(mt), dog, dog_proof, identity)? && is_member(  \n root(mt),  \n cat,  \n cat_proof,  \n identity,  \n )? && is_member(root(mt), mouse, mouse_proof, identity)?  \n  \n let check_sizes =  \n (list.length(dog_proof) == 1)? && (list.length(cat_proof) == 2)? && (list.length(  \n mouse_proof,  \n ) == 2)?  \n  \n all_members? && check_sizes?  \n}  \n  \ntest get_proof_is_member_2() {  \n let dog = \"dog\"  \n let cat = \"cat\"  \n let mouse = \"mouse\"  \n let mt = from_list([dog, cat, mouse], identity)  \n  \n expect Some(dog_proof) = get_proof(mt, dog, identity)  \n  \n !is_member(root(mt), cat, dog_proof, identity)  \n}  \n  \n// ----- Internal  \n  \nfn combine(left: Root, right: Root) -> Root {  \n bytearray.concat(left.inner, right.inner)  \n |> sha2_256  \n |> Root  \n}`\n\n## Case study[​](#case-study \"Direct link to Case study\")\n\nFor an in-depth real-world case study on the application of Merkle Trees within the Cardano blockchain environment, particularly in the context of sidechain to main chain token transfers, refer to the following resource:\n\n[Cardano Sidechain Toolkit - Main Chain Plutus Scripts](https://docs.cardano.org/cardano-sidechains/sidechain-toolkit/mainchain-plutus-scripts/)\n\nThis case study provides valuable insights into how Merkle Trees are integrated into blockchain transactions, offering practical examples and detailed workflows.\n\n## Acknowledgments[​](#acknowledgments \"Direct link to Acknowledgments\")\n\nThis library takes the Aiken code from the aiken-lang.\n\nThe repository can be found at <https://github.com/aiken-lang/trees>",
  "images": [],
  "extraction_metadata": {
    "batch_number": 11,
    "extraction_timestamp": "2025-09-19T14:05:12.534540",
    "extraction_time": 3.978458881378174,
    "source": "tavily_api_raw"
  }
}