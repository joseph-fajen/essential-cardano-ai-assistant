{
  "url": "https://developers.cardano.org/docs/smart-contracts/lessons/04-contract-testing",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Contract Testing\n\nTesting Aiken contracts is crucial to ensure they behave as expected. In this lesson, we will cover:\n\n## Preparing a Complex Contract[​](#preparing-a-complex-contract \"Direct link to Preparing a Complex Contract\")\n\nWe will enhance the withdrawal contract from the previous lesson to include two user actions: `ContinueCounting` or `StopCounting`.\n\n`ContinueCounting`\n`StopCounting`\n\n**ContinueCounting**:\n\n**StopCounting**:\n\n### Contract Code[​](#contract-code \"Direct link to Contract Code\")\n\n`use aiken/crypto.{VerificationKeyHash}  \nuse cardano/address.{Address, Credential}  \nuse cardano/assets.{PolicyId}  \nuse cardano/certificate.{Certificate}  \nuse cardano/transaction.{Transaction}  \nuse cocktail.{input_inline_datum, inputs_with_policy, key_signed, valid_before}  \n  \npub type OracleDatum {  \n app_owner: VerificationKeyHash,  \n app_expiry: Int,  \n spending_validator_address: Address,  \n state_thread_token_policy_id: PolicyId,  \n}  \n  \npub type MyRedeemer {  \n ContinueCounting  \n StopCounting  \n}  \n  \nvalidator complex_withdrawal_contract(oracle_nft: PolicyId) {  \n withdraw(redeemer: MyRedeemer, _credential: Credential, tx: Transaction) {  \n let Transaction {  \n reference_inputs,  \n mint,  \n extra_signatories,  \n validity_range,  \n ..  \n } = tx  \n  \n expect [oracle_ref_input] = inputs_with_policy(reference_inputs, oracle_nft)  \n expect OracleDatum {  \n app_owner,  \n app_expiry,  \n ..  \n } = input_inline_datum(oracle_ref_input)  \n  \n let is_app_owner_signed = key_signed(extra_signatories, app_owner)  \n  \n when redeemer is {  \n ContinueCounting -> {  \n let is_app_not_expired = valid_before(validity_range, app_expiry)  \n let is_nothing_minted = mint == assets.zero  \n  \n is_app_owner_signed? && is_app_not_expired? && is_nothing_minted?  \n }  \n StopCounting -> todo  \n }  \n }  \n  \n publish(_redeemer: Data, _credential: Certificate, _tx: Transaction) {  \n True  \n }  \n  \n else(_) {  \n fail @\"unsupported purpose\"  \n }  \n}`\n\nIn this setup, we define 2 potential user action with `MyRedeemer`, either to `ContinueCounting` or `StopCounting`. We built the partial logics for `ContinueCounting` action, which we put all the logics we have learnt from lesson 3.\n\n`MyRedeemer`\n`ContinueCounting`\n`StopCounting`\n`ContinueCounting`\n\n### `expect`[​](#expect \"Direct link to expect\")\n\n`expect`\n\nNotice we touch on the syntax of `expect` the first time here. `expect` is used to enforce the exact pattern for a variable. In above example, `inputs_with_policy(reference_inputs, oracle_nft)` returns `List<Input>`. However, since in this application we are confident that there is always one item in the list, perhaps since `oracle_nft` is unique, it is impossible to obtain two inputs with `oracle_nft` in value. So that we can use `expect` here.\n\n`expect`\n`expect`\n`inputs_with_policy(reference_inputs, oracle_nft)`\n`List<Input>`\n`oracle_nft`\n`oracle_nft`\n`expect`\n\n### `?` operator[​](#-operator \"Direct link to -operator\")\n\n`?`\n\nIn the last line of `ContinueCounting` branch, you may notice the use of `?` operator. This operator is a tracing operator that helps to trace which condition fails when the validator fails. For example, if `is_app_owner_signed` is false, then the validator will fail with message `is_app_owner_signed?` which helps to identify the root cause of failure.\n\n`ContinueCounting`\n`?`\n`is_app_owner_signed`\n`is_app_owner_signed?`\n\n## Validating Input & Output[​](#validating-input--output \"Direct link to Validating Input & Output\")\n\nWe complete the contract by validating inputs and outputs:\n\n`use aiken/crypto.{VerificationKeyHash}  \nuse cardano/address.{Address, Credential}  \nuse cardano/assets.{PolicyId, without_lovelace}  \nuse cardano/certificate.{Certificate}  \nuse cardano/transaction.{Transaction}  \nuse cocktail.{  \n input_inline_datum, inputs_at_with_policy, inputs_with_policy, key_signed,  \n output_inline_datum, outputs_at_with_policy, valid_before,  \n}  \n  \npub type OracleDatum {  \n app_owner: VerificationKeyHash,  \n app_expiry: Int,  \n spending_validator_address: Address,  \n state_thread_token_policy_id: PolicyId,  \n}  \n  \npub type SpendingValidatorDatum {  \n count: Int,  \n}  \n  \npub type MyRedeemer {  \n ContinueCounting  \n StopCounting  \n}  \n  \nvalidator complex_withdrawal_contract(oracle_nft: PolicyId) {  \n withdraw(redeemer: MyRedeemer, _credential: Credential, tx: Transaction) {  \n let Transaction {  \n reference_inputs,  \n inputs,  \n outputs,  \n mint,  \n extra_signatories,  \n validity_range,  \n ..  \n } = tx  \n  \n expect [oracle_ref_input] = inputs_with_policy(reference_inputs, oracle_nft)  \n expect OracleDatum {  \n app_owner,  \n app_expiry,  \n spending_validator_address,  \n state_thread_token_policy_id,  \n } = input_inline_datum(oracle_ref_input)  \n  \n expect [state_thread_input] =  \n inputs_at_with_policy(  \n inputs,  \n spending_validator_address,  \n state_thread_token_policy_id,  \n )  \n  \n let is_app_owner_signed = key_signed(extra_signatories, app_owner)  \n  \n when redeemer is {  \n ContinueCounting -> {  \n expect [state_thread_output] =  \n outputs_at_with_policy(  \n outputs,  \n spending_validator_address,  \n state_thread_token_policy_id,  \n )  \n expect input_datum: SpendingValidatorDatum =  \n input_inline_datum(state_thread_input)  \n expect output_datum: SpendingValidatorDatum =  \n output_inline_datum(state_thread_output)  \n  \n let is_app_not_expired = valid_before(validity_range, app_expiry)  \n let is_count_added = input_datum.count + 1 == output_datum.count  \n let is_nothing_minted = mint == assets.zero  \n  \n is_app_owner_signed? && is_app_not_expired? && is_count_added && is_nothing_minted?  \n }  \n StopCounting -> {  \n let state_thread_value =  \n state_thread_input.output.value |> without_lovelace()  \n let is_thread_token_burned = mint == assets.negate(state_thread_value)  \n is_app_owner_signed? && is_thread_token_burned?  \n }  \n }  \n }  \n  \n publish(_redeemer: Data, _credential: Certificate, _tx: Transaction) {  \n True  \n }  \n  \n else(_) {  \n fail @\"unsupported purpose\"  \n }  \n}`\n\nWe have used some new techniques here. We have extracted the inline datum of the state thread token input and output using `input_inline_datum` and `output_inline_datum`. We have also used `inputs_at_with_policy` and `outputs_at_with_policy` to filter the inputs and outputs at a specific address with a specific policy ID. With that, we can compare the datum of input and output to ensure the count is incremented by 1.\n\n`input_inline_datum`\n`output_inline_datum`\n`inputs_at_with_policy`\n`outputs_at_with_policy`\n\nIn `StopCounting` case, we ensure the state thread token is burned by checking the `mint` field of the transaction. We use `without_lovelace` to ignore the lovelace part of the value when comparing.\n\n`StopCounting`\n`mint`\n`without_lovelace`\n\n## Build mock transaction in Aiken[​](#build-mock-transaction-in-aiken \"Direct link to Build mock transaction in Aiken\")\n\nAll Aiken contracts can be interpreted as simple functions, which takes in a few parameters and returns a boolean value. This makes it easy to test the contract by providing mock data.\n\nIn Aiken, we can build testing functions with `test` keyword, followed by running `aiken check` in project root to execute the tests.\n\n`test`\n`aiken check`\n\nThe vanilla example:\n\n`test always_true() {  \n True  \n}`\n\nWith `aiken check`, we will see:\n\n`aiken check`\n\n![Dummy Test](/assets/images/04-contract-testing-1-a15710f44e3ef378c21e80845bff9389.png)\n\n![Dummy Test](/assets/images/04-contract-testing-1-a15710f44e3ef378c21e80845bff9389.png)\n\n### Testing always succeed and always fail cases[​](#testing-always-succeed-and-always-fail-cases \"Direct link to Testing always succeed and always fail cases\")\n\nIn our complex withdrawal contract, we have a `publish` function that always returns `True`. We can write a test for it:\n\n`publish`\n`True`\n`use mocktail.{complete, mock_utxo_ref, mocktail_tx}  \n  \ntest test_publish() {  \n let data = Void  \n complex_withdrawal_contract.publish(  \n \"\",  \n data,  \n RegisterCredential(Script(#\"\"), Never),  \n mocktail_tx() |> complete(),  \n )  \n}`\n\nIn this test, we call the `publish` function of our contract with mock parameters. We use `mocktail_tx()` to create a mock transaction and `complete()` to provide an empty `Transaction`.\n\n`publish`\n`mocktail_tx()`\n`complete()`\n`Transaction`\n\nFor the rest of script purposes, it will fallback to the `else` branch which always fails. We can write a test for it:\n\n`else`\n`test test_else() fail {  \n complex_withdrawal_contract.else(  \n \"\",  \n ScriptContext(  \n mocktail_tx() |> complete(),  \n Void,  \n Spending(mock_utxo_ref(0, 0), None),  \n ),  \n )  \n}`\n\nNote that the test is not returning a `False`, but the programme breaks with `fail`. We can indicate that the test is expected to fail by adding `fail` after the test name.\n\n`False`\n`fail`\n`fail`\n\nRunning `aiken check` will show:\n\n`aiken check`\n\n![Always Succeed and Always Fail Test](/assets/images/04-contract-testing-2-25f00a2298518ff52b366ec1852587ba.png)\n\n![Always Succeed and Always Fail Test](/assets/images/04-contract-testing-2-25f00a2298518ff52b366ec1852587ba.png)\n\n### Testing `withdraw` function[​](#testing-withdraw-function \"Direct link to testing-withdraw-function\")\n\n`withdraw`\n\nYou will notice the `withdraw` function is validated the `Transaction` mostly, therefore, we should craft the `Transaction` carefully. However, crafting it with mock data is a bit tricky especially when we have to deal with all the Aiken types. `vodka` library comes to rescue.\n\n`withdraw`\n`Transaction`\n`Transaction`\n`vodka`\n\nIn `vodka`, the `mocktail` module provides a set of functions to create mock data for testing Aiken contracts. We can use `mocktail_tx()` to create a mock `Transaction` and then use various functions to modify the transaction to fit our test case.\n\n`vodka`\n`mocktail`\n`mocktail_tx()`\n`Transaction`\n`const mock_oracle_nft = mock_policy_id(0)  \n  \nconst mock_oracle_address = mock_script_address(0, None)  \n  \nconst mock_oracle_value =  \n assets.from_asset(mock_oracle_nft, \"\", 1) |> assets.add(\"\", \"\", 2_000_000)  \n  \nconst mock_app_owner = mock_pub_key_hash(0)  \n  \nconst mock_spending_validator_address = mock_script_address(1, None)  \n  \nconst mock_state_thread_token_policy_id = mock_policy_id(1)  \n  \nconst mock_state_thread_value =  \n assets.from_asset(mock_state_thread_token_policy_id, \"\", 1)  \n |> assets.add(\"\", \"\", 2_000_000)  \n  \nconst mock_oracle_datum =  \n OracleDatum {  \n app_owner: mock_app_owner,  \n app_expiry: 1000,  \n spending_validator_address: mock_spending_validator_address,  \n state_thread_token_policy_id: mock_state_thread_token_policy_id,  \n }  \n  \nfn mock_datum(count: Int) -> SpendingValidatorDatum {  \n SpendingValidatorDatum { count }  \n}  \n  \nfn mock_continue_counting_tx() -> Transaction {  \n mocktail_tx()  \n |> ref_tx_in(  \n True,  \n mock_tx_hash(0),  \n 0,  \n mock_oracle_value,  \n mock_oracle_address,  \n )  \n |> ref_tx_in_inline_datum(True, mock_oracle_datum)  \n |> tx_in(  \n True,  \n mock_tx_hash(1),  \n 0,  \n mock_state_thread_value,  \n mock_spending_validator_address,  \n )  \n |> tx_in_inline_datum(True, mock_datum(0))  \n |> tx_out(True, mock_spending_validator_address, mock_state_thread_value)  \n |> tx_out_inline_datum(True, mock_datum(1))  \n |> required_signer_hash(True, mock_app_owner)  \n |> invalid_hereafter(True, 999)  \n |> complete()  \n}`\n\nWe can import all the `mock_...` functions from `mocktail` module to build up the types we need. In above example, we create a mock transaction for `ContinueCounting` action. We create the oracle NFT input with inline datum, the state thread token input with inline datum, the state thread token output with inline datum, the required signer and the validity range.\n\n`mock_...`\n`mocktail`\n`ContinueCounting`\n\nNow we can write a test for `ContinueCounting` action:\n\n`ContinueCounting`\n`test success_continue_counting() {  \n complex_withdrawal_contract.withdraw(  \n mock_oracle_nft,  \n ContinueCounting,  \n Credential.Script(#\"\"),  \n mock_continue_counting_tx(),  \n )  \n}`\n\n### Dynamically Testing Failure Cases[​](#dynamically-testing-failure-cases \"Direct link to Dynamically Testing Failure Cases\")\n\nIn the mocktail transaction building methods, we can pass a boolean parameter to indicate whether we want the field to be present or not. This allows us to dynamically create failure cases by omitting certain fields.\n\n`type ContinueCountingTest {  \n is_ref_input_presented: Bool,  \n is_thread_input_presented: Bool,  \n is_thread_output_presented: Bool,  \n is_count_added: Bool,  \n is_app_owner_signed: Bool,  \n is_tx_not_expired: Bool,  \n}  \n  \nfn mock_continue_counting_tx(test_case: ContinueCountingTest) -> Transaction {  \n let ContinueCountingTest {  \n is_ref_input_presented,  \n is_thread_input_presented,  \n is_thread_output_presented,  \n is_count_added,  \n is_app_owner_signed,  \n is_tx_not_expired,  \n } = test_case  \n  \n let output_datum =  \n if is_count_added {  \n mock_datum(1)  \n } else {  \n mock_datum(0)  \n }  \n mocktail_tx()  \n |> ref_tx_in(  \n is_ref_input_presented,  \n mock_tx_hash(0),  \n 0,  \n mock_oracle_value,  \n mock_oracle_address,  \n )  \n |> ref_tx_in_inline_datum(is_ref_input_presented, mock_oracle_datum)  \n |> tx_in(  \n is_thread_input_presented,  \n mock_tx_hash(1),  \n 0,  \n mock_state_thread_value,  \n mock_spending_validator_address,  \n )  \n |> tx_in_inline_datum(is_thread_input_presented, mock_datum(0))  \n |> tx_out(  \n is_thread_output_presented,  \n mock_spending_validator_address,  \n mock_state_thread_value,  \n )  \n |> tx_out_inline_datum(is_thread_output_presented, output_datum)  \n |> required_signer_hash(is_app_owner_signed, mock_app_owner)  \n |> invalid_hereafter(is_tx_not_expired, 999)  \n |> complete()  \n}`\n\nAnd we update the successful test accordingly:\n\n`test success_continue_counting() {  \n let test_case =  \n ContinueCountingTest {  \n is_ref_input_presented: True,  \n is_thread_input_presented: True,  \n is_thread_output_presented: True,  \n is_count_added: True,  \n is_app_owner_signed: True,  \n is_tx_not_expired: True,  \n }  \n  \n complex_withdrawal_contract.withdraw(  \n mock_oracle_nft,  \n ContinueCounting,  \n Credential.Script(#\"\"),  \n mock_continue_counting_tx(test_case),  \n )  \n}`\n\nAnd we can populate the failure cases at ease:\n\n`test fail_continue_counting_no_ref_input() fail {  \n let test_case =  \n ContinueCountingTest {  \n is_ref_input_presented: False,  \n is_thread_input_presented: True,  \n is_thread_output_presented: True,  \n is_count_added: True,  \n is_app_owner_signed: True,  \n is_tx_not_expired: True,  \n }  \n  \n complex_withdrawal_contract.withdraw(  \n mock_oracle_nft,  \n ContinueCounting,  \n Credential.Script(#\"\"),  \n mock_continue_counting_tx(test_case),  \n )  \n}  \n  \ntest fail_continue_counting_no_thread_input() fail {  \n let test_case =  \n ContinueCountingTest {  \n is_ref_input_presented: True,  \n is_thread_input_presented: False,  \n is_thread_output_presented: True,  \n is_count_added: True,  \n is_app_owner_signed: True,  \n is_tx_not_expired: True,  \n }  \n  \n complex_withdrawal_contract.withdraw(  \n mock_oracle_nft,  \n ContinueCounting,  \n Credential.Script(#\"\"),  \n mock_continue_counting_tx(test_case),  \n )  \n}  \n  \ntest fail_continue_counting_no_thread_output() fail {  \n let test_case =  \n ContinueCountingTest {  \n is_ref_input_presented: True,  \n is_thread_input_presented: True,  \n is_thread_output_presented: False,  \n is_count_added: True,  \n is_app_owner_signed: True,  \n is_tx_not_expired: True,  \n }  \n  \n complex_withdrawal_contract.withdraw(  \n mock_oracle_nft,  \n ContinueCounting,  \n Credential.Script(#\"\"),  \n mock_continue_counting_tx(test_case),  \n )  \n}  \n  \ntest fail_continue_counting_incorrect_count() {  \n let test_case =  \n ContinueCountingTest {  \n is_ref_input_presented: True,  \n is_thread_input_presented: True,  \n is_thread_output_presented: True,  \n is_count_added: False,  \n is_app_owner_signed: True,  \n is_tx_not_expired: True,  \n }  \n  \n !complex_withdrawal_contract.withdraw(  \n mock_oracle_nft,  \n ContinueCounting,  \n Credential.Script(#\"\"),  \n mock_continue_counting_tx(test_case),  \n )  \n}  \n  \ntest fail_continue_counting_not_signed_by_owner() {  \n let test_case =  \n ContinueCountingTest {  \n is_ref_input_presented: True,  \n is_thread_input_presented: True,  \n is_thread_output_presented: True,  \n is_count_added: True,  \n is_app_owner_signed: False,  \n is_tx_not_expired: True,  \n }  \n  \n !complex_withdrawal_contract.withdraw(  \n mock_oracle_nft,  \n ContinueCounting,  \n Credential.Script(#\"\"),  \n mock_continue_counting_tx(test_case),  \n )  \n}  \n  \ntest fail_continue_counting_app_expired() {  \n let test_case =  \n ContinueCountingTest {  \n is_ref_input_presented: True,  \n is_thread_input_presented: True,  \n is_thread_output_presented: True,  \n is_count_added: True,  \n is_app_owner_signed: True,  \n is_tx_not_expired: False,  \n }  \n  \n !complex_withdrawal_contract.withdraw(  \n mock_oracle_nft,  \n ContinueCounting,  \n Credential.Script(#\"\"),  \n mock_continue_counting_tx(test_case),  \n )  \n}`\n\nRunning `aiken check` will show:\n![Continue Counting Tests](/assets/images/04-contract-testing-3-f5bab38c0ae6696190cd20e88ba0e0ef.png)\n\n`aiken check`\n![Continue Counting Tests](/assets/images/04-contract-testing-3-f5bab38c0ae6696190cd20e88ba0e0ef.png)\n\n### Exercise[​](#exercise \"Direct link to Exercise\")\n\nWrite tests for `StopCounting` action. Refer to `ContinueCounting` tests for guidance. Suggested answers are in the code example.\n\n`StopCounting`\n`ContinueCounting`\n`expect`\n`?`\n`withdraw`",
  "images": [],
  "extraction_metadata": {
    "batch_number": 11,
    "extraction_timestamp": "2025-09-19T14:05:12.534540",
    "extraction_time": 3.978458881378174,
    "source": "tavily_api_raw"
  }
}