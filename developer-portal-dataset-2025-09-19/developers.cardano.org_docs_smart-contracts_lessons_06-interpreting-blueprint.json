{
  "url": "https://developers.cardano.org/docs/smart-contracts/lessons/06-interpreting-blueprint",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Interpreting Blueprint\n\nIn this lesson, we will explore how to interpret the blueprint generated from onchain code development and translate it into offchain code. This blueprint serves as a bridge between the onchain and offchain worlds, enabling seamless interaction with smart contracts.\n\n## What is a Blueprint?[​](#what-is-a-blueprint \"Direct link to What is a Blueprint?\")\n\nA blueprint is a standardized JSON file introduced by [CIP57](https://cips.cardano.org/cip/CIP-57). It is the ultimate output of Cardano smart contract development and contains essential information about the contract. Regardless of the development method, the blueprint includes:\n\n`preamble`\n`validators`\n`definitions`\n\n### Generating a Blueprint[​](#generating-a-blueprint \"Direct link to Generating a Blueprint\")\n\nTo generate a blueprint using Aiken, follow these steps:\n\n`aiken build`\n`plutus.json`\n\n## Understanding the Blueprint[​](#understanding-the-blueprint \"Direct link to Understanding the Blueprint\")\n\n### `preamble`[​](#preamble \"Direct link to preamble\")\n\n`preamble`\n\nThe `preamble` section contains meta-information about the contract, such as its name, description, version, and Plutus version. The Plutus version is particularly important for preparing offchain code.\n\n`preamble`\n\nExample:\n\n`{  \n \"preamble\": {  \n \"title\": \"meshsdk/aiken-template\",  \n \"description\": \"Aiken contracts for project 'meshsdk/aiken-template'\",  \n \"version\": \"0.0.0\",  \n \"plutusVersion\": \"v3\", // Key information for offchain code  \n \"compiler\": {  \n \"name\": \"Aiken\",  \n \"version\": \"v1.1.16+23061c0\"  \n },  \n \"license\": \"Apache-2.0\"  \n }  \n}`\n\n### `validators`[​](#validators \"Direct link to validators\")\n\n`validators`\n\nThe `validators` section includes type information for `datum`, `redeemer`, and `parameters`, along with the compiled validator code. These definitions may reference reusable types in the `definitions` section.\n\n`validators`\n`datum`\n`redeemer`\n`parameters`\n`definitions`\n\nExample:\n\n`{  \n \"title\": \"spend.spending_logics_delegated.spend\",  \n \"datum\": {  \n \"title\": \"_datum_opt\",  \n \"schema\": {  \n \"$ref\": \"#/definitions/Data\"  \n }  \n },  \n \"redeemer\": {  \n \"title\": \"_redeemer\",  \n \"schema\": {  \n \"$ref\": \"#/definitions/Data\"  \n }  \n },  \n \"parameters\": [  \n {  \n \"title\": \"delegated_withdrawal_script_hash\",  \n \"schema\": {  \n \"$ref\": \"#/definitions/aiken~1crypto~1ScriptHash\"  \n }  \n }  \n ],  \n \"compiledCode\": \"58ac010100229800aba2aba1aba0aab9faab9eaab9dab9a9bae0024888888896600264646644b30013370e900118039baa001899914c004c03400a601a601c0052259800800c528456600266ebc00cc02cc03c00629462660040046020002805100d2444660020026eacc040c044c044c044c044c044c044c034dd518080048c020dd500099ba548008cc028dd4802a5eb822c8030c024004c024c028004c024004c010dd5004c52689b2b200401\",  \n \"hash\": \"9c9666ddc12fc42f0151cd029c150c7d410ede9fe3885c248c8c26a0\"  \n}`\n\nNotice the `spend.spending_logics_delegated.else` compiles to the same hash as the `spend.spending_logics_delegated.spend` function. This is because the `else` branch is not executed in this case, but it is still part of the validator code. So when we are building multiple purposes validators, they will compile to the same hash, i.e. same script, which can be utilitized in certain architectures.\n\n`spend.spending_logics_delegated.else`\n`spend.spending_logics_delegated.spend`\n`else`\n`{  \n \"title\": \"spend.spending_logics_delegated.else\",  \n \"redeemer\": {  \n \"schema\": {}  \n },  \n \"parameters\": [  \n {  \n \"title\": \"delegated_withdrawal_script_hash\",  \n \"schema\": {  \n \"$ref\": \"#/definitions/aiken~1crypto~1ScriptHash\"  \n }  \n }  \n ],  \n \"compiledCode\": \"58ac010100229800aba2aba1aba0aab9faab9eaab9dab9a9bae0024888888896600264646644b30013370e900118039baa001899914c004c03400a601a601c0052259800800c528456600266ebc00cc02cc03c00629462660040046020002805100d2444660020026eacc040c044c044c044c044c044c044c034dd518080048c020dd500099ba548008cc028dd4802a5eb822c8030c024004c024c028004c024004c010dd5004c52689b2b200401\",  \n \"hash\": \"9c9666ddc12fc42f0151cd029c150c7d410ede9fe3885c248c8c26a0\"  \n}`\n\n### `definitions`[​](#definitions \"Direct link to definitions\")\n\n`definitions`\n\nThe `definitions` section provides reusable type definitions referenced in the `validators` section. This is where you can find schemas for types used in the contract.\n\n`definitions`\n`validators`\n\nExample:\n\n`{  \n \"definitions\": {  \n \"Data\": {  \n \"title\": \"Data\",  \n \"description\": \"Any Plutus data.\"  \n },  \n \"aiken/crypto/ScriptHash\": {  \n \"title\": \"ScriptHash\",  \n \"dataType\": \"bytes\"  \n },  \n \"cardano/assets/PolicyId\": {  \n \"title\": \"PolicyId\",  \n \"dataType\": \"bytes\"  \n },  \n \"withdraw/MyRedeemer\": {  \n \"title\": \"MyRedeemer\",  \n \"anyOf\": [  \n {  \n \"title\": \"ContinueCounting\",  \n \"dataType\": \"constructor\",  \n \"index\": 0,  \n \"fields\": []  \n },  \n {  \n \"title\": \"StopCounting\",  \n \"dataType\": \"constructor\",  \n \"index\": 1,  \n \"fields\": []  \n }  \n ]  \n }  \n }  \n}`\n\n## Automating Offchain Code Generation[​](#automating-offchain-code-generation \"Direct link to Automating Offchain Code Generation\")\n\nTranslating the blueprint into offchain code manually can be time-consuming. Fortunately, the Mesh community has developed a tool in the [`Cardano Bar VSCode Extension`](https://marketplace.visualstudio.com/items/?itemName=sidan-lab.cardano-bar-vscode) to automate this process.\n\n`Cardano Bar VSCode Extension`\n\nIn Mesh community, we have developed a tool in [`Cardano Bar VSCode Extension`](https://marketplace.visualstudio.com/items/?itemName=sidan-lab.cardano-bar-vscode) that can automate this process. By running the following below steps, you can generate the offchain code that corresponds to the blueprint:\n\n`Cardano Bar VSCode Extension`\n\nCreate a new TypeScript file, e.g., `offchain.ts`.\n\n`offchain.ts`\n\nOpen the command palette in VSCode (Ctrl+Shift+P or Cmd+Shift+P).\n\nType `Parse blueprint to Typescript - Mesh` and select it.\n![VSCode command palette](/assets/images/06-interpreting-blueprint-1-21e96c186f1e2ca9a13375af4b1b4cd0.png)\n\n`Parse blueprint to Typescript - Mesh`\n![VSCode command palette](/assets/images/06-interpreting-blueprint-1-21e96c186f1e2ca9a13375af4b1b4cd0.png)\n\nSelect the `plutus.json` file that contains the blueprint.\n![VSCode command palette](/assets/images/06-interpreting-blueprint-2-0d79260c15adcd4c44c7a03e5c446ec6.png)\n\n`plutus.json`\n![VSCode command palette](/assets/images/06-interpreting-blueprint-2-0d79260c15adcd4c44c7a03e5c446ec6.png)\n\nThe generated `offchain.ts` file will include all necessary functions to interact with the onchain code, such as spending, minting, and querying the contract. For more details, refer to the [Mesh SDK documentation](https://meshjs.dev/apis/utilities/blueprints).\n\n`offchain.ts`\n\n## Conclusion[​](#conclusion \"Direct link to Conclusion\")\n\nUnderstanding and interpreting the blueprint is a vital skill for Cardano developers. With tools like the Mesh `Blueprint` class, you can streamline the process and focus on building robust applications.\n\n`Blueprint`\n`preamble`\n`validators`\n`definitions`",
  "images": [],
  "extraction_metadata": {
    "batch_number": 11,
    "extraction_timestamp": "2025-09-19T14:05:12.534540",
    "extraction_time": 3.978458881378174,
    "source": "tavily_api_raw"
  }
}