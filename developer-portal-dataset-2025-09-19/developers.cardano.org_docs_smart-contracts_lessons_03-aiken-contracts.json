{
  "url": "https://developers.cardano.org/docs/smart-contracts/lessons/03-aiken-contracts",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Aiken Contracts\n\nFrom lesson 3 to lesson 6, we will explore the core concepts of building Aiken smart contracts. Some materials are abstracted from [Andamio's AikenPBL](https://app.andamio.io/course/db22e013578fcead6c2fed5446d61891ad31f3cb4955e88d980107e7).\n\n### Overview[​](#overview \"Direct link to Overview\")\n\nAiken smart contract development is a specialized field. To dive deeper and start a career as a Cardano on-chain developer, we recommend completing both courses.\n\n## System Setup[​](#system-setup \"Direct link to System Setup\")\n\nBefore we begin, let's prepare our system for development. We will use Aiken for this course. Follow one of these guides to set up your system:\n\n### Set Up an Empty Aiken Project[​](#set-up-an-empty-aiken-project \"Direct link to Set Up an Empty Aiken Project\")\n\nRun the following command to create a new Aiken project using Mesh's template:\n\n`npx meshjs 03-aiken-contracts`\n\nSelect the `Aiken` template when prompted.\n\n`Aiken`\n\n![Select at CLI](/assets/images/03-aiken-contracts-1-38f2ca0ddb30ff4dbee49faab9bf1b0b.png)\n\n![Select at CLI](/assets/images/03-aiken-contracts-1-38f2ca0ddb30ff4dbee49faab9bf1b0b.png)\n\nAfter installation, a new folder `03-aiken-contracts` will be created with the following structure:\n\n`03-aiken-contracts`\n`03-aiken-contracts  \n├── aiken-workspace // Main Aiken project folder used in lessons  \n└── mesh // Folder for equivalent Mesh off-chain code (not used in lessons)`\n\n### Optional: Install Cardano-Bar[​](#optional-install-cardano-bar \"Direct link to Optional: Install Cardano-Bar\")\n\nIf you use VSCode as your IDE, install the [Cardano-Bar](https://marketplace.visualstudio.com/items/?itemName=sidan-lab.cardano-bar-vscode) extension for code snippets to follow the course more easily.\n\n![Cardano Bar](/assets/images/03-aiken-contracts-2-8d6904ab6dee660d302a1a0bcb9eab63.png)\n\n![Cardano Bar](/assets/images/03-aiken-contracts-2-8d6904ab6dee660d302a1a0bcb9eab63.png)\n\n## Understanding Transaction Context[​](#understanding-transaction-context \"Direct link to Understanding Transaction Context\")\n\nCardano contracts are not like traditional smart contracts on other blockchains. They are more like a set of rules governing how transactions are validated. **Validator** is a better term to describe Cardano contracts.\n\nTo build Cardano validators, we need to understand how transactions work. Refer to the [Aiken documentation](https://aiken-lang.github.io/stdlib/cardano/transaction.html#Transaction) for details on the `Transaction` structure.\n\n`Transaction`\n\n![Aiken Tx](/assets/images/03-aiken-contracts-3-7d61e0045147b4567742f4afcc1f83ca.png)\n\n![Aiken Tx](/assets/images/03-aiken-contracts-3-7d61e0045147b4567742f4afcc1f83ca.png)\n\n### Inputs & Outputs[​](#inputs--outputs \"Direct link to Inputs & Outputs\")\n\nAll Cardano transactions must have inputs and outputs:\n\nRefer to [Aiken documentation](https://aiken-lang.github.io/stdlib/cardano/transaction.html#Input) for types:\n\n![Input](/assets/images/03-aiken-contracts-4-f274b6c4254fc629bc1862016b547b0b.png)\n![Output](/assets/images/03-aiken-contracts-5-d16b637b92825198b1619634bc016465.png)\n\n![Input](/assets/images/03-aiken-contracts-4-f274b6c4254fc629bc1862016b547b0b.png)\n![Output](/assets/images/03-aiken-contracts-5-d16b637b92825198b1619634bc016465.png)\n\nKey concepts:\n\n`output_reference`\n\n### Reference Inputs[​](#reference-inputs \"Direct link to Reference Inputs\")\n\n`reference_inputs` in `Transaction` are inputs not spent but referenced in the validator. Useful for reading datum from a UTXO without spending it.\n\n`reference_inputs`\n`Transaction`\n\n### Mint[​](#mint \"Direct link to Mint\")\n\n`mint` in `Transaction` lists assets being minted or burned. Useful for creating or burning tokens.\n\n`mint`\n`Transaction`\n\n### Signatures[​](#signatures \"Direct link to Signatures\")\n\n`extra_signatories` in `Transaction` lists public key hashes required to sign the transaction. Useful for enforcing specific users to sign.\n\n`extra_signatories`\n`Transaction`\n\n### Time[​](#time \"Direct link to Time\")\n\n`validity_range` in `Transaction` specifies the range of slots the transaction is valid for. Useful for enforcing time locks.\n\n`validity_range`\n`Transaction`\n\n## Types of Scripts[​](#types-of-scripts \"Direct link to Types of Scripts\")\n\nRefer to [Aiken documentation](https://aiken-lang.github.io/stdlib/cardano/script_context.html#ScriptContext) for types of scripts in Cardano. Common types:\n\n![Aiken Script Info](/assets/images/03-aiken-contracts-6-0f74b52468c8b57925084de5e4a941a2.png)\n\n![Aiken Script Info](/assets/images/03-aiken-contracts-6-0f74b52468c8b57925084de5e4a941a2.png)\n\n### Minting Script[​](#minting-script \"Direct link to Minting Script\")\n\nMinting script validation logic is triggered when assets are minted or burned under the script's policy.\n\nExample: `/aiken-workspace/validators/mint.ak`:\n\n`/aiken-workspace/validators/mint.ak`\n`use cardano/assets.{PolicyId}  \nuse cardano/transaction.{Transaction, placeholder}  \n  \nvalidator always_succeed {  \n mint(_redeemer: Data, _policy_id: PolicyId, _tx: Transaction) {  \n True  \n }  \n  \n else(_) {  \n fail @\"unsupported purpose\"  \n }  \n}  \n  \ntest test_always_succeed_minting_policy() {  \n let data = Void  \n always_succeed.mint(data, #\"\", placeholder)  \n}`\n\nThis script compiles into a script with hash `def68337867cb4f1f95b6b811fedbfcdd7780d10a95cc072077088ea`, also called `policy Id`. It validates transactions minting or burning assets under this policy.\n\n`def68337867cb4f1f95b6b811fedbfcdd7780d10a95cc072077088ea`\n`policy Id`\n\n#### Parameters[​](#parameters \"Direct link to Parameters\")\n\nUpgrade the script to allow minting/burning only when signed by a specific key:\n\n`validator minting_policy(owner_vkey: VerificationKeyHash) {  \n mint(_redeemer: Data, _policy_id: PolicyId, tx: Transaction) {  \n key_signed(tx.extra_signatories, owner_vkey)  \n }  \n  \n else(_) {  \n fail @\"unsupported purpose\"  \n }  \n}`\n`owner_vkey`\n`key_signed`\n\n#### Redeemer[​](#redeemer \"Direct link to Redeemer\")\n\nExtend the policy to include a redeemer specifying the transaction action (minting or burning):\n\n`pub type MyRedeemer {  \n MintToken  \n BurnToken  \n}  \n  \nvalidator minting_policy(  \n owner_vkey: VerificationKeyHash,  \n minting_deadline: Int,  \n) {  \n mint(redeemer: MyRedeemer, policy_id: PolicyId, tx: Transaction) {  \n when redeemer is {  \n MintToken -> {  \n let before_deadline = valid_before(tx.validity_range, minting_deadline)  \n let is_owner_signed = key_signed(tx.extra_signatories, owner_vkey)  \n before_deadline? && is_owner_signed?  \n }  \n BurnToken -> check_policy_only_burn(tx.mint, policy_id)  \n }  \n }  \n  \n else(_) {  \n fail @\"unsupported purpose\"  \n }  \n}`\n\n### Spending Script[​](#spending-script \"Direct link to Spending Script\")\n\nSpending script validation is triggered when a UTXO is spent in the transaction.\n\nExample: `/aiken-workspace/validators/spend.ak`:\n\n`/aiken-workspace/validators/spend.ak`\n`pub type Datum {  \n oracle_nft: PolicyId,  \n}  \n  \nvalidator hello_world {  \n spend(  \n datum_opt: Option<Datum>,  \n _redeemer: Data,  \n _input: OutputReference,  \n tx: Transaction,  \n ) {  \n when datum_opt is {  \n Some(datum) ->  \n when inputs_with_policy(tx.reference_inputs, datum.oracle_nft) is {  \n [_ref_input] -> True  \n _ -> False  \n }  \n None -> False  \n }  \n }  \n  \n else(_) {  \n fail @\"unsupported purpose\"  \n }  \n}`\n\n#### Datum[​](#datum \"Direct link to Datum\")\n\n`Datum`\n\n### Withdrawing Script[​](#withdrawing-script \"Direct link to Withdrawing Script\")\n\nWithdrawal script validation is triggered when withdrawing from a reward account.\n\nExample: `/aiken-workspace/validators/withdraw.ak`:\n\n`/aiken-workspace/validators/withdraw.ak`\n`use aiken/crypto.{VerificationKeyHash}  \nuse cardano/address.{Credential, Script}  \nuse cardano/certificate.{Certificate}  \nuse cardano/transaction.{Transaction, placeholder}  \n  \nvalidator always_succeed(_key_hash: VerificationKeyHash) {  \n withdraw(_redeemer: Data, _credential: Credential, _tx: Transaction) {  \n True  \n }  \n  \n publish(_redeemer: Data, _certificate: Certificate, _tx: Transaction) {  \n True  \n }  \n  \n else(_) {  \n fail @\"unsupported purpose\"  \n }  \n}  \n  \ntest test_always_succeed_withdrawal_policy() {  \n let data = Void  \n always_succeed.withdraw(\"\", data, Script(#\"\"), placeholder)  \n}`\n\n#### Handling Publishing[​](#handling-publishing \"Direct link to Handling Publishing\")\n\nAll withdrawal scripts must be registered on-chain before they can be used. This is done by publishing a registration certificate with the script hash as the stake credential. The publishing of the script is also validated by the `publish` function in the withdrawal script, which is triggered whenever the current withdrawal script is being registered or deregistered.\n\n`publish`\n\n#### When withdrawal script is used?[​](#when-withdrawal-script-is-used \"Direct link to When withdrawal script is used?\")\n\nFor most Cardano users, we would just use a normal payment key to stake and withdraw rewards. However, it is very popular for Cardano DApps to build withdrawal scripts to enhance the efficiency of validation. We will cover this trick in [lesson 5](/docs/smart-contracts/lessons/05-avoid-redundant-validation).",
  "images": [],
  "extraction_metadata": {
    "batch_number": 11,
    "extraction_timestamp": "2025-09-19T14:05:12.534540",
    "extraction_time": 3.978458881378174,
    "source": "tavily_api_raw"
  }
}