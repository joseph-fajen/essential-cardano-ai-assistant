{
  "url": "https://developers.cardano.org/docs/smart-contracts/lessons/08-plutus-nft",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Plutus NFT Contract\n\nAfter the simple vesting contract, let's level up to a more complex contract with multiple validators interacting with each other. This lesson will guide you step-by-step through the process of creating a Plutus NFT contract, ensuring clarity and simplicity.\n\n## Overview[​](#overview \"Direct link to Overview\")\n\nThis lesson focuses on creating a smart contract for minting NFTs with an automatically incremented index. The contract ensures non-fungibility and uniqueness of the NFTs under the same policy. To achieve this, we will:\n\n## Step 1: Oracle NFT[​](#step-1-oracle-nft \"Direct link to Step 1: Oracle NFT\")\n\nThe oracle NFT acts as the single source of truth for the system. It uses a state thread token to ensure consistency. We will implement a one-time minting policy for the oracle NFT.\n\n### Code Explanation[​](#code-explanation \"Direct link to Code Explanation\")\n\nThe following code defines the minting policy for the oracle NFT:\n\n`pub type MintPolarity {  \n RMint  \n RBurn  \n}  \n  \nvalidator oracle_nft(utxo_ref: OutputReference) {  \n mint(redeemer: MintPolarity, policy_id: PolicyId, tx: Transaction) {  \n when redeemer is {  \n RMint -> {  \n let Transaction { inputs, .. } = tx  \n let hash_equal =  \n fn(input: Input) {  \n let hash = input.output_reference  \n utxo_ref == hash  \n }  \n let target_input_exist = list.find(inputs, hash_equal)  \n when target_input_exist is {  \n Some(_) -> True  \n None -> False  \n }  \n }  \n RBurn -> check_policy_only_burn(tx.mint, policy_id)  \n }  \n }  \n  \n else(_) {  \n fail  \n }  \n}`\n\n**Key Points:**\n\n`RMint`\n`RBurn`\n\n## Step 2: Oracle Validator[​](#step-2-oracle-validator \"Direct link to Step 2: Oracle Validator\")\n\nThe oracle validator holds the current state of the NFT index. It defines the datum and redeemer types for state changes.\n\n### Datum Definition[​](#datum-definition \"Direct link to Datum Definition\")\n\n`pub type OracleDatum {  \n count: Int,  \n lovelace_price: Int,  \n fee_address: Address,  \n}`\n\n### Redeemer Types[​](#redeemer-types \"Direct link to Redeemer Types\")\n\n`pub type OracleRedeemer {  \n MintPlutusNFT  \n StopOracle  \n}`\n\n### Validator Logic[​](#validator-logic \"Direct link to Validator Logic\")\n\nThe validator ensures the state changes are valid:\n\n`validator oracle {  \n spend(  \n datum_opt: Option<OracleDatum>,  \n redeemer: OracleRedeemer,  \n input: OutputReference,  \n tx: Transaction,  \n ) {  \n let Transaction { mint, inputs, outputs, extra_signatories, .. } = tx  \n expect Some(OracleDatum { count, lovelace_price, fee_address }) = datum_opt  \n expect Some(own_input) = find_input(inputs, input)  \n expect [(oracle_nft_policy, _, _)] =  \n list.filter(flatten(own_input.output.value), fn(x) { x.1st != \"\" })  \n  \n todo  \n }  \n  \n else(_) {  \n fail  \n }  \n}`\n\nIn this setup, we identified the own input with `find_input` function, which is a utility function that finds the input with the given output reference. We also expect the oracle NFT policy to be present in the own input's value.\n\n`find_input`\n\nWe know that for state change, we will have exactly one input from current address, and one output to the same address. We can then perform below pattern matching:\n\n `let own_address = own_input.output.address  \n when  \n (  \n redeemer,  \n inputs_at_with_policy(inputs, own_address, oracle_nft_policy),  \n outputs_at_with_policy(outputs, own_address, oracle_nft_policy),  \n )  \n is {  \n (MintPlutusNFT, [_], [only_output]) -> {  \n todo  \n }  \n _ -> False  \n }`\n\nAdd in core checks for `MintPlutusNFT`:\n\n`MintPlutusNFT`\n `let is_output_value_clean = list.length(flatten(only_output.value)) == 2  \n let is_count_updated =  \n only_output.datum == InlineDatum(  \n OracleDatum { count: count + 1, lovelace_price, fee_address },  \n )  \n let is_fee_paid =  \n get_all_value_to(outputs, fee_address)  \n |> value_geq(from_lovelace(lovelace_price))  \n is_output_value_clean? && is_count_updated? && is_fee_paid?`\n\nNotice there is a `is_output_value_clean` check here, which ensures the changed state UTxO only contains the state thread token and ADA, i.e. no other assets are present in the output value. This is to prevent a common vulnerability of `Unbounded Value`, where people can attach infinitely amount of assets to the output to make it unspendable by overflowing the transaction size.\n\n`is_output_value_clean`\n`Unbounded Value`\n\nComplete with `StopOracle` logics:\n\n`StopOracle`\n `(StopOracle, [_], _) -> {  \n let is_oracle_nft_burnt =  \n only_minted_token(mint, oracle_nft_policy, \"\", -1)  \n let owner_key = address_payment_key(fee_address)  \n let is_owner_signed = key_signed(extra_signatories, owner_key)  \n is_oracle_nft_burnt? && is_owner_signed?  \n }`\n\nA complete oracle validator looks like this:\n\n`validator oracle {  \n spend(  \n datum_opt: Option<OracleDatum>,  \n redeemer: OracleRedeemer,  \n input: OutputReference,  \n tx: Transaction,  \n ) {  \n let Transaction { mint, inputs, outputs, extra_signatories, .. } = tx  \n expect Some(OracleDatum { count, lovelace_price, fee_address }) = datum_opt  \n expect Some(own_input) = find_input(inputs, input)  \n expect [(oracle_nft_policy, _, _)] =  \n list.filter(flatten(own_input.output.value), fn(x) { x.1st != \"\" })  \n let own_address = own_input.output.address  \n when  \n (  \n redeemer,  \n inputs_at_with_policy(inputs, own_address, oracle_nft_policy),  \n outputs_at_with_policy(outputs, own_address, oracle_nft_policy),  \n )  \n is {  \n (MintPlutusNFT, [_], [only_output]) -> {  \n let is_output_value_clean = list.length(flatten(only_output.value)) == 2  \n let is_count_updated =  \n only_output.datum == InlineDatum(  \n OracleDatum { count: count + 1, lovelace_price, fee_address },  \n )  \n let is_fee_paid =  \n get_all_value_to(outputs, fee_address)  \n |> value_geq(from_lovelace(lovelace_price))  \n is_output_value_clean? && is_count_updated? && is_fee_paid?  \n }  \n (StopOracle, [_], _) -> {  \n let is_oracle_nft_burnt =  \n only_minted_token(mint, oracle_nft_policy, \"\", -1)  \n let owner_key = address_payment_key(fee_address)  \n let is_owner_signed = key_signed(extra_signatories, owner_key)  \n is_oracle_nft_burnt? && is_owner_signed?  \n }  \n _ -> False  \n }  \n }  \n  \n else(_) {  \n fail  \n }  \n}`\n\n**Key Points:**\n\n`MintPlutusNFT`\n`StopOracle`\n\n## Step 3: Plutus NFT Minting Validator[​](#step-3-plutus-nft-minting-validator \"Direct link to Step 3: Plutus NFT Minting Validator\")\n\nThe Plutus NFT minting validator ensures the NFT is unique and non-fungible.\n\n### Code Explanation[​](#code-explanation-1 \"Direct link to Code Explanation\")\n\n`pub type MintPolarity {  \n RMint  \n RBurn  \n}  \n  \nvalidator plutus_nft(collection_name: ByteArray, oracle_nft: PolicyId) {  \n mint(redeemer: MintPolarity, policy_id: PolicyId, tx: Transaction) {  \n when redeemer is {  \n RMint -> {  \n let Transaction { inputs, mint, .. } = tx  \n expect [auth_input] = inputs_with_policy(inputs, oracle_nft)  \n expect InlineDatum(input_datum) = auth_input.output.datum  \n expect OracleDatum { count, .. }: OracleDatum = input_datum  \n let asset_name =  \n collection_name  \n |> concat(\" (\")  \n |> concat(convert_int_to_bytes(count))  \n |> concat(\")\")  \n only_minted_token(mint, policy_id, asset_name, 1)  \n }  \n  \n RBurn -> check_policy_only_burn(tx.mint, policy_id)  \n }  \n }  \n  \n else(_) {  \n fail  \n }  \n}`\n\n**Key Points:**\n\nThe code example above is presented in [Mesh repository](https://github.com/MeshJS/mesh/tree/main/packages/mesh-contract/src/plutus-nft/aiken-workspace), you can find the equivalent tests there.\n\n### Compile and build script[​](#compile-and-build-script \"Direct link to Compile and build script\")\n\n`aiken build`\n\nThis command will generate a CIP-0057 Plutus blueprint, which you can find in [`plutus.json`](https://github.com/cardanobuilders/cardanobuilders.github.io/blob/main/codes/course-hello-cardano/03-vesting/src/aiken-workspace/plutus.json).\n\n`plutus.json`\n\n## Setup Oracle[​](#setup-oracle \"Direct link to Setup Oracle\")\n\nTo set up the oracle, we need to mint the oracle NFT first and lock it in the oracle validator. This is a one-time operation, and we can do it with the following code:\n\nWe prepare the wallet and tx-builder similar to previous lessons, and get some static information:\n\n`const compiledCode = <the compile code from blueprint>;  \n  \nconst utxos = await wallet?.getUtxos();  \nconst collateral = (await wallet.getCollateral())[0]!;  \nconst walletAddress = await wallet.getChangeAddress()  \n  \nconst paramUtxo = utxos[0]!;  \nconst param: Data = mOutputReference(  \n paramUtxo.input.txHash,  \n paramUtxo.input.outputIndex,  \n);  \nconst paramScript = applyParamsToScript(compiledCode, [param]);  \nconst policyId = resolveScriptHash(paramScript, \"V3\");  \nconst tokenName = \"\";  \nconst { pubKeyHash, stakeCredentialHash } =  \n deserializeAddress(walletAddress);`\n\nThen we can perform the setup:\n\n`const txHex = await txBuilder  \n .txIn(  \n paramUtxo.input.txHash,  \n paramUtxo.input.outputIndex,  \n paramUtxo.output.amount,  \n paramUtxo.output.address,  \n )  \n .mintPlutusScriptV3()  \n .mint(\"1\", policyId, tokenName)  \n .mintingScript(paramScript)  \n .mintRedeemerValue(mConStr0([]))  \n .txOut(oracleAddress, [{ unit: policyId, quantity: \"1\" }])  \n .txOutInlineDatumValue(  \n mConStr0([  \n 0,  \n lovelacePrice,  \n mPubKeyAddress(pubKeyHash, stakeCredentialHash),  \n ]),  \n )  \n .txInCollateral(  \n collateral.input.txHash,  \n collateral.input.outputIndex,  \n collateral.output.amount,  \n collateral.output.address,  \n )  \n .changeAddress(walletAddress)  \n .selectUtxosFrom(utxos)  \n .complete();`\n\nImportant, we need to save the `paramUtxo` information for later use:\n\n`paramUtxo`\n\n## Mint Plutus NFT[​](#mint-plutus-nft \"Direct link to Mint Plutus NFT\")\n\nTo mint the Plutus NFT, first we need to define static info:\n\n`type OracleDatum = ConStr0<[Integer, Integer, PubKeyAddress]>;  \n  \nconst oracleCompileCode = <the compile code from oracle blueprint>;  \nconst oracleNftCbor = applyParamsToScript(blueprint.validators[2]!.compiledCode, [  \n mOutputReference(paramUtxo.txHash, paramUtxo.outputIndex),  \n])  \nconst oracleNftPolicyId = resolveScriptHash(oracleNftCbor, \"V3\");  \n  \nconst oracleCbor = applyCborEncoding(<the oracle compile code>)  \nconst oracleAddress = serializePlutusScript(  \n {  \n code: oracleCbor,  \n version: \"V3\",  \n },  \n \"\", // the stake credential, we can supply if we have one  \n \"preprod\",  \n ).address  \n  \nconst getAddressUtxosWithToken = async (  \n walletAddress: string,  \n assetHex: string,  \n ) => {  \n let utxos = await fetcher.fetchAddressUTxOs(walletAddress);  \n return utxos.filter((u) => {  \n const assetAmount = u.output.amount.find(  \n (a: any) => a.unit === assetHex,  \n )?.quantity;  \n return Number(assetAmount) >= 1;  \n });  \n };`\n\nAnd a helper method to get the existing oracle information:\n\n`const getOracleData = async () => {  \n const oracleUtxo = (  \n await getAddressUtxosWithToken(oracleAddress, oracleNftPolicyId)  \n )[0]!;  \n const oracleDatum: OracleDatum = parseDatumCbor(  \n oracleUtxo!.output.plutusData!,  \n );  \n  \n const nftIndex = oracleDatum.fields[0].int;  \n const lovelacePrice = oracleDatum.fields[1].int;  \n const feeCollectorAddressObj = oracleDatum.fields[2];  \n const feeCollectorAddress = serializeAddressObj(  \n feeCollectorAddressObj,  \n \"preprod\",  \n );  \n  \n const policyId = resolveScriptHash(oracleNftCbor, \"V3\");  \n  \n return {  \n nftIndex,  \n policyId,  \n lovelacePrice,  \n oracleUtxo,  \n oracleNftPolicyId,  \n feeCollectorAddress,  \n feeCollectorAddressObj,  \n };  \n};`\n\nThen we can build the core logic to mint the Plutus NFT:\n\n`const utxos = await wallet?.getUtxos();  \nconst collateral = (await wallet.getCollateral())[0]!;  \nconst walletAddress = await wallet.getChangeAddress()  \n  \nconst collectionName = \"MyNFTCollection\";  \nconst nftCbor = applyParamsToScript(<the plutus NFT compiled code>, [  \n stringToHex(collectionName),  \n oracleNftPolicyId,  \n]);  \n  \n  \nconst {  \n nftIndex,  \n policyId,  \n lovelacePrice,  \n oracleUtxo,  \n oracleNftPolicyId,  \n feeCollectorAddress,  \n feeCollectorAddressObj,  \n} = await getOracleData();  \n  \nconst tokenName = `${collectionName} (${nftIndex})`;  \nconst tokenNameHex = stringToHex(tokenName);  \n  \nconst updatedOracleDatum: OracleDatum = conStr0([  \n integer((nftIndex as number) + 1),  \n integer(lovelacePrice),  \n feeCollectorAddressObj,  \n]);  \n  \nconst tx = txBuilder  \n .spendingPlutusScriptV3()  \n .txIn(  \n oracleUtxo.input.txHash,  \n oracleUtxo.input.outputIndex,  \n oracleUtxo.output.amount,  \n oracleUtxo.output.address,  \n 0  \n )  \n .txInRedeemerValue(mConStr0([]))  \n .txInScript(oracleCbor)  \n .txInInlineDatumPresent()  \n .txOut(oracleAddress, [{ unit: oracleNftPolicyId, quantity: \"1\" }])  \n .txOutInlineDatumValue(updatedOracleDatum, \"JSON\")  \n .mintPlutusScriptV3()  \n .mint(\"1\", policyId, tokenNameHex)  \n .mintingScript(nftCbor);  \n  \nconst assetMetadata = {  \n name: `MyNFTCollection (${nftIndex})`,  \n image: \"ipfs://QmRzicpReutwCkM6aotuKjErFCUD213DpwPq6ByuzMJaua\",  \n mediaType: \"image/jpg\",  \n description: \"This NFT was minted by Mesh (https://meshjs.dev/).\",  \n};  \n  \nconst metadata = { [policyId]: { [tokenName]: { ...assetMetadata } } };  \ntx.metadataValue(721, metadata);  \n  \ntx.mintRedeemerValue(mConStr0([]))  \n .txOut(feeCollectorAddress, [  \n { unit: \"lovelace\", quantity: lovelacePrice.toString() },  \n ])  \n .txInCollateral(  \n collateral.input.txHash,  \n collateral.input.outputIndex,  \n collateral.output.amount,  \n collateral.output.address,  \n )  \n .changeAddress(walletAddress)  \n .selectUtxosFrom(utxos);  \n  \nconst txHex = await tx.complete();`\n\n## Packaged functions[​](#packaged-functions \"Direct link to Packaged functions\")\n\nThe Plutus NFT contract has been implemented in `@meshsdk/contract` package, you can find further explanation at the [Mesh documentation](https://meshjs.dev/smart-contracts/plutus-nft) and more details about entire stack source code at [Mesh repository](https://github.com/MeshJS/mesh/tree/main/packages/mesh-contract/src/plutus-nft).\n\n`@meshsdk/contract`",
  "images": [],
  "extraction_metadata": {
    "batch_number": 11,
    "extraction_timestamp": "2025-09-19T14:05:12.534540",
    "extraction_time": 3.978458881378174,
    "source": "tavily_api_raw"
  }
}