{
  "url": "https://developers.cardano.org/docs/smart-contracts/smart-contract-languages/aiken/advanced-data-structures/linked-list",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Linked List\n\n## Introduction[​](#introduction \"Direct link to Introduction\")\n\nLinked list structures leverage the EUTXO model to enhancing scalability and throughput significantly. By linking multiple UTXOs together through a series of minting policies and validators, it can improve the user experience interacting with smart contract concurrently.\n\nThe github repository introducing these data structures can be found [here](https://github.com/Anastasia-Labs/aiken-linked-list).\n\n## Documentation[​](#documentation \"Direct link to Documentation\")\n\n### Linked List[​](#linked-list \"Direct link to Linked List\")\n\nThe Aiken Linked List is an on-chain, sorted linked list solution designed for blockchain environments, specifically utilizing NFTs (Non-Fungible Tokens) and datums. It provides a structured and efficient way to store and manipulate a list of key/value pairs on-chain.\n\n![linked-list](/assets/images/linked-list-1-71c67965afd9b03cf7d6954746efb616.png)\n\n![linked-list](/assets/images/linked-list-1-71c67965afd9b03cf7d6954746efb616.png)\n\n#### Entry Structure[​](#entry-structure \"Direct link to Entry Structure\")\n\nEach entry in the list comprises:\n\n#### EntryDatum Definition[​](#entrydatum-definition \"Direct link to EntryDatum Definition\")\n\n`data EntryDatum = EntryDatum {  \n key :: BuiltinByteString,  \n value :: Maybe SomeValue,  \n nft :: NFT,  \n next :: Maybe NFT  \n}`\n\n#### Operations[​](#operations \"Direct link to Operations\")\n\n##### Inserting an Entry[​](#inserting-an-entry \"Direct link to Inserting an Entry\")\n\n![insert entry](/assets/images/linked-list-2-9027d729be0bab4c3c4b9b4e313d3e29.png)\n\n![insert entry](/assets/images/linked-list-2-9027d729be0bab4c3c4b9b4e313d3e29.png)\n\nInsertion involves:\n\nValidation Rules\n\n##### Removing an Entry[​](#removing-an-entry \"Direct link to Removing an Entry\")\n\n![remove entry](/assets/images/linked-list-3-8ea28d25a5961ac70fb53d476ec61166.png)\n\n![remove entry](/assets/images/linked-list-3-8ea28d25a5961ac70fb53d476ec61166.png)\n\nTo remove an entry:\n\n#### Utilizing NFTs as Pointers[​](#utilizing-nfts-as-pointers \"Direct link to Utilizing NFTs as Pointers\")\n\nNFTs serve as robust and unique pointers within the list. Their uniqueness is ensured by a specific minting policy related to the list's head NFT.\n\n#### Key Considerations[​](#key-considerations \"Direct link to Key Considerations\")\n\n#### Advanced Features[​](#advanced-features \"Direct link to Advanced Features\")\n\n### Aiken Linked List implementation[​](#aiken-linked-list-implementation \"Direct link to Aiken Linked List implementation\")\n\nThe Aiken Linked List implementation provides several functions to create and manipulate Linked List. Below is a brief overview of each function:\n\n`init`\n`deinit`\n`insert`\n`remove`\n\n## Validator Logic[​](#validator-logic \"Direct link to Validator Logic\")\n\nFor a complete example, including tests and further explanations, reger to the provided sample validator:\n\n`use aiken/bytearray  \nuse aiken/dict  \nuse aiken/interval.{Finite, Interval, IntervalBound, is_entirely_before}  \nuse aiken/list  \nuse aiken/transaction.{  \n InlineDatum, Input, Mint, NoDatum, Output, OutputReference, ScriptContext,  \n Transaction, TransactionId,  \n}  \nuse aiken/transaction/credential.{Address}  \nuse aiken/transaction/value  \nuse linkedlist/constants.{origin_node_token_name}  \nuse linkedlist/linked_list.{deinit, init, insert, remove}  \nuse linkedlist/types.{  \n Config, Deinit, Empty, Init, Insert, Key, NodeAction, Remove, SetNode,  \n}  \nuse linkedlist/utils  \n  \nvalidator {  \n fn mint_validator(cfg: Config, redeemer: NodeAction, ctx: ScriptContext) {  \n let (common, inputs, outputs, sigs, vrange) = utils.make_common(ctx)  \n when redeemer is {  \n Init -> {  \n expect  \n list.any(  \n inputs,  \n fn(input) { cfg.init_utxo == input.output_reference },  \n )  \n init(common)  \n }  \n Deinit -> deinit(common)  \n Insert { key_to_insert, covering_node } -> {  \n expect is_entirely_before(vrange, cfg.deadline)  \n expect list.any(sigs, fn(sig) { sig == key_to_insert })  \n insert(common, key_to_insert, covering_node)  \n }  \n Remove { key_to_remove, covering_node } -> {  \n expect is_entirely_before(vrange, cfg.deadline)  \n remove(common, vrange, cfg, outputs, sigs, key_to_remove, covering_node)  \n }  \n }  \n }  \n}  \n  \ntest mint_validator_init() {  \n let own_cs = #\"746fa3ba2daded6ab9ccc1e39d3835aa1dfcb9b5a54acc2ebe6b79a4\"  \n let init_output_ref =  \n OutputReference {  \n transaction_id: TransactionId {  \n hash: #\"2c6dbc95c1e96349c4131a9d19b029362542b31ffd2340ea85dd8f28e271ff6d\",  \n },  \n output_index: 1,  \n }  \n let config =  \n Config {  \n init_utxo: init_output_ref,  \n deadline: 86_400_000,  \n penalty_address: Address(credential.ScriptCredential(\"P\"), None),  \n }  \n let redeemer = Init  \n let minted_value = value.add(value.zero(), own_cs, origin_node_token_name, 1)  \n let head_output =  \n Output {  \n address: Address(credential.ScriptCredential(\"B\"), None),  \n value: value.add(  \n minted_value,  \n value.ada_policy_id,  \n value.ada_asset_name,  \n 4_000_000,  \n ),  \n datum: InlineDatum(SetNode { key: Empty, next: Empty }),  \n reference_script: None,  \n }  \n let context =  \n ScriptContext {  \n purpose: Mint(own_cs),  \n transaction: Transaction {  \n inputs: [  \n Input {  \n output_reference: init_output_ref,  \n output: Output {  \n address: Address(credential.ScriptCredential(\"C\"), None),  \n value: value.from_lovelace(4_000_000),  \n datum: NoDatum,  \n reference_script: None,  \n },  \n },  \n ],  \n reference_inputs: [],  \n outputs: [head_output],  \n fee: value.zero(),  \n mint: value.to_minted_value(minted_value),  \n certificates: [],  \n withdrawals: dict.new(),  \n validity_range: interval.everything(),  \n extra_signatories: [],  \n redeemers: dict.new(),  \n datums: dict.new(),  \n id: TransactionId {  \n hash: #\"2c6dbc95c1e96349c4131a9d19b029362542b31ffd2340ea85dd8f28e271ff6d\",  \n },  \n },  \n }  \n  \n mint_validator(config, redeemer, context)  \n}  \n  \ntest mint_validator_deinit() {  \n let own_cs = #\"746fa3ba2daded6ab9ccc1e39d3835aa1dfcb9b5a54acc2ebe6b79a4\"  \n let init_output_ref =  \n OutputReference {  \n transaction_id: TransactionId {  \n hash: #\"2c6dbc95c1e96349c4131a9d19b029362542b31ffd2340ea85dd8f28e271ff6d\",  \n },  \n output_index: 1,  \n }  \n let config =  \n Config {  \n init_utxo: init_output_ref,  \n deadline: 86_400_000,  \n penalty_address: Address(credential.ScriptCredential(\"P\"), None),  \n }  \n let redeemer = Deinit  \n let own_cs_value = value.add(value.zero(), own_cs, origin_node_token_name, -1)  \n let burn_value = value.add(value.zero(), own_cs, origin_node_token_name, -1)  \n let in_output =  \n Output {  \n address: Address(credential.ScriptCredential(\"B\"), None),  \n value: value.add(  \n own_cs_value,  \n value.ada_policy_id,  \n value.ada_asset_name,  \n 4_000_000,  \n ),  \n datum: InlineDatum(SetNode { key: Empty, next: Empty }),  \n reference_script: None,  \n }  \n let context =  \n ScriptContext {  \n purpose: Mint(own_cs),  \n transaction: Transaction {  \n inputs: [Input { output_reference: init_output_ref, output: in_output }],  \n reference_inputs: [],  \n outputs: [],  \n fee: value.zero(),  \n mint: value.to_minted_value(burn_value),  \n certificates: [],  \n withdrawals: dict.new(),  \n validity_range: interval.everything(),  \n extra_signatories: [],  \n redeemers: dict.new(),  \n datums: dict.new(),  \n id: TransactionId {  \n hash: #\"2c6dbc95c1e96349c4131a9d19b029362542b31ffd2340ea85dd8f28e271ff6d\",  \n },  \n },  \n }  \n  \n mint_validator(config, redeemer, context)  \n}  \n  \ntest mint_validator_deinit_fails_on_non_empty() fail {  \n let own_cs = #\"746fa3ba2daded6ab9ccc1e39d3835aa1dfcb9b5a54acc2ebe6b79a4\"  \n let init_output_ref =  \n OutputReference {  \n transaction_id: TransactionId {  \n hash: #\"2c6dbc95c1e96349c4131a9d19b029362542b31ffd2340ea85dd8f28e271ff6d\",  \n },  \n output_index: 1,  \n }  \n let config =  \n Config {  \n init_utxo: init_output_ref,  \n deadline: 86_400_000,  \n penalty_address: Address(credential.ScriptCredential(\"P\"), None),  \n }  \n let user2_pkh =  \n bytearray.from_string(  \n @\"e18d73505be6420225ed2a42c8e975e4c6f9148ab38e951ea2572e54\",  \n )  \n let user2_tn = \"FSNe18d73505be6420225ed2a42c8e975e4c6f9148ab38e951ea2572e54\"  \n let remove_output_ref =  \n OutputReference {  \n transaction_id: TransactionId { hash: #\"\" },  \n output_index: 1,  \n }  \n let remove_node =  \n SetNode { key: Key { key: user2_pkh }, next: Key { key: user2_pkh } }  \n let user2_value = value.add(value.zero(), own_cs, user2_tn, 1)  \n let remove_node_output =  \n Output {  \n address: Address(credential.ScriptCredential(\"I\"), None),  \n value: value.add(  \n user2_value,  \n value.ada_policy_id,  \n value.ada_asset_name,  \n 9_000_000,  \n ),  \n datum: InlineDatum(remove_node),  \n reference_script: None,  \n }  \n let burn_value = value.add(value.zero(), own_cs, origin_node_token_name, -1)  \n let redeemer = Deinit  \n let context =  \n ScriptContext {  \n purpose: Mint(own_cs),  \n transaction: Transaction {  \n inputs: [  \n Input {  \n output_reference: remove_output_ref,  \n output: remove_node_output,  \n },  \n ],  \n reference_inputs: [],  \n outputs: [],  \n fee: value.zero(),  \n mint: value.to_minted_value(burn_value),  \n certificates: [],  \n withdrawals: dict.new(),  \n validity_range: interval.everything(),  \n extra_signatories: [],  \n redeemers: dict.new(),  \n datums: dict.new(),  \n id: TransactionId {  \n hash: #\"2c6dbc95c1e96349c4131a9d19b029362542b31ffd2340ea85dd8f28e271ff6d\",  \n },  \n },  \n }  \n mint_validator(config, redeemer, context)  \n}  \n  \ntest mint_validator_insert() {  \n let own_cs = #\"746fa3ba2daded6ab9ccc1e39d3835aa1dfcb9b5a54acc2ebe6b79a4\"  \n let init_output_ref =  \n OutputReference {  \n transaction_id: TransactionId {  \n hash: #\"2c6dbc95c1e96349c4131a9d19b029362542b31ffd2340ea85dd8f28e271ff6d\",  \n },  \n output_index: 1,  \n }  \n let config =  \n Config {  \n init_utxo: init_output_ref,  \n deadline: 86_400_000,  \n penalty_address: Address(credential.ScriptCredential(\"P\"), None),  \n }  \n let user1_pkh =  \n bytearray.from_string(  \n @\"a65ca58a4e9c755fa830173d2a5caed458ac0c73f97db7faae2e7e3b\",  \n )  \n let covering_tn =  \n \"FSNa65ca58a4e9c755fa830173d2a5caed458ac0c73f97db7faae2e7e3b\"  \n let user2_pkh =  \n bytearray.from_string(  \n @\"e18d73505be6420225ed2a42c8e975e4c6f9148ab38e951ea2572e54\",  \n )  \n let insert_tn = \"FSNe18d73505be6420225ed2a42c8e975e4c6f9148ab38e951ea2572e54\"  \n let covering_minted_value = value.add(value.zero(), own_cs, covering_tn, 1)  \n let covering_node_value =  \n value.add(  \n covering_minted_value,  \n value.ada_policy_id,  \n value.ada_asset_name,  \n 9_000_000,  \n )  \n let covering_node = SetNode { key: Key { key: user1_pkh }, next: Empty }  \n let covering_output =  \n Output {  \n address: Address(credential.ScriptCredential(\"I\"), None),  \n value: covering_node_value,  \n datum: InlineDatum(covering_node),  \n reference_script: None,  \n }  \n let covering_output_ref =  \n OutputReference {  \n transaction_id: TransactionId { hash: #\"\" },  \n output_index: 1,  \n }  \n let out_prev_node =  \n SetNode { key: covering_node.key, next: Key { key: user2_pkh } }  \n  \n let out_prev_node_output =  \n Output {  \n address: Address(credential.ScriptCredential(\"I\"), None),  \n value: covering_node_value,  \n datum: InlineDatum(out_prev_node),  \n reference_script: None,  \n }  \n let out_node =  \n SetNode { key: Key { key: user2_pkh }, next: covering_node.next }  \n let insert_minted_value = value.add(value.zero(), own_cs, insert_tn, 1)  \n let out_node_output =  \n Output {  \n address: Address(credential.ScriptCredential(\"I\"), None),  \n value: value.add(  \n insert_minted_value,  \n value.ada_policy_id,  \n value.ada_asset_name,  \n 9_000_000,  \n ),  \n datum: InlineDatum(out_node),  \n reference_script: None,  \n }  \n let redeemer = Insert { key_to_insert: user2_pkh, covering_node }  \n let insert_timerange =  \n Interval {  \n lower_bound: IntervalBound {  \n bound_type: Finite(1000),  \n is_inclusive: False,  \n },  \n upper_bound: IntervalBound {  \n bound_type: Finite(2000),  \n is_inclusive: False,  \n },  \n }  \n let context =  \n ScriptContext {  \n purpose: Mint(own_cs),  \n transaction: Transaction {  \n inputs: [  \n Input {  \n output_reference: covering_output_ref,  \n output: covering_output,  \n },  \n ],  \n reference_inputs: [],  \n outputs: [out_prev_node_output, out_node_output],  \n fee: value.zero(),  \n mint: value.to_minted_value(insert_minted_value),  \n certificates: [],  \n withdrawals: dict.new(),  \n validity_range: insert_timerange,  \n extra_signatories: [user2_pkh],  \n redeemers: dict.new(),  \n datums: dict.new(),  \n id: TransactionId {  \n hash: #\"2c6dbc95c1e96349c4131a9d19b029362542b31ffd2340ea85dd8f28e271ff6d\",  \n },  \n },  \n }  \n mint_validator(config, redeemer, context)  \n}  \n  \ntest mint_validator_remove() {  \n let own_cs = #\"746fa3ba2daded6ab9ccc1e39d3835aa1dfcb9b5a54acc2ebe6b79a4\"  \n let init_output_ref =  \n OutputReference {  \n transaction_id: TransactionId {  \n hash: #\"2c6dbc95c1e96349c4131a9d19b029362542b31ffd2340ea85dd8f28e271ff6d\",  \n },  \n output_index: 1,  \n }  \n let config =  \n Config {  \n init_utxo: init_output_ref,  \n deadline: 86_400_000,  \n penalty_address: Address(credential.ScriptCredential(\"P\"), None),  \n }  \n let user1_pkh =  \n bytearray.from_string(  \n @\"a65ca58a4e9c755fa830173d2a5caed458ac0c73f97db7faae2e7e3b\",  \n )  \n let covering_tn =  \n \"FSNa65ca58a4e9c755fa830173d2a5caed458ac0c73f97db7faae2e7e3b\"  \n let user2_pkh =  \n bytearray.from_string(  \n @\"e18d73505be6420225ed2a42c8e975e4c6f9148ab38e951ea2572e54\",  \n )  \n let user2_tn = \"FSNe18d73505be6420225ed2a42c8e975e4c6f9148ab38e951ea2572e54\"  \n let covering_minted_value = value.add(value.zero(), own_cs, covering_tn, 1)  \n let covering_node_value =  \n value.add(  \n covering_minted_value,  \n value.ada_policy_id,  \n value.ada_asset_name,  \n 9_000_000,  \n )  \n let covering_node =  \n SetNode { key: Key { key: user1_pkh }, next: Key { key: user2_pkh } }  \n let covering_output =  \n Output {  \n address: Address(credential.ScriptCredential(\"I\"), None),  \n value: covering_node_value,  \n datum: InlineDatum(covering_node),  \n reference_script: None,  \n }  \n let covering_output_ref =  \n OutputReference {  \n transaction_id: TransactionId { hash: #\"\" },  \n output_index: 1,  \n }  \n let remove_output_ref =  \n OutputReference {  \n transaction_id: TransactionId { hash: #\"\" },  \n output_index: 1,  \n }  \n let remove_node = SetNode { key: Key { key: user2_pkh }, next: Empty }  \n let user2_value = value.add(value.zero(), own_cs, user2_tn, 1)  \n let remove_node_output =  \n Output {  \n address: Address(credential.ScriptCredential(\"I\"), None),  \n value: value.add(  \n user2_value,  \n value.ada_policy_id,  \n value.ada_asset_name,  \n 9_000_000,  \n ),  \n datum: InlineDatum(remove_node),  \n reference_script: None,  \n }  \n let output_node = SetNode { key: covering_node.key, next: remove_node.next }  \n let out_node_output =  \n Output {  \n address: Address(credential.ScriptCredential(\"I\"), None),  \n value: covering_node_value,  \n datum: InlineDatum(output_node),  \n reference_script: None,  \n }  \n let remove_burn_value = value.add(value.zero(), own_cs, user2_tn, -1)  \n let cover_node = SetNode { key: Key { key: user1_pkh }, next: Empty }  \n let redeemer = Remove { key_to_remove: user2_pkh, covering_node: cover_node }  \n let remove_timerange =  \n Interval {  \n lower_bound: IntervalBound {  \n bound_type: Finite(1000),  \n is_inclusive: False,  \n },  \n upper_bound: IntervalBound {  \n bound_type: Finite(2000),  \n is_inclusive: False,  \n },  \n }  \n let context =  \n ScriptContext {  \n purpose: Mint(own_cs),  \n transaction: Transaction {  \n inputs: [  \n Input {  \n output_reference: remove_output_ref,  \n output: remove_node_output,  \n },  \n Input {  \n output_reference: covering_output_ref,  \n output: covering_output,  \n },  \n ],  \n reference_inputs: [],  \n outputs: [out_node_output],  \n fee: value.zero(),  \n mint: value.to_minted_value(remove_burn_value),  \n certificates: [],  \n withdrawals: dict.new(),  \n validity_range: remove_timerange,  \n extra_signatories: [user2_pkh],  \n redeemers: dict.new(),  \n datums: dict.new(),  \n id: TransactionId {  \n hash: #\"2c6dbc95c1e96349c4131a9d19b029362542b31ffd2340ea85dd8f28e271ff6d\",  \n },  \n },  \n }  \n mint_validator(config, redeemer, context)  \n}`\n\n### Library[​](#library \"Direct link to Library\")\n\n#### Constants[​](#constants \"Direct link to Constants\")\n\n`pub const origin_node_token_name = \"FSN\"  \n  \npub const set_node_prefix = \"FSN\"`\n\n#### Linked List[​](#linked-list-1 \"Direct link to Linked List\")\n\n`use aiken/bytearray  \nuse aiken/interval.{Interval}  \nuse aiken/list  \nuse aiken/transaction.{Output}  \nuse aiken/transaction/value.{lovelace_of}  \nuse linkedlist/constants  \nuse linkedlist/types.{Common, Config, Empty, POSIXTime, PubKeyHash, SetNode}  \nuse linkedlist/utils  \n  \npub fn init(common: Common) -> Bool {  \n let must_spend_nodes = list.length(common.node_inputs) == 0  \n let must_exactly_one_node_output = list.length(common.node_outputs) == 1  \n let must_mint_correctly =  \n utils.validate_mint(  \n common.mint,  \n common.own_cs,  \n constants.origin_node_token_name,  \n 1,  \n )  \n must_spend_nodes? && must_exactly_one_node_output? && must_mint_correctly?  \n}  \n  \npub fn deinit(common: Common) -> Bool {  \n expect [head_node] = common.node_inputs  \n expect Empty = head_node.node.next  \n let must_not_produce_node_output = list.length(common.node_outputs) == 0  \n let must_burn_correctly =  \n utils.validate_mint(  \n common.mint,  \n common.own_cs,  \n constants.origin_node_token_name,  \n -1,  \n )  \n must_not_produce_node_output? && must_burn_correctly?  \n}  \n  \npub fn insert(common: Common, insert_key: PubKeyHash, node: SetNode) -> Bool {  \n let must_cover_inserting_key = utils.cover_key(node, insert_key)  \n expect [covering_node] = common.node_inputs  \n let prev_node_datum = utils.as_predecessor_of(node, insert_key)  \n let node_datum = utils.as_successor_of(insert_key, node)  \n let must_has_datum_in_output =  \n list.any(  \n common.node_outputs,  \n fn(node_pair) { node_datum == node_pair.node },  \n )  \n let must_correct_node_output =  \n list.any(  \n common.node_outputs,  \n fn(node_pair) {  \n covering_node.val == node_pair.val && prev_node_datum == node_pair.node  \n },  \n )  \n  \n let must_mint_correct =  \n utils.validate_mint(  \n common.mint,  \n common.own_cs,  \n bytearray.concat(constants.origin_node_token_name, insert_key),  \n 1,  \n )  \n must_cover_inserting_key? && must_has_datum_in_output? && must_correct_node_output? && must_mint_correct?  \n}  \n  \npub fn remove(  \n common: Common,  \n range: Interval<POSIXTime>,  \n disc_config: Config,  \n outs: List<Output>,  \n sigs: List<PubKeyHash>,  \n remove_key: PubKeyHash,  \n node: SetNode,  \n) -> Bool {  \n let must_cover_remove_key = utils.cover_key(node, remove_key)  \n let prev_node_datum = utils.as_predecessor_of(node, remove_key)  \n let node_datum = utils.as_successor_of(remove_key, node)  \n let must_spend_two_nodes = list.length(common.node_inputs) == 2  \n expect Some(stay_node) =  \n list.find(common.node_inputs, fn(input) { prev_node_datum == input.node })  \n expect Some(remove_node) =  \n list.find(common.node_inputs, fn(input) { node_datum == input.node })  \n let remove_token_name =  \n bytearray.concat(constants.origin_node_token_name, remove_key)  \n let must_correct_node_output =  \n list.any(  \n common.node_outputs,  \n fn(node_pair) { stay_node.val == node_pair.val && node == node_pair.node },  \n )  \n let must_mint_correct =  \n utils.validate_mint(common.mint, common.own_cs, remove_token_name, -1)  \n let must_sign_by_user = list.has(sigs, remove_key)  \n let own_input_lovelace = lovelace_of(remove_node.val)  \n let own_input_fee = utils.div_ceil(own_input_lovelace, 4)  \n let disc_deadline = disc_config.deadline  \n let must_satisfy_removal_broke_phase_rules =  \n if interval.is_entirely_before(range, disc_deadline) {  \n True  \n } else {  \n list.any(  \n outs,  \n fn(out) {  \n out.address == disc_config.penalty_address && own_input_fee < lovelace_of(  \n out.value,  \n )  \n },  \n )  \n }  \n must_cover_remove_key? && must_spend_two_nodes? && must_correct_node_output? && must_mint_correct? && must_sign_by_user? && must_satisfy_removal_broke_phase_rules?  \n}`\n\n#### Types[​](#types \"Direct link to Types\")\n\n`use aiken/hash.{Blake2b_224, Hash}  \nuse aiken/transaction.{OutputReference}  \nuse aiken/transaction/credential.{Address, VerificationKey}  \nuse aiken/transaction/value.{AssetName, PolicyId, Value}  \n  \n/// A number of milliseconds since 00:00:00 UTC on 1 January 1970.  \npub type POSIXTime =  \n Int  \n  \npub type AssetClass {  \n policy_id: PolicyId,  \n asset_name: AssetName,  \n}  \n  \npub type PubKeyHash =  \n Hash<Blake2b_224, VerificationKey>  \n  \npub type Config {  \n init_utxo: OutputReference,  \n deadline: POSIXTime,  \n penalty_address: Address,  \n}  \n  \npub type NodeKey {  \n Key { key: PubKeyHash }  \n Empty  \n}  \n  \npub type SetNode {  \n key: NodeKey,  \n next: NodeKey,  \n}  \n  \npub type NodePair {  \n val: Value,  \n node: SetNode,  \n}  \n  \npub type Common {  \n own_cs: PolicyId,  \n mint: Value,  \n node_inputs: List<NodePair>,  \n node_outputs: List<NodePair>,  \n}  \n  \npub type NodeAction {  \n Init  \n Deinit  \n Insert { key_to_insert: PubKeyHash, covering_node: SetNode }  \n Remove { key_to_remove: PubKeyHash, covering_node: SetNode }  \n}`\n\n### Utilities[​](#utilities \"Direct link to Utilities\")\n\n`use aiken/bytearray  \nuse aiken/dict.{has_key}  \nuse aiken/interval.{Interval}  \nuse aiken/list  \nuse aiken/transaction.{  \n InlineDatum, Input, Mint, Output, ScriptContext, Transaction,  \n}  \nuse aiken/transaction/value.{  \n AssetName, PolicyId, Value, flatten, from_minted_value, to_dict, tokens,  \n}  \nuse linkedlist/constants.{set_node_prefix}  \nuse linkedlist/types.{  \n Common, Empty, Key, NodePair, POSIXTime, PubKeyHash, SetNode,  \n}  \n  \npub fn validate_mint(  \n mints: Value,  \n expected_minting_policy: ByteArray,  \n expected_minting_name: ByteArray,  \n expected_minting_amt: Int,  \n) -> Bool {  \n let mints_policy = dict.to_list(value.tokens(mints, expected_minting_policy))  \n mints_policy == [(expected_minting_name, expected_minting_amt)]  \n}  \n  \npub fn cover_key(node: SetNode, insert_key: PubKeyHash) -> Bool {  \n let less_than_key =  \n when node.key is {  \n Empty -> True  \n Key(key) -> bytearray.compare(key, insert_key) == Less  \n }  \n let more_than_key =  \n when node.next is {  \n Empty -> True  \n Key(key) -> bytearray.compare(key, insert_key) == Greater  \n }  \n less_than_key? && more_than_key?  \n}  \n  \npub fn as_predecessor_of(node: SetNode, next_key: PubKeyHash) -> SetNode {  \n SetNode { key: node.key, next: Key(next_key) }  \n}  \n  \npub fn as_successor_of(prev_key: PubKeyHash, node: SetNode) -> SetNode {  \n SetNode { key: Key(prev_key), next: node.next }  \n}  \n  \npub fn div_ceil(a, b: Int) -> Int {  \n let div = a / b  \n let rem = a % b  \n when rem is {  \n 0 -> div  \n _ -> div + 1  \n }  \n}  \n  \npub fn make_common(  \n ctx: ScriptContext,  \n) -> (Common, List<Input>, List<Output>, List<PubKeyHash>, Interval<POSIXTime>) {  \n expect ScriptContext {  \n transaction: Transaction {  \n inputs,  \n outputs,  \n mint,  \n validity_range,  \n extra_signatories,  \n ..  \n },  \n purpose: Mint(own_cs),  \n } = ctx  \n let in_outputs = get_outputs(inputs)  \n let from_node_val = only_at_node_val(in_outputs, own_cs)  \n let to_node_val = only_at_node_val(outputs, own_cs)  \n expect Some(head) = list.head(list.concat(from_node_val, to_node_val))  \n let Output { address: node_address, .. } = head  \n expect  \n from_node_val  \n |> list.concat(to_node_val)  \n |> list.reduce(  \n True,  \n fn(acc, cur_node) {  \n let Output { address: cur_address, .. } = cur_node  \n and {  \n cur_address == node_address,  \n acc,  \n }  \n },  \n )  \n let node_inputs = list.map(from_node_val, node_input_utxo_datum_unsafe)  \n let node_outputs =  \n list.map(to_node_val, fn(node) { parse_node_output_utxo(own_cs, node) })  \n let common =  \n Common { own_cs, mint: from_minted_value(mint), node_inputs, node_outputs }  \n (common, inputs, outputs, extra_signatories, validity_range)  \n}  \n  \n// Checks if a Currency Symbol is held within a Value  \npub fn has_data_cs(cs: PolicyId, value: Value) -> Bool {  \n value  \n |> to_dict()  \n |> has_key(cs)  \n}  \n  \npub fn get_outputs(inputs: List<Input>) -> List<Output> {  \n list.map(  \n inputs,  \n fn(input) {  \n let Input { output, .. } = input  \n output  \n },  \n )  \n}  \n  \npub fn only_at_node_val(outputs: List<Output>, cs: PolicyId) -> List<Output> {  \n outputs  \n |> list.filter(  \n fn(output) {  \n let Output { value, .. } = output  \n has_data_cs(cs, value)  \n },  \n )  \n}  \n  \npub fn node_input_utxo_datum_unsafe(output: Output) -> NodePair {  \n expect Output { value, datum: InlineDatum(raw_node), .. } = output  \n expect node: SetNode = raw_node  \n NodePair { val: value, node }  \n}  \n  \npub fn parse_node_output_utxo(cs: PolicyId, output: Output) -> NodePair {  \n expect Output { value, datum: InlineDatum(raw_node), .. } = output  \n expect node: SetNode = raw_node  \n expect [(tn, amount)] =  \n value  \n |> tokens(cs)  \n |> dict.to_list()  \n expect amount == 1  \n let node_key = parse_node_key(tn)  \n let datum_key =  \n when node.key is {  \n Empty -> None  \n Key(key) -> Some(key)  \n }  \n expect node_key == datum_key  \n expect list.length(flatten(value)) == 2  \n expect valid_node(node)  \n expect find_cs_by_token_prefix(value, set_node_prefix) == [cs]  \n NodePair { val: value, node }  \n}  \n  \npub fn parse_node_key(tn: AssetName) -> Option<ByteArray> {  \n let prefix_length = bytearray.length(set_node_prefix)  \n let tn_length = bytearray.length(tn)  \n let key = bytearray.drop(tn, prefix_length)  \n expect set_node_prefix == bytearray.take(tn, prefix_length)  \n when prefix_length < tn_length is {  \n True -> Some(key)  \n False -> None  \n }  \n}  \n  \npub fn valid_node(node: SetNode) -> Bool {  \n when node.key is {  \n Empty -> True  \n Key(node_key) ->  \n when node.next is {  \n Empty -> True  \n Key(next_key) -> bytearray.compare(node_key, next_key) == Less  \n }  \n }  \n}  \n  \npub fn find_cs_by_token_prefix(  \n value: Value,  \n prefix: ByteArray,  \n) -> List<PolicyId> {  \n value  \n |> flatten  \n |> list.filter_map(  \n fn(input: (PolicyId, ByteArray, Int)) -> Option<PolicyId> {  \n let (cs, tn, _amt) = input  \n if is_prefix_of(prefix, tn) {  \n Some(cs)  \n } else {  \n None  \n }  \n },  \n )  \n}  \n  \npub fn is_prefix_of(prefix: ByteArray, src: ByteArray) -> Bool {  \n let prefix_length = bytearray.length(prefix)  \n let src_length = bytearray.length(src)  \n when prefix_length <= src_length is {  \n True -> bytearray.take(src, prefix_length) == prefix  \n False -> False  \n }  \n}`\n\n## Case study[​](#case-study \"Direct link to Case study\")\n\nLinked list can be leveraged in smart contract applications where the order of inputs is not crucial, and multiple users can interact with the contracts simultaneously. For example, consider a decentralized voting system where users can cast their votes concurrently. A linked list data structure can be employed to store and manage the votes efficiently. Each user's vote can be represented as a node in the linked list, containing relevant information such as the user's address and their chosen candidate.\n\n## Acknowledgments[​](#acknowledgments \"Direct link to Acknowledgments\")\n\nThis documentation and the implementation of the Aiken Linked List draw inspiration from an original idea presented in the Plutonomicon. We acknowledge the innovative concepts and approaches outlined in their work, specifically regarding associative data structures on blockchain platforms.\n\nFor further details on the foundational ideas and their context, please refer to the Plutonomicon's overview of associative data structures: [Plutonomicon's Associative Data Structures Overview](https://github.com/Plutonomicon/plutonomicon/blob/main/assoc.md#overview).\n\nWe express our gratitude to the creators and contributors of the Plutonomicon for their pioneering work in this area, which has significantly influenced the development of our Aiken Linked List.",
  "images": [],
  "extraction_metadata": {
    "batch_number": 11,
    "extraction_timestamp": "2025-09-19T14:05:12.534540",
    "extraction_time": 3.978458881378174,
    "source": "tavily_api_raw"
  }
}