{
  "url": "https://developers.cardano.org/docs/smart-contracts/smart-contract-languages/plutarch/production-grade-dapps/single-asset-staking",
  "content": "![Cardano Logo](/img/cardano-black.svg)\n![Cardano Logo](/img/cardano-white.svg)\n\n# Single Asset Staking\n\n## Introduction[​](#introduction \"Direct link to Introduction\")\n\nSingle Asset Staking contracts facilitate collective staking of digital assets and distributing rewards among participants in a completely on-chain and trustless manner.\n\nAs the name suggests, it allows for a single asset, which can be any Cardano Native Fungible Token, to be staked to earn rewards. The reward itself can be any Cardano Native Fungible Token. The contracts are parameterized with `policyId` and `tokenName` (in addition to a few others) of stake token and reward token. This allows different projects conducting the Staking event to configure the contracts accordingly.\n\n`policyId`\n`tokenName`\n\nInstead of a fixed percentage based return, the staking reward obtained is not known beforehand. Because its determined by the total amount of assets staked till the end of the staking period and the total rewards locked before staking begins. Eligible participants are then given rewards propotional to their share of stake (`(userStake * totalRewards) / totalStake`).\n\n`(userStake * totalRewards) / totalStake`\n\nThe source code for these dApps can be found [here](https://github.com/Anastasia-Labs/single-asset-staking).\n\n## Overview[​](#overview \"Direct link to Overview\")\n\nAn interesting technical detail about this protocol is the use of an [on-chain association list](https://github.com/Plutonomicon/plutonomicon/blob/main/assoc.md). It maintains every unique public key's stake in a separate UTxO which points to the next stake UTxO. Every UTxO in the list will have `StakingSetNode` in its datum.\n\n`StakingSetNode`\n`data StakingSetNode = MkSetNode  \n { key :: StakingNodeKey -- owner wallet's PaymentPubKeyHash  \n , next :: StakingNodeKey -- next PaymentPubKeyHash in a list of lexicographically sorted key hashes  \n }  \n  \ndata StakingNodeKey = Key BuiltinByteString | Empty`\n\nThis sections provides you with the timeline of different phases involved in Single Asset Staking. With each phase further listing the order of actions which comprises it.\n\nActions which can be performed if user wishes to.\n\n## Deployment[​](#deployment \"Direct link to Deployment\")\n\nEverything begins here with the project configuring and setting up the Smart Contracts. Its only after the deployment phase is completed that users can begin staking. It comprises of below four actions that need to be performed.\n\n### Build Scripts[​](#build-scripts \"Direct link to Build Scripts\")\n\nThe contracts available from [Single Asset Staking](https://github.com/Anastasia-Labs/single-asset-staking) repository, require paramters configuring details of Staking event.\n\n### Deploy Reference Scripts[​](#deploy-reference-scripts \"Direct link to Deploy Reference Scripts\")\n\nThis step uses the applied validators obtained above to create a [Reference Script UTxO](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0033) for every validator. In order to easily identify a particular validator on-chain, a native minting policy is used in conjuction. It mints an NFT with the validator name and is made available inside the `RefUTxO`. This native minting policy allows minting for a very short duration of **thirty mintues** within which all the `RefUTxOs` must be created. All the `RefUTxOs` are sent to an `Always Fail Script` address ensuring they are immutable and locked forever.\n\n`RefUTxO`\n`RefUTxOs`\n`RefUTxOs`\n`Always Fail Script`\n\n### **Lock Rewards**[​](#lock-rewards \"Direct link to lock-rewards\")\n\nHere project locks the entire staking reward in `tokenHolderValidator`. The total reward amount will be distributed among participants in proportion to their stake. Locking of rewards beforehand gives high assurance to all the participants before they can begin staking. One percent of total reward amount is paid as protocol fees for facilitating staking.\n\n`tokenHolderValidator`\n\n### **Initialize Head Node**[​](#initialize-head-node \"Direct link to initialize-head-node\")\n\nThis marks the beginning of the association list which will contain all the stake by different participants as separate UTxOs. The first node of the list know as head node is created in this step.\n\nHead node differs from all the nodes in that its key is null. Every valid stake UTxO in the list has a unique \"Node Token\" which is minted by `stakingPolicy` at the time of its insertion. The token name is derived as `NODE_PREFIX (\"FSN\") + PaymentPubKeyHash` thereby making every node token unique. Head node just has `NODE_PREFIX` as the token name.\n\n`stakingPolicy`\n`NODE_PREFIX (\"FSN\") + PaymentPubKeyHash`\n`NODE_PREFIX`\n\n## User Participation[​](#user-participation \"Direct link to User Participation\")\n\nNow the Staking event is opened and users can participate by locking their stake in `stakingValidator` by updating the linked list. Before the stake is frozen, participants can choose to increase, decrease or remove their stake altogether.\n\n`stakingValidator`\n\n## Active Staking[​](#active-staking \"Direct link to Active Staking\")\n\nOnce stake is frozen (configured by parameter `freezeStake :: POSIXTime`), the active staking phase begins for which the participants will be earning rewards. This phase lasts till `endStaking :: POSIXTime` as decided by the project. During this period, new participants cannot enter nor can the old ones modify their stake. However, existing stakers can still get their stake back if they choose to, by paying 25% of their stake as penalty fee.\n\n`freezeStake :: POSIXTime`\n`endStaking :: POSIXTime`\n\n## Rewards Processing[​](#rewards-processing \"Direct link to Rewards Processing\")\n\nAfter the active staking phase has ended (after `endStaking :: POSIXTime`) comes the part where project processes and allocates rewards to its participants who staked till now.\n\n`endStaking :: POSIXTime`\n\nIts done by first calculating and saving the total amount staked on-chain. Then every participant's stake UTxO is updated to include rewards in it, in proportion to their stake. Reward calculation is given by the formula `(userStake * totalRewards) / totalStake`.\n\n`(userStake * totalRewards) / totalStake`\n\nFollowing sequence of on-chain actions elaborate further on how rewards processing mechanism works.\n\n### Initialize Commit Fold[​](#initialize-commit-fold \"Direct link to Initialize Commit Fold\")\n\nCommit Fold carries out the computation of total staked amount by going over all the linked list UTxOs one after the other in order. The current state of the computation, i.e. how far along the linked list it has summed and the current sum, is stored in a UTxO at `foldValidator`. This UTxO is uniquely identified with the presence of an NFT (`$FoldPolicy.CFold`) minted using `foldPolicy`. This initialization of commit UTxO is perfomed in this step.\n\n`foldValidator`\n`$FoldPolicy.CFold`\n`foldPolicy`\n\n### Complete Commit Fold[​](#complete-commit-fold \"Direct link to Complete Commit Fold\")\n\nHere one stake UTxO after another is used as reference input to calculate and update `totalStake` value in Commit Fold UTxO's datum. This is done till the end of list is not reached, at which point `next = null` in fold datum and `totalStake` is finally determined.\n\n`totalStake`\n`next = null`\n`totalStake`\n\nHead Node's stake is never taken into account.\n\n### Initialize Reward Fold[​](#initialize-reward-fold \"Direct link to Initialize Reward Fold\")\n\nNow that we have total staked amount available on-chain, we initialize the reward fold wherein a UTxO to `rewardValidator` is sent. This contains total reward amount obtained from UTxO locked at `Token Holder Validator` along with `totalRewardTokens` and `totalStake` in its datum. Additionally, it has `$RewardPolicy.RFold` NFT minted from `Reward Policy` which validates that the initialization is carried out accurately.\n\n`rewardValidator`\n`Token Holder Validator`\n`totalRewardTokens`\n`totalStake`\n`$RewardPolicy.RFold`\n`Reward Policy`\n\nNote: Upon undergoing rewards fold a UTxO has to pay 1 ADA folding fee.\n\n### Complete Reward Fold[​](#complete-reward-fold \"Direct link to Complete Reward Fold\")\n\nWith Reward Fold UTxO initialized with rewards and other essential information, rewards can be distributed into individual stake UTxO. This is similar to commit fold, with UTxO after head node being processed first and other UTxOs in the order they appear in list. Rewards fold gets concluded when `next = null` on processing the last UTxO of the list. Upon undergoing rewards fold a UTxO has to pay 1 ADA folding fee.\n\n`next = null`\n\nIf any reward tokens are left due to remainder from integer division in `(userStake * totalRewards) / totalStake`\n\n`(userStake * totalRewards) / totalStake`\n\n## Claim[​](#claim \"Direct link to Claim\")\n\nOnly after rewards are processed can the participants claim their stake and reward. They can do so by spending their stake UTxO from \"Staking Validator\" after signing transaction with private key belonging to the PaymentPubKeyHash as `key` in UTxO's datum.\n\n`key`\n\n### Project Reclaims Reward[​](#project-reclaims-reward \"Direct link to Project Reclaims Reward\")\n\nOnce the rewards are processed, project is free to claim any remaining project tokens left in \"Reward Fold UTxO\" along with any lovelaces present. They'll have to additionally burn \"$RewardPolicy.RFold\" token for this, which is only allowed when `next = null` i.e. all rewards are processed.\n\n`next = null`\n\n### Deinitialize Head Node[​](#deinitialize-head-node \"Direct link to Deinitialize Head Node\")\n\nThe project is also free to reclaim the Head Node with the \"minStake\" and lovelaces present in it. It can only be done after the reward fold is initiated (Reward Fold Token datum has `next == *head node's next*`), therefore ensuring no information is lost.\n\n`next == *head node's next*`\n\n## Offchain Implementation[​](#offchain-implementation \"Direct link to Offchain Implementation\")\n\nYou can find the entire offchain implementation complimenting this dApp [here](https://github.com/Anastasia-Labs/single-asset-staking-offchain).",
  "images": [],
  "extraction_metadata": {
    "batch_number": 12,
    "extraction_timestamp": "2025-09-19T14:05:17.156321",
    "extraction_time": 1.6163160800933838,
    "source": "tavily_api_raw"
  }
}