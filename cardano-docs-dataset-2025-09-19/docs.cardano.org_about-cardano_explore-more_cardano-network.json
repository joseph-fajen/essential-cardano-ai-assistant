{
  "url": "https://docs.cardano.org/about-cardano/explore-more/cardano-network",
  "content": "![Cardano logo](/assets/cardano-logo.svg)\n![Cardano logo](/assets/cardano-logo.svg)\n\n# Cardano network\n\nThe Cardano network is a technical infrastructure combining Cardano nodes and\ntheir interactions in one unified system. It consists of a collection\nof nodes that communicate with each other to maintain the distributed ledger.\nThese nodes are the actors on Cardano that validate blocks, add blocks to the\nchain, and distribute transactions.\n\nThe networking layer is the driving force for delivering information exchange\nrequirements, which includes new blocks diffusion and transaction information\nfor establishing a better data flow. Cardano nodes maintain connections with\npeers that have been chosen via a custom peer selection process.\n\nRead the following specifications for more details:\n\n## Data flow between and within nodes[​](#data-flow-between-and-within-nodes \"Direct link to Data flow between and within nodes\")\n\nTo understand how nodes communicate with each other, let’s suppose that node *A*\nis connected to node *B*. Then, the Ouroboros protocol schedules a node *N* to\ngenerate a new block in a given time slot. Depending on the location of nodes\n*A*, *B*, and *N* in the network topology, and whether a new block arrives first\nat *A* or *B*, node *A* can be either upstream or downstream of node *B*.\n\nA set of mini-protocols is used to enable communication between different nodes.\nEach mini-protocol implements a basic information exchange requirement, such as\ninforming peers of the latest block, sharing blocks as needed, or sharing new\ntransactions around the Cardano network. For connection purposes, mini-protocols\nare determined by the version of the network protocol. For example, there are\ntwo protocol suites: node-to-node and node-to-client. The node-to-client\nprotocol suite is used by wallets and chain consumers. Protocol suites use\ndifferent sets of mini-protocols and the version is negotiated when a new\nconnection is established using a specific protocol (protocols are described in\nthe following sections).\n\nClients can also choose which node-to-client mini-protocols to use, but it is\nimportant to note that the node needs to be able to reply to all of them to\nsupport different use cases. For example, to communicate, node A runs its\nclient-side instance of the *chain-sync mini-protocol* that talks with a server\ninstance of the *chain-sync mini-protocol* at node *B*. Such a situation is\nsimilar to the functionality of other mini-protocols.\n\nThe scheme below illustrates how data flows within a node. Circles represent\nprotocol threads and internal threads that are responsible for running the\nclient and server processes within the respective mini-protocols.\n\n![node_data_flow](/assets/images/node_data_flow-8161728b90a9190d24db7d0036f1db6e.jpg)\n\n![node_data_flow](/assets/images/node_data_flow-8161728b90a9190d24db7d0036f1db6e.jpg)\n\nTwo types of data flow exist:\n\n## Addressing network complexities and constraints[​](#addressing-network-complexities-and-constraints \"Direct link to Addressing network complexities and constraints\")\n\nTo design an efficient and robust networking architecture, a number of potential\nissues regarding complexity and constraints have been evaluated.\n\n**Congestion control** is one such feature and is used to deal with system\noverload. Congestion control is vital to ensure that the system is robust enough\nwhile operating high workloads. Within the networking design, it is common that\nthe number of transactions that occur can be higher than the number that can be\nactually processed for inclusion in the blockchain. Therefore, it is important\nto ensure that the increasing rate of transaction submission into a block does\nnot decrease the performance of blockchain.\n\nThe actual node has a limit to the amount of data it can process. In particular,\na node might have to share its processing power with other processes that run on\nthe same machine or operating system instance. This means that a node can slow\ndown and result in the system not being able to process all the available data\nfrom the network.\n\nTo address these issues, the congestion control feature has been designed to\noperate appropriately in such a situation and recover from transient conditions.\nIn any case, a node must not exceed its memory limits so there must be defined\nmemory limits, breaches of which are treated as protocol violations. These\nfactors mean that the system will be able to meet performance goals.\n\n**Real-time constraints** and **coordinated universal time** are other aspects\nthat have been considered while designing the networking architecture. In\nCardano, Ouroboros consensus protocols model the passage of physical time as an\ninfinite sequence of time slots, assigning slot leaders to create a new block in\nthose time slots. Choosing a slot time, however, might cause certain\ncomplexities in terms of the slot length, as it should be long enough for a new\nblock to have a good chance to reach the next slot leader in time. Therefore, a\nchosen value for the slot length was initially set to 20 seconds in the Byron\nera. With [Ouroboros Praos](https://eprint.iacr.org/2017/573.pdf)\nimplemented in the Shelley era, a slot length of 1 second is chosen but, on\naverage, only 0.05 of slots will produce a block (and thus on average, there\nwill be 20-second intervals between blocks). It is assumed that the clock skews\nbetween the local clocks of the nodes are small with respect to the slot length.\nPossible clock inaccuracies should still be taken into consideration, especially\nwhen dealing with time-stamped incoming blocks. It is important to differentiate\nwhether there is a time difference or whether the node considers an adversarial\nbehavior of another node.\n\n## Utilizing mini-protocols[​](#utilizing-mini-protocols \"Direct link to Utilizing mini-protocols\")\n\nMini-protocols are used to communicate between multiple nodes while implementing\ninformation exchange requirements. A mini-protocol is a defined modular building\nblock of the network protocol. Structuring the network protocol around mini-protocols helps to manage the overall complexity of the design while ensuring\nuseful flexibility.\n\nMini-protocols describe both the *initiator* and the *responder* within the\ncommunication stream. The initiator is the dual element of the responder and\nvice versa. A node typically runs many instances of mini-protocols, which\nincludes many instances of the same mini-protocol. Each mini-protocol instance\nof the node then communicates with the dual instance of the exact peer. All mini-protocols that communicate with the same peer share a single communication\nchannel (pipe or socket). A multiplexer or de-multiplexer is used to multiplex\nrespective protocols over that channel.\n\nThe set of mini-protocols that is used for connection between two participants\nof the system depends on the role of these participants, for instance, whether\nthe node acts as a full node or a blockchain consumer (for example, a wallet).\n\nIt is also worth noting that the implementation of mini-protocols uses a generic\nframework for **state machines**. This framework uses *correct-by-construction*\ntechniques to guarantee the implementation of several properties of the\nprotocol. In particular, this technique assures that no deadlocks occur and\ncommunication is canceled in the following scenarios:\n\nAll mini-protocols based on this framework include the following information in\ntheir description:\n\n## Example mini-protocols[​](#example-mini-protocols \"Direct link to Example mini-protocols\")\n\nThis section outlines some examples of mini-protocols.\n\n### Ping pong protocol[​](#ping-pong-protocol \"Direct link to Ping pong protocol\")\n\nThis is a simple protocol for testing that a client can use to check that the\nserver is responsive. The ping pong protocol is very simple because the messages\ndo not carry any data and the ping pong client, as well as the ping pong server,\ndo not access the internal state of the node.\n\n### Request response protocol[​](#request-response-protocol \"Direct link to Request response protocol\")\n\nThe request response protocol is polymorphic in the request and response data\nthat is being transmitted. This means that there are different possible\napplications of this protocol and the application of the protocol determines the\ntypes of requests sent and responses received.\n\n### Chain synchronization protocol[​](#chain-synchronization-protocol \"Direct link to Chain synchronization protocol\")\n\nThe chain synchronization protocol is used by a blockchain consumer to replicate\nthe producer’s blockchain locally. A node communicates with several upstream and\ndownstream nodes and runs an independent client instance and an independent\nserver instance for each node with which it communicates.\n\nThe chain synchronization protocol is polymorphic. The node-to-client protocol\nuses an instance of the chain synchronization protocol that transfers full\nblocks, while the node-to-node instance only transfers block headers. In the\nnode-to-node scenario, the block fetch protocol is used to transfer full blocks.\n\n### Block fetch protocol[​](#block-fetch-protocol \"Direct link to Block fetch protocol\")\n\nThe block-fetching protocol enables a node to download a range of blocks.\n\n### Local transaction submission mini-protocol[​](#local-transaction-submission-mini-protocol \"Direct link to Local transaction submission mini-protocol\")\n\nThe local transaction submission mini-protocol is used by local clients, for\nexample, wallets or CLI tools, to submit transactions to a local node. The\nprotocol is not used to forward transactions from one core node to another. The\nprotocol follows a simple request-response pattern:\n\n### Node-to-node transaction submission protocol[​](#node-to-node-transaction-submission-protocol \"Direct link to Node-to-node transaction submission protocol\")\n\nThe node-to-node transaction submission protocol is used to transfer\ntransactions between full nodes. The protocol follows a pull-based strategy\nwhere the initiator asks for new transactions and the responder replies with\ntransactions. It is suitable for a trustless setting where both sides need to\nguard against resource consumption attacks from the other side. The\nimplementation of the node-to-node transaction mini-protocol is based on a\ngeneric mini-protocol framework (the same as for all other mini-protocols). For\ntechnical reasons, the roles of the initiator and the responder are reversed in\nthis case compared to the way other mini-protocols are implemented in the\nframework. In other words, the server is the initiator who requests new\ntransactions, and the client is the responder who replies with transactions.\n\n### Handshake mini-protocol[​](#handshake-mini-protocol \"Direct link to Handshake mini-protocol\")\n\nThe handshake mini-protocol is used to negotiate the protocol version and the\nprotocol parameters that are used by the client and the server. It is used first\nwhen a new connection is initialized and consists of a single request from the\nclient and a single reply from the server. The handshake mini-protocol is a\ngeneric protocol that can negotiate any kind of protocol parameters. It assumes\nthat protocol parameters can be encoded to, and decoded from Concise Binary\nObject Representation (CBOR) terms. A node that runs the handshake protocol must\ninstantiate it with the set of supported protocol versions and callback\nfunctions for handling the protocol parameters. These callback functions are\nspecific to the supported protocol versions.\n\n![Cardano Logo](/assets/cardano-logo-blue.svg)\n![Cardano Logo](/assets/cardano-logo.svg)\n\nCardano is an open-source project. Cardano is a software platform ONLY and does not conduct any independent diligence on, or substantive review of, any blockchain asset, digital currency, cryptocurrency or associated funds. You are fully and solely responsible for evaluating your investments, for determining whether you will exchange blockchain assets based on your own judgement, and for all your decisions as to whether to exchange blockchain assets with Cardano. In many cases, blockchain assets you exchange on the basis of your research may not increase in value, and may decrease in value. Similarly, blockchain assets you exchange on the basis of your research may fall or rise in value after your exchange. Past performance is not indicative of future results. Any investment in blockchain assets involves the risk of loss of part or all of your investment. The value of the blockchain assets you exchange is subject to market and other investment risks.\n\nThis work is licensed under CC BY 4.0\n\n© IOHK 2015-2025 - IOHK Supported Project",
  "images": [],
  "extraction_metadata": {
    "batch_number": 1,
    "extraction_timestamp": "2025-09-19T13:29:04.354369",
    "extraction_time": 1.501661777496338,
    "source": "tavily_api_raw"
  }
}