{
  "batch_number": 1,
  "urls": [
    "https://docs.cardano.org/",
    "https://docs.cardano.org/about-cardano/contributions",
    "https://docs.cardano.org/about-cardano/evolution/about-hard-forks",
    "https://docs.cardano.org/about-cardano/evolution/cardano-design-rationale",
    "https://docs.cardano.org/about-cardano/evolution/eras-and-phases",
    "https://docs.cardano.org/about-cardano/evolution/upgrades/allegra",
    "https://docs.cardano.org/about-cardano/evolution/upgrades/alonzo",
    "https://docs.cardano.org/about-cardano/evolution/upgrades/byron-to-shelley",
    "https://docs.cardano.org/about-cardano/evolution/upgrades/chang",
    "https://docs.cardano.org/about-cardano/evolution/upgrades/mary",
    "https://docs.cardano.org/about-cardano/evolution/upgrades/valentine",
    "https://docs.cardano.org/about-cardano/evolution/upgrades/vasil",
    "https://docs.cardano.org/about-cardano/explore-more/cardano-architecture",
    "https://docs.cardano.org/about-cardano/explore-more/cardano-network",
    "https://docs.cardano.org/about-cardano/explore-more/cardano-network/networking-protocol"
  ],
  "extraction_time": 1.9533109664916992,
  "timestamp": "2025-09-29T13:36:02.262771",
  "response": {
    "results": [
      {
        "url": "https://docs.cardano.org/about-cardano/evolution/about-hard-forks",
        "raw_content": "# About hard forks\n\nThe term *hard fork* describes a radical change in the blockchain: a change from one protocol to another, for example. In most blockchains, a hard fork indicates block changes or a change to their interpretation.\n\nTraditionally, when conducting a hard fork, the current protocol would stop operating, new rules and changes would be implemented, and the chain would restart. It is important to note that a hard-forked chain *will be different* from the previous version and that the history of the pre-forked blockchain will no longer be available.\n\nThe Cardano blockchain hard forked from a Byron federated model to a Shelley decentralized one in 2020. However, this hard fork was unique. Instead of implementing radical changes, Cardano ensured a smooth transition to a new protocol while saving the history of the previous blocks. This means that the chain did not change *radically*, instead, it contained Byron blocks, and after a transition period, added Shelley blocks. There was no fundamental restart point that erased the history of previous activities.\n\n## What is a hard fork combinator?[​](#what-is-a-hard-fork-combinator \"Direct link to What is a hard fork combinator?\")\n\nA combinator is a technical term used to indicate the combination of certain processes or things. In the case of Cardano, a hard fork combinator combines protocols, thereby enabling the [era-to-era transition](https://iohk.io/en/blog/posts/2020/04/29/from-byron-to-shelley-part-one-the-testnets/) without system interruption or restart. It ensured that Byron and Shelley ledgers appeared as *one* ledger. Shifting from [Ouroboros BFT](https://eprint.iacr.org/2018/1049.pdf) to [Ouroboros Praos](https://iohk.io/en/research/library/papers/ouroboros-praosan-adaptively-securesemi-synchronous-proof-of-stake-protocol/) did not require all nodes to update simultaneously. Instead, nodes could update gradually, in fact, some could run Byron blocks, while others could run Shelley blocks.\n\nThe hard fork combinator is designed to enable the combination of several protocols, without having to make significant adjustments.\n\nRead more about Cardano's upgrades in the following section.\n\nOn this page\n\n* [What is a hard fork combinator?](#what-is-a-hard-fork-combinator)\n\n ",
        "images": []
      },
      {
        "url": "https://docs.cardano.org/about-cardano/evolution/cardano-design-rationale",
        "raw_content": "Opens in a new window Opens an external website Opens an external website in a new window\n\nThis website utilizes technologies such as cookies to enable essential site functionality, as well as for analytics, personalization, and targeted advertising. To learn more, view the following link:    [Privacy Policy](https://static.iohk.io/terms/iog-privacy-policy.pdf)[Cookie Policy](https://static.iohk.io/terms/iog-cookie-policy.pdf)\n\n[Skip to main content](#__docusaurus_skipToContent_fallback)\n\n# Design rationale\n\n[Cardano](https://cardano.org/) is an open source\n[proof-of-stake](/about-cardano/new-to-cardano/proof-of-stake) blockchain\nproject that began in 2015 to address existing blockchain challenges in the\ndesign and development of cryptocurrencies. It aims to provide a more balanced\nand sustainable ecosystem that better accounts for the needs of its users as\nwell as other systems seeking integration.\n\nThe first generation of blockchains (like Bitcoin) offered decentralized ledgers\nfor secure cryptocurrency transfer. However, such blockchains did not provide a\nfunctional environment for complex deal settlement and decentralized application\n(DApp) development. As blockchain technology matured, the second generation\n(like Ethereum) provided more enhanced solutions for writing and executing smart\ncontracts, application development, and the creation of different token types.\nOn the other hand, the second generation of blockchains often faces issues in\nterms of scalability.\n\nCardano is conceived as the third-generation blockchain as it combines the\nproperties of the prior generations and evolves to meet all the arising needs of\nusers. When comparing blockchain properties, many aspects should be considered.\nThus, the best solution must ensure the highest security, scalability\n(transaction throughput, data scale, network bandwidth), and functionality\n(besides transaction processing, the blockchain should provide all means for\nbusiness deal settlement). Moreover, it is important to ensure that blockchain\ntechnology is constantly developing in terms of sustainability and is\ninteroperable with other blockchains and financial institutions.\n\nTo address these needs, Cardano has been built focusing on such core concepts\nas:\n\n* **Scalability** – ensures that the Cardano network is capable of processing an\n  increasing number of transactions as user demand grows. Scalability also\n  provides higher bandwidth capabilities to allow transactions to carry a\n  significant amount of supportive data that can be easily managed within the\n  network. For these needs, Cardano is implementing various techniques (like\n  data compression for instance), and introduces such scaling solutions as\n  [Hydra](https://hydra.family/head-protocol/) and\n  [Mithril](https://mithril.network/doc/), for example. Read more about the\n  [research underpinning Cardano's scalability here](https://www.essentialcardano.io/article/an-analysis-of-the-research-underpinning-cardanos-scalability).\n* **Interoperability** – ensures the most multi-functional environment for\n  financial, business, or commercial operations by enabling users to interact\n  with different blockchain systems. Cardano aims to support cross-chain\n  transfers, multiple token types, and commonly used smart contract languages.\n  Read more about the concept of\n  [partner chains](https://iohk.io/en/blog/posts/2023/11/03/partner-chains-are-coming-to-cardano/).\n* **Sustainability** – designing a proof-of-stake blockchain means it is vital\n  to ensure that the system is self-sustainable. To drive growth and maturity in\n  a truly decentralized manner, Cardano is built to allow the community to\n  maintain its continuous development by participating, proposing, and\n  implementing system improvements. This is now being implemented through\n  [CIP-1694](https://cips.cardano.org/cip/CIP-1694) on-chain governance\n  mechanisms.\n\n## Cardano advantages[​](#cardano-advantages \"Direct link to Cardano advantages\")\n\n* **Academic research** – formal methods, such as mathematical specifications,\n  property-based tests, and proofs, are the best way to deliver high assurance\n  software systems and give confidence to users for the management of digital\n  funds. Cardano has been built using formal methods to achieve strong\n  guarantees on the functional correctness of core components of the system. All\n  of the research and technical specifications that underpin Cardano are\n  publicly available, and all Cardano development activity is published online.\n* **System design** – Cardano is written in Haskell, a secure functional\n  programming language that encourages building a system using pure functions,\n  which leads to a design where components are conveniently testable in\n  isolation. Advanced features of Haskell enable employing a whole range of\n  powerful methods for ensuring code correctness, such as basing the\n  implementation on formal and executable specifications, extensive\n  property-based testing, and running tests in simulation.\n* **Security** –\n  [Ouroboros](https://iohk.io/en/blog/posts/2020/06/23/the-ouroboros-path-to-decentralization/)\n  (the Cardano proof-of-stake protocol) establishes rigorous security\n  guarantees; it was delivered with several peer-reviewed papers presented in\n  top-tier conferences and publications in the area of cybersecurity and\n  cryptography.\n* **Energy efficiency** – Cardano is a proof-of-stake blockchain. In contrast to\n  proof-of-work blockchains,\n  [Cardano requires much less energy](https://iohk.io/en/blog/posts/2021/08/17/why-they-re-calling-cardano-the-green-blockchain/)\n  and computational power. The Bitcoin network is secured through computers\n  doing ever-more-energy-intensive computations – proof of work – which is\n  unsustainable in the long term. Cambridge University has an online tool that\n  shows the [computers powering Bitcoin](https://cbeci.org/) already consume\n  more electricity than some countries, like\n  [Switzerland](https://www.bfe.admin.ch/bfe/en/home/supply/statistics-and-geodata/energy-statistics/overall-energy-statistics.html)\n  for example.\n* **Seamless upgrades** – traditionally, blockchains upgrade using hard forks.\n  When conducting a hard fork, the current protocol would stop operating, new\n  rules and changes would be implemented, and the chain would restart – with its\n  previous history being erased. Cardano handles hard forks differently. Instead\n  of implementing radical changes, the Cardano\n  [hard fork combinator technology](https://iohk.io/en/blog/posts/2020/05/07/combinator-makes-easy-work-of-shelley-hard-fork/)\n  ensures a smooth transition to a new protocol while saving the history of the\n  previous blocks and not causing any disruptions for end users.\n* **Decentralization** – Cardano is maintained by over 3,000 distributed stake\n  pools that are operated by the community. All blocks and transactions are\n  validated by network participants without any reliance on a centralized\n  authority.\n* **Functional environment for business use cases** – Cardano is establishing a\n  foundation for global, decentralized finance to develop a range of DApps that\n  can run using functional and domain-specific smart contracts, providing\n  multi-asset tokens for any needs.\n\nOn this page\n\n* [Cardano advantages](#cardano-advantages)",
        "images": []
      },
      {
        "url": "https://docs.cardano.org/about-cardano/evolution/eras-and-phases",
        "raw_content": "Opens in a new window Opens an external website Opens an external website in a new window\n\nThis website utilizes technologies such as cookies to enable essential site functionality, as well as for analytics, personalization, and targeted advertising. To learn more, view the following link:    [Privacy Policy](https://static.iohk.io/terms/iog-privacy-policy.pdf)[Cookie Policy](https://static.iohk.io/terms/iog-cookie-policy.pdf)\n\n[Skip to main content](#__docusaurus_skipToContent_fallback)\n\n# Development phases and eras\n\ninfo\n\nThis overview is based on [CIP-59](https://cips.cardano.org/cip/CIP-0059).\n\nCardano’s development follows a well-defined and clearly communicated [roadmap](https://roadmap.cardano.org/en/). Firmly based on academic research and rigorous testing, this process has resulted in a chain with zero outages.\n\nCardano has gone through multiple development *phases and eras enabled by hard fork combinator events*. The following concepts are explained below:\n\n* **Development phase** – a high-level collection of features described on the [Cardano roadmap](https://roadmap.cardano.org/en/).\n* **Ledger era** – a collection of ledger features introduced with a hard fork. Starting with Alonzo, eras are planned to be named after mathematicians and computer scientists in *a, b,c* order.\n* **Intra-era hard fork** – a small and focused semantic change to the ledger requiring a hard fork.\n* **Consensus mechanism** – a collection of consensus features introduced with a hard fork. Historically, these have featured the name ‘Ouroboros’.\n* **Ledger protocol** – a collection of ledger features between the consensus layer and the ledger layer, roughly characterized by block header validation.\n\n## Development phases[​](#development-phases \"Direct link to Development phases\")\n\nCardano’s development phases include Byron, Shelley, Goguen, Basho, and Voltaire – all named after poets except for Goguen, a computer scientist.\n\n* **Byron**. Byron set the foundation for Cardano development allowing users to buy and sell ada on a proof-of-stake blockchain network. Initially, the Cardano ledger was established as a federated network, where block production and transaction validation were maintained by [the founding entities](https://www.essentialcardano.io/article/founding-and-iog-organization). Byron saw the delivery of [Daedalus](https://daedaluswallet.io/) and Yoroi wallets, and also provided users with a Block Explorer ‒ a tool specifically designed for browsing the blockchain.\n* **Shelley**. The Shelley development theme introduced a decentralized ledger creating a completely new economic system, which drives the network’s growth and gradual optimization. Shelley evolved from Byron’s federated network maintenance, with more and more blocks being produced by the distributed stake pool operator community. This theme focused on many critical steps that ensure enhanced user experience in terms of stake pool operation, delegation preferences, and incentives.\n* **Goguen**. Goguen development focused on the establishment of a global, financial, and multi-functional system for decentralized application (DApp) building, smart contract support, and custom token issuance. Goguen is a key building block to establish a versatile platform to build solutions around such application domains as supply chain, track and trace, finance, medical records, identity voting, property registration, P2P payments, and many others.\n* **Basho**. Basho focuses on Cardano’s optimization in terms of improving the scalability and interoperability of the network. Whereas other development stages focus on decentralization and new functionality, Basho is about improving the underlying performance of the Cardano network to better support growth and adoption for applications with high transaction volume.\n* **Voltaire**. Decentralized governance and decision making lie at the heart of Voltaire granting the Cardano community the ability to vote on network development updates, technical improvements, and project funding. For the Cardano network to become more decentralized, it requires not only the distributed infrastructure introduced during Shelley but also the capacity to be maintained and improved over time in a decentralized way.\n\n## Ledger eras[​](#ledger-eras \"Direct link to Ledger eras\")\n\nThere are several eras within the evolution of Cardano. Each era refers to the rules of the ledger. For example, what transaction types and what data is stored in the ledger, or the validity and meaning of the transactions.\n\n### Byron and Shelley eras[​](#byron-and-shelley-eras \"Direct link to Byron and Shelley eras\")\n\nThe evolution of the Cardano mainnet began with the Byron ledger rules. The mainnet underwent a hard fork in late July 2020 to switch from the Byron rules to the Shelley ledger rules. It was a full reimplementation of Cardano, which enabled two fundamental changes: the support for multiple sets of ledger rules, and the management of the hard fork process of switching from one set of rules to the next. In other words, the new implementation could support both the Byron rules and the Shelley rules, which meant that, when deployed to the mainnet in early 2020, the implementation was fully compatible with the Byron rules. This allowed for a smooth transition from the old to the new implementation. Once all Cardano users had upgraded their nodes to the new implementation, it became possible to invoke the hard fork combinator event and switch to the Shelley rules.\n\n### Allegra, Mary, and Alonzo eras[​](#allegra-mary-and-alonzo-eras \"Direct link to Allegra, Mary, and Alonzo eras\")\n\nAllegra, Mary, and Alonzo eras are all part of the *Goguen development phase.*\n\nStarting with Goguen, the ledger team introduced the notion of *era* into the ledger code. Shelley ledger rules then became ‘the Shelley era’.\n\nBecause Goguen features were implemented in steps, each set of functionality was introduced with a different hard fork, hence there were several ledger eras:\n\n* Allegra: introduced token locking support\n* Mary: brought native tokens and multi-asset functionality to Cardano\n* Alonzo: introduced smart contract support.\n\nThe names Allegra and Mary were chosen for their connection to the poet Percy Shelley and were only intended to be used as [variable names](https://github.com/input-output-hk/cardano-ledger/blob/1cbf1fc2bb005a8206e5b5a7cdf44d35baaca455/eras/shelley-ma/impl/src/Cardano/Ledger/Allegra.hs#L40) for a very specific abstraction used in the ledger code.\n\nGoguen, the smart contract development phase, was the only phase named not after a poet. So the name of the ledger era that introduced smart contracts was named after Alonzo Church – the person who invented the lambda calculus (Plutus Core uses a variant of [system F](https://en.wikipedia.org/wiki/System_F)).\n\nGoing forward, the teams decided to use names in *a,b,c* order, after individuals who contributed to mathematics and computer science. One lack of consistency to notice is that eras can use both first and last names. This is driven by conciseness.\n\n### Babbage era[​](#babbage-era \"Direct link to Babbage era\")\n\nThe Babbage ledger era introduced such features as inline datums, reference scripts, and reference inputs. However, the release is also known as *Vasil,* named to honor the late Bulgarian mathematician and Cardano ambassador Vasil Dabov.\n\n## Intra-era hard forks[​](#intra-era-hard-forks \"Direct link to Intra-era hard forks\")\n\nA new era *must* be introduced with a hard fork, but the ledger can also change semantics during a controlled hard fork with another mechanism – an intra-era hard fork. This is an implementation detail that involves bumping the major protocol version but not creating a new ledger era. The Alonzo era, for example, experienced an intra-era hard fork when going from major protocol version 5 to 6.\n\nYou can see a table with Cardano’s phases, eras, and intra-era hard forks visualized below:\n\nImage source: [CIP-59 Cardano features annex](https://github.com/cardano-foundation/CIPs/blob/master/CIP-0059/feature-table.md)\n\n## Conclusion[​](#conclusion \"Direct link to Conclusion\")\n\nIt is important to understand that not all of the semantic changes to the Cardano network involve the ledger. Changes to the consensus protocol or the networking layer may also require a hard fork. There is also an abstraction between the consensus and ledger layers, named the *protocol*. The distinction between the ledger protocols and the ledger eras corresponds roughly to how block headers are validated (protocol) versus how block bodies are validated (era). The Shelley era used the ‘transitional Praos’ protocol (TPraos), which consisted of Praos combined with a transition system to move away from Ouroboros BFT. The Babbage era replaced TPraos with Praos.\n\nNote that the protocol version is unrelated to the node-to-node and node-to-client protocol versions. The consensus layer maintains a versioning scheme for the node queries that does not necessarily align with the protocol version described in this overview.\n\nThe protocol version is also included in each block header indicating the maximum protocol version that the block producer is capable of supporting.\n\nOn this page\n\n* [Development phases](#development-phases)\n* [Ledger eras](#ledger-eras)\n  + [Byron and Shelley eras](#byron-and-shelley-eras)\n  + [Allegra, Mary, and Alonzo eras](#allegra-mary-and-alonzo-eras)\n  + [Babbage era](#babbage-era)\n* [Intra-era hard forks](#intra-era-hard-forks)\n* [Conclusion](#conclusion)",
        "images": []
      },
      {
        "url": "https://docs.cardano.org/about-cardano/evolution/upgrades/byron-to-shelley",
        "raw_content": "Byron to Shelley | Cardano Docs\n\n===============\n\nOpens in a new window Opens an external website Opens an external website in a new window\n\nThis website utilizes technologies such as cookies to enable essential site functionality, as well as for analytics, personalization, and targeted advertising. To learn more, view the following link: [Privacy Policy](https://static.iohk.io/terms/iog-privacy-policy.pdf)[Cookie Policy](https://static.iohk.io/terms/iog-cookie-policy.pdf)\n\nManage Preferences \n\n[Skip to main content](https://docs.cardano.org/about-cardano/evolution/upgrades/byron-to-shelley#__docusaurus_skipToContent_fallback)\n\n[![Image 1: Cardano logo](https://docs.cardano.org/assets/cardano-logo.svg)](https://docs.cardano.org/)[About](https://docs.cardano.org/about-cardano/introduction)[Developer resources](https://docs.cardano.org/developer-resources/welcome)[Stake pool operations](https://docs.cardano.org/stake-pool-operators/operating-a-stake-pool)[Testnets](https://docs.cardano.org/cardano-testnets/environments)[Education](https://docs.cardano.org/pioneer-programs/community-education)\n\n[Community](https://docs.cardano.org/about-cardano/evolution/upgrades/byron-to-shelley#)\n*   [Support](https://iohk.zendesk.com/hc/en-us/requests/new)\n*   [Essential Cardano](https://www.essentialcardano.io/)\n*   [Cardano Stack Exchange](https://cardano.stackexchange.com/)\n*   [Ambassadors program](https://cardano.org/ambassadors/)\n*   [Cardano Improvement Proposals (CIPs)](https://cips.cardano.org/)\n\n[Developer portal](https://developers.cardano.org/)[](https://github.com/input-output-hk/cardano-documentation)\n\nSearch...\n\n*   [Introduction](https://docs.cardano.org/about-cardano/introduction)\n*   [New to Cardano?](https://docs.cardano.org/about-cardano/new-to-cardano) \n*   [Learn](https://docs.cardano.org/about-cardano/evolution/upgrades/byron-to-shelley#) \n*   [Explore more](https://docs.cardano.org/about-cardano/evolution/upgrades/byron-to-shelley#) \n*   [Cardano evolution](https://docs.cardano.org/about-cardano/evolution/upgrades/byron-to-shelley#) \n    *   [Design rationale](https://docs.cardano.org/about-cardano/evolution/cardano-design-rationale)\n    *   [Development phases and eras](https://docs.cardano.org/about-cardano/evolution/eras-and-phases)\n    *   [About hard forks](https://docs.cardano.org/about-cardano/evolution/about-hard-forks)\n    *   [Upgrades explained](https://docs.cardano.org/about-cardano/evolution/upgrades/byron-to-shelley#) \n        *   [Byron to Shelley](https://docs.cardano.org/about-cardano/evolution/upgrades/byron-to-shelley)\n        *   [Allegra](https://docs.cardano.org/about-cardano/evolution/upgrades/allegra)\n        *   [Mary](https://docs.cardano.org/about-cardano/evolution/upgrades/mary)\n        *   [Alonzo](https://docs.cardano.org/about-cardano/evolution/upgrades/alonzo)\n        *   [Vasil](https://docs.cardano.org/about-cardano/evolution/upgrades/vasil)\n        *   [Valentine (SECP)](https://docs.cardano.org/about-cardano/evolution/upgrades/valentine)\n        *   [Chang](https://docs.cardano.org/about-cardano/evolution/upgrades/chang)\n\n*   [Governance overview](https://docs.cardano.org/about-cardano/governance-overview)\n*   [Contribution guidelines](https://docs.cardano.org/about-cardano/contributions)\n*   [Glossary](https://www.essentialcardano.io/glossary?sort=alphabetical)\n*   [FAQs](https://www.essentialcardano.io/faq)\n\n*   [](https://docs.cardano.org/)\n*   Cardano evolution\n*   Upgrades explained\n*   Byron to Shelley\n\n[Edit this page](https://github.com/input-output-hk/cardano-documentation/blob/master/docs/about-cardano/05-evolution/04-upgrades/01-byron-to-shelley.mdx)\n\nByron to Shelley\n================\n\nCardano's Byron mainnet ran on the [Ouroboros Classic](https://iohk.io/en/research/library/papers/ouroboros-a-provably-secure-proof-of-stake-blockchain-protocol/) consensus protocol. Cardano's Shelley mainnet transitioned to a decentralized network running on the [Ouroboros Praos](https://iohk.io/en/research/library/papers/ouroboros-praos-an-adaptively-secure-semi-synchronous-proof-of-stake-protocol/) consensus protocol, which enabled more extended capabilities while also supporting the staking process with monetary rewards for ada holders and stake pool operators.\n\nTo enable orderly transitions in Cardano without any diversions in the system, it was necessary to update the code to support the new protocol’s conditions. Doing so in a single update might have caused a range of complexities, so Cardano decided to take a two-stage approach, using the Ouroboros _Byzantine Fault Tolerance_ (BFT) protocol as an intermediary.\n\nThe shift from Ouroboros Classic to BFT (which happened on February 20, 2020) is the only traditional hard fork within the Cardano blockchain. This forking event restarted the Byron mainnet to run the BFT protocol and enable a smoother transition to Ouroboros Praos without any further chain interruptions. The BFT protocol was carefully designed so that blockchain history would remain unchanged, and the blockchain would appear as a single entity.\n\n[Previous About hard forks](https://docs.cardano.org/about-cardano/evolution/about-hard-forks)[Next Allegra](https://docs.cardano.org/about-cardano/evolution/upgrades/allegra)\n\n![Image 2: Cardano Logo](https://docs.cardano.org/assets/cardano-logo-blue.svg)\n\nMore About Cardano\n\n*   [Cardano Explorer](https://cardanoexplorer.com/)\n*   [Cardano Foundation](https://cardanofoundation.org/)\n*   [Cardano.org](https://www.cardano.org/)\n*   [Daedalus](https://daedaluswallet.io/)\n\nJoin the community\n\n*   [Cardano Community](https://cardano.org/)\n*   [Cardano Telegram](https://t.me/CardanoAnnouncements/)\n*   [Cardano Forum](https://forum.cardano.org/)\n*   [Cardano Blog](https://www.reddit.com/r/cardano/)\n*   [IOHK](https://www.iohk.io/)\n*   [IOHK blog](https://www.iohk.io/blog/)\n*   [IOHK YouTube](https://www.youtube.com/channel/UCBJ0p9aCW-W82TwNM-z3V2w)\n*   [Cardano Foundation YouTube](https://www.youtube.com/channel/UCbQ9vGfezru1YRI1zDCtTGg)\n*   [Cardano Foundation Twitter](https://twitter.com/Cardano_CF)\n*   [IOG Academy](https://www.youtube.com/channel/UCX9j__vYOJu00iqBrCzecVw)\n\nFollow us\n\n*   [X](https://twitter.com/inputoutputHK)\n*   [Facebook](https://www.facebook.com/iohk.io/)\n*   [Youtube](https://www.youtube.com/c/IohkIo)\n*   [Reddit](https://www.reddit.com/r/cardano/)\n\nSubscribe to our newsletter\n\nEmail* \n\n*   - [x] By checking this box, I agree to allow IOG to store and process the personal data submitted on this form in accordance with the IOG [Privacy Policy](https://static.iohk.io/terms/iog-privacy-policy.pdf)* \n\nCardano is an open-source project. Cardano is a software platform ONLY and does not conduct any independent diligence on, or substantive review of, any blockchain asset, digital currency, cryptocurrency or associated funds. You are fully and solely responsible for evaluating your investments, for determining whether you will exchange blockchain assets based on your own judgement, and for all your decisions as to whether to exchange blockchain assets with Cardano. In many cases, blockchain assets you exchange on the basis of your research may not increase in value, and may decrease in value. Similarly, blockchain assets you exchange on the basis of your research may fall or rise in value after your exchange. Past performance is not indicative of future results. Any investment in blockchain assets involves the risk of loss of part or all of your investment. The value of the blockchain assets you exchange is subject to market and other investment risks.\n\nThis work is licensed under CC BY 4.0\n\n© IOHK 2015-2025 - IOHK Supported Project\n\n*   [IOHK Privacy Policy](https://static.iohk.io/terms/iog-privacy-policy.pdf)\n*   [IOHK Terms & Conditions](https://static.iohk.io/terms/iog-terms-and-conditions.pdf)",
        "images": []
      },
      {
        "url": "https://docs.cardano.org/about-cardano/evolution/upgrades/chang",
        "raw_content": "Opens in a new window Opens an external website Opens an external website in a new window\n\nThis website utilizes technologies such as cookies to enable essential site functionality, as well as for analytics, personalization, and targeted advertising. To learn more, view the following link:    [Privacy Policy](https://static.iohk.io/terms/iog-privacy-policy.pdf)[Cookie Policy](https://static.iohk.io/terms/iog-cookie-policy.pdf)\n\n[Skip to main content](#__docusaurus_skipToContent_fallback)\n\n# Chang\n\nThe Chang upgrade ushered in the Conway ledger era, a deeply transformative advancement for Cardano's governance, where any ada holder can submit or participate in the voting process for governance actions. The upgrade happened in two stages, Chang #1 and Chang #2, now known as the Plomin hard fork.\n\nConway, named after the eminent mathematician [John Horton Conway](https://en.wikipedia.org/wiki/John_Horton_Conway), builds upon previous phases, emphasizing decentralized decision-making and enhanced smart contract functionalities.\n\nIn November 2024, following the sudden passing of Matthew Plomin, the hard fork working group recommended to rename the second upgrade after him. As a founding partner of the USDM Stablecoin, Matt was instrumental in the construction and regulatory compliance of groundbreaking financial technologies. The renaming has been widely affirmed by the community in a following governance info action.\n\n## What does Chang enable?[​](#what-does-chang-enable \"Direct link to What does Chang enable?\")\n\ninfo\n\nLearn more about Cardano governance and related terminology in [CIP-1694](https://github.com/cardano-foundation/CIPs/tree/master/CIP-1694).\n\nChang enables on-chain participatory governance through the implementation of mechanisms outlined in CIP-1694. This upgrade ensures transparency, inclusivity, and resilience of governance in the Cardano ecosystem. The Conway era is based on liquid democracy, which enables individual empowerment through democratic consent by leveraging a voting process with the option of direct and representative voting. Ada holders can vote individually on every governance matter, or delegate their voting power to [delegate representatives (DReps)](https://iohk.io/en/blog/posts/2022/04/11/introducing-the-concept-of-delegate-representatives-dreps/) they trust in decision making. DReps consolidate the voting influence of numerous ada holders, ensuring that each participant can contribute to the future of Cardano’s development.\n\nWith the introduction of [PlutusV3](https://iohk.io/en/blog/posts/2024/02/12/unlocking-more-opportunities-with-plutus-v3/), Plutus scripts are available for use as part of the governance system, enabling sophisticated voting possibilities like supporting DAOs, for example. Chang also brings advanced Plutus cryptographic primitives, other new primitives, and performance enhancements to the platform. These additions provide developers with a richer smart contract creation toolkit, enhancing both developer and user experiences, and unlocking new possibilities for decentralized applications (DApps) on Cardano.\n\n### Chang’s key features[​](#changs-key-features \"Direct link to Chang’s key features\")\n\n**Decentralized governance mechanisms:** through Chang, Cardano institutes on-chain decentralized governance mechanisms including a constitutional committee (CC), DReps, and a new governance role for stake pool operators (SPOs), fostering community-driven decision-making processes.\n\n**On-chain voting:** Chang facilitates on-chain voting for governance actions, allowing stakeholders to propose and vote on protocol changes and other governance-related matters.\n\n**PlutusV3 ledger language**: [PlutusV3](https://iohk.io/en/blog/posts/2024/02/12/unlocking-more-opportunities-with-plutus-v3/) introduces advanced Plutus primitives and cryptographic capabilities, enhancing the platform's smart contract functionalities. Cryptographic primitives are central to every blockchain, including hash functions, digital signatures, and zero-knowledge proof (ZKP) systems. These elements are designed for computational efficiency, ensuring robust security for their applications. PlutusV3 enhancements include:\n\n* **BLS12-381 primitives.** This collection of new built-in functions is fundamental for cryptographic operations that allow for efficient verification of zero-knowledge proofs.\n* **New hash primitives**. Blake2b-224 and [Keccak-256](https://cips.cardano.org/cip/CIP-101) are new cryptographic hash functions used for validating transaction signatures (improving compatibility with Ethereum), and secure data verification respectively.\n* **Sums of products (SOPs)**. PlutusV3 introduces SOPs, a new approach to encoding data types in Plutus Core. This method improves script efficiency and code generation for Plutus Core compilers, leading to faster program execution and streamlined smart contract development.\n* **Bitwise primitives**. The Chang upgrade brings two new bitwise primitives – `integerToByteString` and `byteStringToInteger`. Additional primitives will be added to Plutus V1, V2, and V3 with future upgrades. These primitives offer robust capabilities for low-level bit manipulations. This enhances performance optimization, cryptographic support, integer-string conversions, and efficient algorithms and data structures within smart contracts.\n\n## Additional functionalities[​](#additional-functionalities \"Direct link to Additional functionalities\")\n\nConway also introduces several new functionalities:\n\n* Reference scripts are enabled for Plutus V1 scripts. This enables legacy scripts to take advantage of reference scripts, reducing DApp costs and increasing on-chain capacity.\n* The `minFeeRefScriptsCoinsPerByte` protocol parameter refines the Plutus cost model and improves fee calculations by allowing separate tuning of the costs for reference scripts.\n* Adjustments to SPO deposits: SPO deposits are tracked individually, distinguishing between stake address registration deposits and stake pool registration deposits. This distinction has been retroactively applied all the way back to Shelley, facilitated by the static nature of deposits since their introduction.\n* General ledger rules improvements.\n\n## The Chang upgrade in stages[​](#the-chang-upgrade-in-stages \"Direct link to The Chang upgrade in stages\")\n\nChang was implemented in two stages. The first stage established foundational governance features, and the second will emphasize community-driven decision-making and governance.\n\n**First stage/bootstrapping**\n\nThe first stage was completed in August, 2024. Its purpose is to enable initial governance features and lay the groundwork for Conway-era functionality. During this time, DReps can register, and ada holders can delegate their voting power. PlutusV3 was introduced, which included new governance features.\n\nAn [interim constitution](https://docs.intersectmbo.org/cardano/cardano-governance/cardano-constitution/interim-cardano-constitution) was established with safeguards supported by a technical guardrails script. An interim constitutional committee oversees the constitutionality of governance actions during the interim period, prior to ratification of a full constitution. The bootstrap period is used to form the group of DReps. Limited governance actions are supported, including parameter changes, hard forks, and 'Info' actions.\n\nDuring the interim period, only SPOs and the interim constitutional committee can vote on governance actions, including possible protocol parameter changes. As an exception, DReps can participate in 'Info' actions at this stage.\n\nThe goal of the first stage is to ensure security and continuity during the governance bootstrapping phase, allowing DReps to register and campaign for delegation, while developing and ratifying a final constitution.\n\n**The second stage/on-chain decision making**\n\nThe second stage, which emphasized decentralized governance, was initiated by the community after the bootstrap period. The governance action to approve this Plomin hard fork was submitted on chain at the end of epoch 529, December 20, 2025 at 21:44 UTC. [Intersect](https://www.intersectmbo.org/) oversaw, established, and helped facilitate the community in self-government initiatives for the Cardano ecosystem. All governance entities, including DReps, SPOs, and the interim constitutional committee, can vote on governance actions during this stage. The conclusion of this stage allowed for treasury withdrawals.\n\n**The Cardano constitution**\n\nThe Cardano Constitutional Convention was held simultaneously in Buenos Aires - Argentina, and Nairobi - Kenya from December 4 to 6, 2024. After 63 workshops across 51 countries, participants came together to refine and strengthen the constitution. The draft constitution was agreed to by 95% of elected delegates.\n\nThe delegate-approved Cardano constitution is the foundational document that translates the community’s values and decisions into a clear set of principles, rules, and responsibilities. It defines the governance framework for the Cardano ecosystem, outlining stakeholders' roles and obligations, including DReps, SPOs, and others. This constitution guides Cardano toward becoming a sustainable platform for Web3 products and services.\n\nOn this page\n\n* [What does Chang enable?](#what-does-chang-enable)\n  + [Chang’s key features](#changs-key-features)\n* [Additional functionalities](#additional-functionalities)\n* [The Chang upgrade in stages](#the-chang-upgrade-in-stages)",
        "images": []
      },
      {
        "url": "https://docs.cardano.org/about-cardano/evolution/upgrades/valentine",
        "raw_content": "Opens in a new window Opens an external website Opens an external website in a new window\n\nThis website utilizes technologies such as cookies to enable essential site functionality, as well as for analytics, personalization, and targeted advertising. To learn more, view the following link:    [Privacy Policy](https://static.iohk.io/terms/iog-privacy-policy.pdf)[Cookie Policy](https://static.iohk.io/terms/iog-cookie-policy.pdf)\n\n[Skip to main content](#__docusaurus_skipToContent_fallback)\n\n# Valentine (SECP)\n\nThe Valentine (or SECP) upgrade is Cardano’s intra-era hard fork that followed the Vasil upgrade. Valentine was a small and focused semantic change to the ledger, which brought new built-in functions to Plutus to support SECP elliptic curves (ECDSA and Schnorr). Although an intra-era hard fork requires a hard fork combinator event, it does not change the ledger era, which means that this was an upgrade to the Babbage ledger era.\n\n## About ECC[​](#about-ecc \"Direct link to About ECC\")\n\nECC is a popular primitive for developing cryptographic protocols and secure applications using custom encryption and decryption algorithms validated by digital signatures. ECC provides the same level of security as other mechanisms while using shorter keys and signatures.\n\nThere are different elliptic curves one can use, with secp256k1 as one of the options. Each of these curves differs in its parameters. The secp256k1 curve provides two common signature schemes – ECDSA and Schnorr.\n\nCardano uses the Edwards-curve Digital Signature Algorithm (EdDSA) with elliptic curve Curve25519 as its base curve (Ed25519). Ed25519 is designed to be resistant to certain types of cryptographic attacks, making it a secure choice.\n\nEd25519 is part of the family of [safeCurves](https://safecurves.cr.yp.to/), which secp256k1 is not part of. The variance in algorithms means that Plutus DApp developers who want to work with other blockchains and need to validate ECDSA and Schnorr signatures would have to spend time, effort, and funds to implement such algorithms over the Standards for Efficient Cryptography (SECP) elliptic curves in Plutus. This extra implementation considerably increases potential security risks.\n\nSince only Cardano’s primary signature algorithm Ed25519 was provided as a Plutus built-in function, ECDSA and Schnorr operations would be more expensive and time-consuming unless also provided as built-in functions.\n\n**What did the SECP upgrade bring?**\n\nCardano’s Valentine upgrade added new built-in functions to Plutus to support ECDSA and Schnorr signatures along with Cardano’s native signature.\n\nThese built-in functions are now native to Cardano, and since they are implemented and audited by experts, they provide the highest level of security. This standardization allows any Plutus DApp developer to widen the choice of multi-signature or threshold signature design to use.\n\n[CIP-49](https://github.com/mlabs-haskell/CIPs/blob/c5bdd66fe49c19c341499f86cebaa2eef9e90b74/CIP-0049/README.md) provides a more in-depth oversight of the motivation and specification for the new implementation of built-in functions.\n\nAfter the new cryptographic primitives implementation, Plutus can easily verify transactions from other blockchains using ECDSA and Schnorr standards. For example, Plutus can natively verify signatures generated in EVM sidechains, which improves the developer experience in terms of process simplicity, cost, and advanced security.\n\n## Example scripts[​](#example-scripts \"Direct link to Example scripts\")\n\nBelow is a link to examples of scripts and script data files containing the inputs for working with SECP256k1 elliptic curves.\n\nThe use of these scripts is similar to a [token minting process](https://github.com/input-output-hk/cardano-node-wiki/blob/main/docs/reference/plutus/plutus-minting-script-example.md), where you build a transaction to mint a token using `--mint-script-file` with a provided Plutus script and `--mint-redeemer-file` for provided input script data.\n\nSee the tutorial on [how to use SECP256K1 primitives](https://github.com/input-output-hk/Vasil-testnet/blob/main/secp-primitives-cip.md).\n\nOn this page\n\n* [About ECC](#about-ecc)\n* [Example scripts](#example-scripts)",
        "images": []
      },
      {
        "url": "https://docs.cardano.org/about-cardano/evolution/upgrades/vasil",
        "raw_content": "Opens in a new window Opens an external website Opens an external website in a new window\n\nThis website utilizes technologies such as cookies to enable essential site functionality, as well as for analytics, personalization, and targeted advertising. To learn more, view the following link:    [Privacy Policy](https://static.iohk.io/terms/iog-privacy-policy.pdf)[Cookie Policy](https://static.iohk.io/terms/iog-cookie-policy.pdf)\n\n[Skip to main content](#__docusaurus_skipToContent_fallback)\n\n# Vasil\n\nVasil is the protocol upgrade implemented in June 2022. Named after the late Bulgarian mathematician and prominent Cardano community member Vasil Dabov, the Vasil upgrade introduced five key mechanisms to improve the blockchain's performance: [CIP-31](https://cips.cardano.org/cip/CIP-0031) (reference inputs), [CIP-32](https://cips.cardano.org/cip/CIP-0032) (inline datums), [CIP-33](https://cips.cardano.org/cip/CIP-0033) (reference scripts), [CIP-40](https://cips.cardano.org/cip/CIP-0040) (collateral outputs), and diffusion pipelining.\n\nHere's a more detailed feature overview.\n\n## Diffusion pipelining[​](#diffusion-pipelining \"Direct link to Diffusion pipelining\")\n\nDiffusion pipelining is a feature that improves block propagation times and further leads to higher throughput. In essence, it streamlines the process of sharing information about newly created blocks among network participants. The goal is to ensure that blocks can be shared (propagated) in the network within five seconds after their creation. For this, diffusion pipelining propagates blocks before their full validation thus overlapping the time spent on diffusion with the time needed on validation.\n\nPipelining also ensures that the block header referencing the hash of a previous block is propagated correctly. The body of the block is retained within the metadata included in the next block, which is essential for DDoS attack resistance even without full block confirmation.\n\nDiffusion pipelining provides more space for block size increase and Plutus script improvements, leading to a more scalable setting overall.\n\n## Plutus Core changes[​](#plutus-core-changes \"Direct link to Plutus Core changes\")\n\nPlutus Core is a scripting language used in the Cardano ledger. It consists of basic core language constructs and also includes built-in types (integers, strings, etc) and built-in functions (integer addition, etc) that provide functionality that would be difficult or expensive to implement in the Plutus Core code. Built-in functions mostly operate on built-in types. Built-in types come with a size metric that is used by costing functions. For example, the size metric for integers returns the bit-size of the integer.\n\nThe performance of Plutus Core scripts relates to how expensive it is to run a script in the ledger. The cost model describes CPU and memory fees for each language primitive and can be used off-chain to predict fees for running such scripts.\n\nModel performance is calculated by `costing _evaluation_` in abstract resource units (exunits) of CPU and memory. Individual steps of evaluation are costed, and built-in functions must also come with a `_costing function_` that provides costing information for them. The costing function for a built-in function is a mathematical function that takes the sizes of the arguments (as computed by their size metrics) and returns an estimate of the budget that will be used to perform that function.\n\nFor example, the costing function for addition says that the CPU and memory costs are both proportional to the maximum of the sizes of the input integers (with some appropriate constants). Determining costing functions is done empirically by running the function in question against a large number of inputs and choosing a costing function that fits the data well.\n\n### Scripts in the Cardano ledger[​](#scripts-in-the-cardano-ledger \"Direct link to Scripts in the Cardano ledger\")\n\nThe Cardano ledger recognizes various types of scripts that are identified by ‘language’ version. This language tag allows the ledger to distinguish between different script types. When a new behavior or functionality is introduced, so is a new language. Each new version of Plutus will be its own language, and all Plutus Core language versions are supported forever in the ledger. This provides the ability to validate the history of the chain indefinitely.\n\nPart of the specification of a language in the ledger explains how language scripts run, what arguments they are given, and how those arguments are structured. Languages also have an associated subset of Cardano protocol parameters that control some aspects of the script evaluation. For Plutus, this is the cost model that is associated with each new language version.\n\n### Plutus evaluator speed improvements[​](#plutus-evaluator-speed-improvements \"Direct link to Plutus evaluator speed improvements\")\n\nDue to performance improvements in the Plutus evaluator, both Plutus V1 and Plutus V2 scripts have lower cost model parameters than before, resulting in 20-30% improvements in script resource usage.\n\n### Updated cost model parameters[​](#updated-cost-model-parameters \"Direct link to Updated cost model parameters\")\n\nThe updated cost model parameters include the following changes:\n\n1. Extend the set of built-in functions by adding the new built-in “serialiseData.”\n2. The built-in function “verifySignature” was renamed “verifyEd25519Signature” to make it more clear what its function is.\n3. Recalibrate the cost model for the version of the evaluator in the node to align with the CPU parameters changes.\n\n### New Plutus Core built-in[​](#new-plutus-core-built-in \"Direct link to New Plutus Core built-in\")\n\nThe built-in types and type operators remain unchanged from the Alonzo upgrade. All the new built-in functions are backward compatible. Adding them does not break any older script validators. The Vasil release continues to support the Alonzo built-in functions and adds the following new function:\n\n**serialiseData**\n\nA new Plutus built-in is added for serializing `BuiltinData` to `BuiltinByteString`. The serialiseData function takes a data object and converts it into a [CBOR](https://cbor.io/) object.\n\nPlutus already provides a built-in for hashing data structure, for example, `sha2_256 :: BuiltinByteString -> BuiltinByteString`, it does not provide generic ways of serializing some data types to `BuiltinByteString`.\n\nThe overall memory and CPU costs are reduced by having a new built-in to serialize any Plutus ‘BuiltinData’ to ‘BuiltinByteString’ such that validators can leverage more optimized implementations and bytestring builders via built-ins than what is available on-chain.\n\nFor more explanations, how-to guides, and tutorials, see [Plutus Docs.](https://plutus.readthedocs.io/en/latest/)\n\n### Plutus script addresses[​](#plutus-script-addresses \"Direct link to Plutus script addresses\")\n\n*A Plutus V2 script does not have the same hash value as a Plutus V1 script.*\n\nSince scripts must match their on-chain hashes exactly, it is important that the scripts that an application uses do not accidentally change. For example, changing the source code or updating dependencies or tooling may lead to small changes in the script. As a result, the hash will change. In cases where the hashes must match exactly, even changes which do not alter the functionality of the script can be problematic.\n\nIn light of this consideration, some DApp developers might expect that when doing a migration from Plutus V1 scripts to Plutus V2 scripts, the same source code, when recompiled, will generate the same hash value of that script address. However, it is impossible for a compiled V2 script to have the same script hash and address as a compiled V1 script.\n\nUsing the exact same script with different language versions will result in different hashes. The exact same script (as in UPLC.Program) can be used as a Plutus V1 script or a Plutus V2 script, and since the language version is part of the hash, the two hashes will be different.\n\n**A Plutus V1 script will not necessarily have the same hash value when recompiled with a later version of the Plutus compiler**\n\nSuppose you write your Haskell source code (Plutus Tx), compile it into Plutus Core code (PLC), generate its hash value, then use it in a transaction. If you don’t save your compiled code, and then decide to use the same script in the future, you would have to recompile it. This could result in a different hash value of the script address even without upgrading from Plutus V1 to Plutus V2 scripts. This is because the hash is computed based on the output of the compiled code.\n\nGiven Plutus compiler version changes, changes in the dependencies, and multiple other improvements, it is expected that the hash value of the script address will change after the source code is recompiled.\n\n**When to export and save the output of a compiled script**\n\nOnce you expect that you will not modify the on-chain part of your application and you don’t want the hash value of your script address to change, the best way to keep it the same is to save the output of your final compiled Plutus Core code (PLC) to a file.\n\nFor details on how to export scripts, please see: [How to export scripts, datums, and redeemers](https://plutus.readthedocs.io/en/latest/howtos/exporting-a-script.html) in the Plutus Core user documentation.\n\n## Reference inputs (CIP-31)[​](#reference-inputs-cip-31 \"Direct link to Reference inputs (CIP-31)\")\n\nTransaction outputs carry datums, which enable access to information on the blockchain. However, these datums are constrained in a number of ways. For example, to access information in the datum, you’d have to spend the output that the datum is attached to. This requires the re-creation of a spent output. Any user who wishes to look at the data cannot spend the old output (which is gone), but must spend the new output (which they will not know about until the next block). In practice, this limits some applications to one ‘operation’ per block, thus decreasing the desired performance.\n\nCIP-31 introduces a new mechanism for accessing information in datums – a reference input. Reference inputs allow looking at an output without spending it. This will facilitate access to information stored on the blockchain without the need for spending and re-creating unspent transaction outputs (UTXOs).\n\nThe key use case of CIP-31 is to support reference scripts (CIP-33). Other use cases include:\n\n1. Inspecting the state (datum, or locked value) of an on-chain application without having to consume the output. For example, checking the current state of a stablecoin state machine.\n2. The ability to reference on-chain data providers that store data in outputs by other scripts.\n\nSee the [how to use reference inputs](https://github.com/perturbing/vasil-tests/blob/main/reference-inputs-cip-31.md) tutorial for more details.\n\n## Inline datums (CIP-32)[​](#inline-datums-cip-32 \"Direct link to Inline datums (CIP-32)\")\n\nDatums carrying transaction information are commonly implemented by attaching hashes of datums to outputs. This is quite inconvenient for users. Datums tend to represent the result of computation done by the party who creates the output, and as such, there is almost no chance that the spending party will know the datum without communicating with the creating party. This means that either the datum must be communicated between parties off-chain, or on-chain by including it in the witness map of the transaction that creates the output (‘extra datums’). Such a case requires the spending party to watch the whole chain to find the datum, which is also inconvenient.\n\nCIP-32 suggests a solution that allows datums themselves to be attached to outputs instead of datum hashes. This will allow much simpler communication of datum values between users.\n\n**Use cases** include:\n\n* Creating a single UTXO with data to be used in multiple subsequent transactions, but only paying the cost for submitting it once.\n* Storing little information on-chain. For example, Oracles can benefit from this by simply adding some off-chain data to the main chain.\n\nSee the [how to use inline datums](https://github.com/perturbing/vasil-tests/blob/main/inline-datums-cip-32.md) tutorial for more details.\n\n## Reference scripts (CIP-33)[​](#reference-scripts-cip-33 \"Direct link to Reference scripts (CIP-33)\")\n\nWhen you spend an output locked with a Plutus script, you must include the script in the spending transaction. Hence, the size of the scripts contributes to transaction size, which directly influences Cardano’s throughput.\n\nLarge script sizes pose problems for users because:\n\n1. Larger transactions result in higher fees.\n2. Transactions have size limits. Large scripts can hit the limits. Even if one script fits, multiple scripts in one transaction might not fit. This makes it difficult to execute complex transactions that rely on several scripts.\n\nCIP-33 introduces the ability to reference a script without including it in each transaction. This hugely reduces the contribution of scripts to the transaction size.\n\nSee the [how to reference scripts](https://github.com/perturbing/vasil-tests/blob/main/referencing-scripts-cip-33.md) tutorial for more details.\n\n## Transaction redeemers[​](#transaction-redeemers \"Direct link to Transaction redeemers\")\n\nTwo important elements in Plutus are *datums* and *redeemers*. The datum is a piece of information that can be associated with a UTXO and is used to carry script state information. It is frequently used in combination with a redeemer, which is like an instruction or command to the contract.\n\nWith the Vasil hard fork, developers can see redeemers for all inputs rather than just the one being passed to the currently executing script.\n\n## Collateral change address[​](#collateral-change-address \"Direct link to Collateral change address\")\n\nScript collateral is the monetary guarantee a user gives to assure that the transaction that uses a contract has been carefully constructed and thoroughly tested before submission to the validators. It is used to guarantee that nodes are compensated for their work in case phase-2 validation fails. The collateral amount is specified at the time of constructing the transaction and is reserved to allow for the on-chain script execution.\n\nWith the Vasil hard fork, DApp developers can specify a change address for the script collateral. This means that in case the script fails phase-2 validation, only the right amount will be taken, and the remaining funds will be sent to the provided change address.\n\nSee the [how to use collateral outputs](https://github.com/perturbing/vasil-tests/blob/main/collateral-output-cip-40.md) tutorial for more details.\n\n## Single VRF implementation[​](#single-vrf-implementation \"Direct link to Single VRF implementation\")\n\nOn Cardano, the Verifiable Random Function (VRF) determines which SPO creates the next block. Before Vasil, there were two VFR functions executed on every network hop to validate a block. With the Vasil hard fork, one of these functions is dropped, resulting in faster block validation and overall network syncing times.\n\nOn this page\n\n* [Diffusion pipelining](#diffusion-pipelining)\n* [Plutus Core changes](#plutus-core-changes)\n  + [Scripts in the Cardano ledger](#scripts-in-the-cardano-ledger)\n  + [Plutus evaluator speed improvements](#plutus-evaluator-speed-improvements)\n  + [Updated cost model parameters](#updated-cost-model-parameters)\n  + [New Plutus Core built-in](#new-plutus-core-built-in)\n  + [Plutus script addresses](#plutus-script-addresses)\n* [Reference inputs (CIP-31)](#reference-inputs-cip-31)\n* [Inline datums (CIP-32)](#inline-datums-cip-32)\n* [Reference scripts (CIP-33)](#reference-scripts-cip-33)\n* [Transaction redeemers](#transaction-redeemers)\n* [Collateral change address](#collateral-change-address)\n* [Single VRF implementation](#single-vrf-implementation)",
        "images": []
      },
      {
        "url": "https://docs.cardano.org/about-cardano/explore-more/cardano-architecture",
        "raw_content": "Opens in a new window Opens an external website Opens an external website in a new window\n\nThis website utilizes technologies such as cookies to enable essential site functionality, as well as for analytics, personalization, and targeted advertising. To learn more, view the following link:    [Privacy Policy](https://static.iohk.io/terms/iog-privacy-policy.pdf)[Cookie Policy](https://static.iohk.io/terms/iog-cookie-policy.pdf)\n\n[Skip to main content](#__docusaurus_skipToContent_fallback)\n\n# Cardano architecture\n\nThis section describes the high-level architecture of Cardano, providing details\non the core components and their interactions.\n\nThe following diagram outlines the interaction between the system components of\nCardano:\n\n## System components[​](#system-components \"Direct link to System components\")\n\nThe *current* implementation of Cardano is highly modular. It includes the\nfollowing components (different deployment use cases will use different\ncombinations of components):\n\n* [Node](https://github.com/input-output-hk/cardano-node)\n* [Command line interface (CLI)](https://github.com/IntersectMBO/cardano-cli)\n* [Cardano wallet](https://github.com/input-output-hk/cardano-wallet)\n* [Cardano db-sync](https://github.com/input-output-hk/cardano-db-sync)\n* [GraphQL](https://github.com/input-output-hk/cardano-graphql) API server\n  (Apollo)\n* [SMASH server](https://github.com/IntersectMBO/cardano-db-sync/tree/master/cardano-smash-server).\n\n## Nodes and remote nodes[​](#nodes-and-remote-nodes \"Direct link to Nodes and remote nodes\")\n\nA blockchain system consists of a set of nodes distributed across a network that\ncommunicate with each other to achieve\n[consensus](/about-cardano/learn/consensus-explained) about the system’s state.\n\nNodes are responsible for:\n\n* Executing the\n  [Ouroboros](https://github.com/IntersectMBO/ouroboros-network?tab=readme-ov-file#ouroboros-network)\n  protocol\n* Validating and relaying blocks\n* Producing blocks (some nodes)\n* Providing information about the state of the blockchain to other local\n  clients.\n\n### Node process[​](#node-process \"Direct link to Node process\")\n\nThe `cardano-node` is the top level Cardano component that consists of the other\nsubsystems, of which the most significant are\n[consensus](https://github.com/IntersectMBO/ouroboros-consensus?tab=readme-ov-file#ouroboros-consensus),\n[ledger](https://github.com/IntersectMBO/cardano-ledger?tab=readme-ov-file#cardano-ledger),\nand\n[networking](https://github.com/IntersectMBO/ouroboros-network?tab=readme-ov-file#ouroboros-network)\nwith ancillary configuration, CLI, logging, and monitoring.\n\n### Node-to-node IPC protocol[​](#node-to-node-ipc-protocol \"Direct link to Node-to-node IPC protocol\")\n\nThe purpose of the node-to-node Inter-Process Communication (IPC) protocol is to\nallow for the exchange of blocks and transactions between nodes as part of the\nOuroboros consensus algorithm.\n\nThe node-to-node protocol is a composite protocol, consisting of three\nmini-protocols:\n\n* **chain-sync**: used for following the chain and getting block headers\n* **block-fetch**: used for getting block bodies\n* **tx-submission**: used for forwarding transactions.\n\nThese mini-protocols are multiplexed on a single long-running Transmission\nControl Protocol (TCP) connection between nodes. They can be run in *both*\ndirections on the same TCP connection to allow for peer-to-peer (P2P) settings.\n\nThe overall protocol – and each mini-protocol – is designed for a trustless\nsetting where both sides need to guard against Denial-of-Service (DoS) attacks.\nFor example, each mini-protocol uses consumer-driven control flow, so a node\nonly requests more work when it is ready, rather than having work *pushed* upon\nit.\n\nThe protocol design is modular and evolvable: version negotiation is used to\nagree on the set of mini-protocols to use, which allows additional or updated\nmini-protocols to be added over time without causing compatibility issues.\n\n### Node-to-client IPC[​](#node-to-client-ipc \"Direct link to Node-to-client IPC\")\n\nThe purpose of the node-to-client IPC protocol is to allow local applications to\ninteract with the blockchain via the node. This includes applications such as\nwallet backends or blockchain explorers. The node-to-client protocol enables\nthese applications to access the raw chain data and to query the current ledger\nstate. It also provides the ability to submit new transactions to the system.\n\nThe node-to-client protocol uses the same design as the node-to-node protocol,\nbut with a different set of mini-protocols, and local pipes rather than TCP\nconnections. As such, it is a relatively low-level narrow interface that exposes\nonly what the node can provide natively. For example, the node provides access\nto all the raw chain data but does not provide a way to query data on the chain.\nThe job of providing data services and more convenient higher level APIs is\ndelegated to dedicated clients, such as cardano-db-sync and the wallet backend.\n\nThe node-to-client protocol consists of three mini-protocols:\n\n* **chain-sync**: used for following the chain and getting blocks\n* **local-tx-submission**: used for submitting transactions\n* **local-state-query**: used for querying the ledger state.\n\nThe node-to-client version of chain sync uses *full* blocks, rather than just\nblock headers. This is why no separate block-fetch protocol is needed. The\nlocal-tx-submission protocol is like the node-to-node tx-submission protocol but\nsimpler, and it returns the details of transaction validation failures. The\nlocal state query protocol provides query access to the current ledger state,\nwhich contains a lot of interesting data that is *not* directly reflected on the\nchain itself.\n\ninfo\n\nRead more about the\n[networking protocol design here](/about-cardano/explore-more/cardano-network/networking-protocol).\n\n## Command line interface (CLI)[​](#command-line-interface-cli \"Direct link to Command line interface (CLI)\")\n\nThe node’s CLI tool is the 'swiss army knife' of the system. It can do almost\neverything, but it is quite low level and not very convenient because it’s\ntext-based and lacks a graphical user interface (GUI).\n\nThe CLI tool can:\n\n* query the node for information\n* submit transactions\n* build and sign transactions\n* manage cryptographic keys.\n\n## Daedalus wallet[​](#daedalus-wallet \"Direct link to Daedalus wallet\")\n\nDaedalus is a full node wallet that helps users to manage their ada, and can\nsend and receive payments on the Cardano blockchain. Daedalus consists of a\nwallet frontend and a backend. The frontend is the graphical application that\nusers see and interact with. The backend is a service process that monitors the\nstate of the user’s wallet and does all the 'heavy lifting', such as coin\nselection, transaction construction, and submission. The backend interacts with\na local node via the node-to-client IPC protocol, and interacts with the\nfrontend via a HTTP API. The backend also provides a CLI that enables\ninteraction with the wallet. The wallet backend can also be used on its own –\nwithout Daedalus – via its API. This is a convenient way for software developers\nto integrate Cardano with other applications and systems.\n\n## Cardano DB Sync[​](#cardano-db-sync \"Direct link to Cardano DB Sync\")\n\nThe Cardano node stores only the blockchain itself and the associated\ninformation needed to validate the blockchain. This design principle is about\nminimizing code complexity (and reducing computational cost and resource use) to\nkeep the node's local interfaces as minimal as possible and to use external\nclients to provide a variety of convenient interfaces and extra functionality.\nIn particular, the node does not provide a convenient query interface for\nhistorical information on the blockchain. This data service is provided by a\nseparate component using a Structured Query Language (SQL) database.\n\nLearn more about\n[Cardano DB Sync here](https://github.com/IntersectMBO/cardano-db-sync?tab=readme-ov-file#cardano-db-sync).\n\nOn this page\n\n* [System components](#system-components)\n* [Nodes and remote nodes](#nodes-and-remote-nodes)\n  + [Node process](#node-process)\n  + [Node-to-node IPC protocol](#node-to-node-ipc-protocol)\n  + [Node-to-client IPC](#node-to-client-ipc)\n* [Command line interface (CLI)](#command-line-interface-cli)\n* [Daedalus wallet](#daedalus-wallet)\n* [Cardano DB Sync](#cardano-db-sync)",
        "images": []
      },
      {
        "url": "https://docs.cardano.org/about-cardano/explore-more/cardano-network",
        "raw_content": "# Cardano network\n\nThe Cardano network is a technical infrastructure combining Cardano nodes and their interactions in one unified system. It consists of a collection of nodes that communicate with each other to maintain the distributed ledger. These nodes are the actors on Cardano that validate blocks, add blocks to the chain, and distribute transactions.\n\nThe networking layer is the driving force for delivering information exchange requirements, which includes new blocks diffusion and transaction information for establishing a better data flow. Cardano nodes maintain connections with peers that have been chosen via a custom peer selection process.\n\ninfo\n\nRead the following specifications for more details:\n\n* [The Shelley networking protocol](https://ouroboros-network.cardano.intersectmbo.org/pdfs/network-spec/network-spec.pdf)\n* [An introduction to the design of data diffusion and networking for Cardano Shelley.](https://ouroboros-network.cardano.intersectmbo.org/pdfs/network-design/network-design.pdf)\n\n## Data flow between and within nodes[​](#data-flow-between-and-within-nodes \"Direct link to Data flow between and within nodes\")\n\nTo understand how nodes communicate with each other, let’s suppose that node *A* is connected to node *B*. Then, the Ouroboros protocol schedules a node *N* to generate a new block in a given time slot. Depending on the location of nodes *A*, *B*, and *N* in the network topology, and whether a new block arrives first at *A* or *B*, node *A* can be either upstream or downstream of node *B*.\n\nA set of mini-protocols is used to enable communication between different nodes. Each mini-protocol implements a basic information exchange requirement, such as informing peers of the latest block, sharing blocks as needed, or sharing new transactions around the Cardano network. For connection purposes, mini-protocols are determined by the version of the network protocol. For example, there are two protocol suites: node-to-node and node-to-client. The node-to-client protocol suite is used by wallets and chain consumers. Protocol suites use different sets of mini-protocols and the version is negotiated when a new connection is established using a specific protocol (protocols are described in the following sections).\n\nClients can also choose which node-to-client mini-protocols to use, but it is important to note that the node needs to be able to reply to all of them to support different use cases. For example, to communicate, node A runs its client-side instance of the *chain-sync mini-protocol* that talks with a server instance of the *chain-sync mini-protocol* at node *B*. Such a situation is similar to the functionality of other mini-protocols.\n\nThe scheme below illustrates how data flows within a node. Circles represent protocol threads and internal threads that are responsible for running the client and server processes within the respective mini-protocols.\n\nTwo types of data flow exist:\n\n1. Mini-protocols communicate with mini-protocols of other nodes by sending and receiving messages across a public network (internet); this flow is not covered within the scheme above.\n2. Within a node, mini-protocols communicate with each other by reading from, and writing to, a shared mutable variable, which is represented by boxes in the scheme. Arrows indicate whether a thread has *read* or *write* access to the shared state.\n\n## Addressing network complexities and constraints[​](#addressing-network-complexities-and-constraints \"Direct link to Addressing network complexities and constraints\")\n\nTo design an efficient and robust networking architecture, a number of potential issues regarding complexity and constraints have been evaluated.\n\n**Congestion control** is one such feature and is used to deal with system overload. Congestion control is vital to ensure that the system is robust enough while operating high workloads. Within the networking design, it is common that the number of transactions that occur can be higher than the number that can be actually processed for inclusion in the blockchain. Therefore, it is important to ensure that the increasing rate of transaction submission into a block does not decrease the performance of blockchain.\n\nThe actual node has a limit to the amount of data it can process. In particular, a node might have to share its processing power with other processes that run on the same machine or operating system instance. This means that a node can slow down and result in the system not being able to process all the available data from the network.\n\nTo address these issues, the congestion control feature has been designed to operate appropriately in such a situation and recover from transient conditions. In any case, a node must not exceed its memory limits so there must be defined memory limits, breaches of which are treated as protocol violations. These factors mean that the system will be able to meet performance goals.\n\n**Real-time constraints** and **coordinated universal time** are other aspects that have been considered while designing the networking architecture. In Cardano, Ouroboros consensus protocols model the passage of physical time as an infinite sequence of time slots, assigning slot leaders to create a new block in those time slots. Choosing a slot time, however, might cause certain complexities in terms of the slot length, as it should be long enough for a new block to have a good chance to reach the next slot leader in time. Therefore, a chosen value for the slot length was initially set to 20 seconds in the Byron era. With [Ouroboros Praos](https://eprint.iacr.org/2017/573.pdf) implemented in the Shelley era, a slot length of 1 second is chosen but, on average, only 0.05 of slots will produce a block (and thus on average, there will be 20-second intervals between blocks). It is assumed that the clock skews between the local clocks of the nodes are small with respect to the slot length. Possible clock inaccuracies should still be taken into consideration, especially when dealing with time-stamped incoming blocks. It is important to differentiate whether there is a time difference or whether the node considers an adversarial behavior of another node.\n\n## Utilizing mini-protocols[​](#utilizing-mini-protocols \"Direct link to Utilizing mini-protocols\")\n\nMini-protocols are used to communicate between multiple nodes while implementing information exchange requirements. A mini-protocol is a defined modular building block of the network protocol. Structuring the network protocol around mini-protocols helps to manage the overall complexity of the design while ensuring useful flexibility.\n\nMini-protocols describe both the *initiator* and the *responder* within the communication stream. The initiator is the dual element of the responder and vice versa. A node typically runs many instances of mini-protocols, which includes many instances of the same mini-protocol. Each mini-protocol instance of the node then communicates with the dual instance of the exact peer. All mini-protocols that communicate with the same peer share a single communication channel (pipe or socket). A multiplexer or de-multiplexer is used to multiplex respective protocols over that channel.\n\nThe set of mini-protocols that is used for connection between two participants of the system depends on the role of these participants, for instance, whether the node acts as a full node or a blockchain consumer (for example, a wallet).\n\nIt is also worth noting that the implementation of mini-protocols uses a generic framework for **state machines**. This framework uses *correct-by-construction* techniques to guarantee the implementation of several properties of the protocol. In particular, this technique assures that no deadlocks occur and communication is canceled in the following scenarios:\n\n* when one side is expected to transmit the next message, and the other side is awaiting the message, and both sides agree that the protocol has been terminated\n* when either side receives a message that is not expected according to the protocol.\n\nAll mini-protocols based on this framework include the following information in their description:\n\n* an informal description of the protocol\n* state machine states\n* exchanged messages\n* a transition graph of the state machine global view\n* the client’s implementation of the protocol\n* the server implementation of the protocol.\n\n## Example mini-protocols[​](#example-mini-protocols \"Direct link to Example mini-protocols\")\n\nThis section outlines some examples of mini-protocols.\n\n### Ping pong protocol[​](#ping-pong-protocol \"Direct link to Ping pong protocol\")\n\nThis is a simple protocol for testing that a client can use to check that the server is responsive. The ping pong protocol is very simple because the messages do not carry any data and the ping pong client, as well as the ping pong server, do not access the internal state of the node.\n\n### Request response protocol[​](#request-response-protocol \"Direct link to Request response protocol\")\n\nThe request response protocol is polymorphic in the request and response data that is being transmitted. This means that there are different possible applications of this protocol and the application of the protocol determines the types of requests sent and responses received.\n\n### Chain synchronization protocol[​](#chain-synchronization-protocol \"Direct link to Chain synchronization protocol\")\n\nThe chain synchronization protocol is used by a blockchain consumer to replicate the producer’s blockchain locally. A node communicates with several upstream and downstream nodes and runs an independent client instance and an independent server instance for each node with which it communicates.\n\nThe chain synchronization protocol is polymorphic. The node-to-client protocol uses an instance of the chain synchronization protocol that transfers full blocks, while the node-to-node instance only transfers block headers. In the node-to-node scenario, the block fetch protocol is used to transfer full blocks.\n\n### Block fetch protocol[​](#block-fetch-protocol \"Direct link to Block fetch protocol\")\n\nThe block-fetching protocol enables a node to download a range of blocks.\n\n### Local transaction submission mini-protocol[​](#local-transaction-submission-mini-protocol \"Direct link to Local transaction submission mini-protocol\")\n\nThe local transaction submission mini-protocol is used by local clients, for example, wallets or CLI tools, to submit transactions to a local node. The protocol is not used to forward transactions from one core node to another. The protocol follows a simple request-response pattern:\n\n1. the client sends a request with a single transaction\n2. the server either accepts the transaction (returning a confirmation), or rejects it (returning the reason).\n\n### Node-to-node transaction submission protocol[​](#node-to-node-transaction-submission-protocol \"Direct link to Node-to-node transaction submission protocol\")\n\nThe node-to-node transaction submission protocol is used to transfer transactions between full nodes. The protocol follows a pull-based strategy where the initiator asks for new transactions and the responder replies with transactions. It is suitable for a trustless setting where both sides need to guard against resource consumption attacks from the other side. The implementation of the node-to-node transaction mini-protocol is based on a generic mini-protocol framework (the same as for all other mini-protocols). For technical reasons, the roles of the initiator and the responder are reversed in this case compared to the way other mini-protocols are implemented in the framework. In other words, the server is the initiator who requests new transactions, and the client is the responder who replies with transactions.\n\n### Handshake mini-protocol[​](#handshake-mini-protocol \"Direct link to Handshake mini-protocol\")\n\nThe handshake mini-protocol is used to negotiate the protocol version and the protocol parameters that are used by the client and the server. It is used first when a new connection is initialized and consists of a single request from the client and a single reply from the server. The handshake mini-protocol is a generic protocol that can negotiate any kind of protocol parameters. It assumes that protocol parameters can be encoded to, and decoded from Concise Binary Object Representation (CBOR) terms. A node that runs the handshake protocol must instantiate it with the set of supported protocol versions and callback functions for handling the protocol parameters. These callback functions are specific to the supported protocol versions.\n\nOn this page\n\n* [Data flow between and within nodes](#data-flow-between-and-within-nodes)\n* [Addressing network complexities and constraints](#addressing-network-complexities-and-constraints)\n* [Utilizing mini-protocols](#utilizing-mini-protocols)\n* [Example mini-protocols](#example-mini-protocols)\n  + [Ping pong protocol](#ping-pong-protocol)\n  + [Request response protocol](#request-response-protocol)\n  + [Chain synchronization protocol](#chain-synchronization-protocol)\n  + [Block fetch protocol](#block-fetch-protocol)\n  + [Local transaction submission mini-protocol](#local-transaction-submission-mini-protocol)\n  + [Node-to-node transaction submission protocol](#node-to-node-transaction-submission-protocol)\n  + [Handshake mini-protocol](#handshake-mini-protocol)\n\n ",
        "images": []
      },
      {
        "url": "https://docs.cardano.org/about-cardano/explore-more/cardano-network/networking-protocol",
        "raw_content": "Opens in a new window Opens an external website Opens an external website in a new window\n\nThis website utilizes technologies such as cookies to enable essential site functionality, as well as for analytics, personalization, and targeted advertising. To learn more, view the following link:    [Privacy Policy](https://static.iohk.io/terms/iog-privacy-policy.pdf)[Cookie Policy](https://static.iohk.io/terms/iog-cookie-policy.pdf)\n\n[Skip to main content](#__docusaurus_skipToContent_fallback)\n\n# Networking protocol design overview\n\nTransmission Control Protocols (TCP) and Internet Protocols (IP) form a protocol\nsuite universally deployed on the network. TCP/IP enables a reliable\nbidirectional communication channel between systems on the internet.\n\nThe ordered delivery of *Cardano node communication protocols* is guaranteed by\nthe TCP/IP protocol.\n\nOperating systems limit the number of concurrent connections. By default, Linux,\nfor example, can open 1,024 connections per process, whereas macOS limits this\nnumber to 256. To avoid excessive use of resources and enable reliable means for\nconnection establishment, Cardano uses a *multiplexer*.\n\n## Connection management[​](#connection-management \"Direct link to Connection management\")\n\nThe network layer handles a range of specific tasks besides the exchange of\nblock and transaction information required by the Ouroboros protocol.\n\nGenerally, connection management implementation includes the performance of the\nfollowing tasks:\n\n* opening a socket and/or acquiring resources from the OS\n* negotiating the protocol version with the handshake mini-protocol\n* spawning the thread that runs the multiplexer (which can be instructed to\n  start/stop various mini-protocols)\n* discovering and classifying exceptions thrown by mini-protocols or the\n  multiplexer itself\n* shutting down the connection in case of an error\n* handling a shutdown request from the peer\n* shutting down the threads that run mini-protocols\n* closing a socket.\n\n## Multiplexing[​](#multiplexing \"Direct link to Multiplexing\")\n\nThe multiplexing layer acts as a central crossing between mini-protocols and the\nnetwork channel. It runs several\n[mini-protocols](/about-cardano/explore-more/cardano-network#utilizing-mini-protocols)\nin parallel in a single channel ‒ TCP connection, for example.\n\nFigure 1 reflects how data flows between two nodes, each running three\nmini-protocols using a multiplexer (MUX) and a de-multiplexer (DEMUX).\n\nFigure 1. Data flow between the nodes through multiplexing\n\nData transmitted between nodes passes through the MUX/DEMUX of the nodes. There\nis a fixed pairing of mini-protocol instances, which means that each instance\nonly communicates with its dual instance (an initiator and a responder side).\n\nThe implementation of the mini-protocol also handles serialization and\nde-serialization of its messages. Mini-protocols write chunks of bytes to the\nMUX and read chunks of bytes from the DEMUX. The MUX reads the data from\nmini-protocols, splits it into segments, adds a segment header, and transmits\nthe segments to the DEMUX of its peer. The DEMUX uses the segment’s headers to\nreassemble byte streams for the mini-protocols on its side. The multiplexing\nprotocol (see the note below) itself is completely agnostic to the structure of\nthe multiplexed data.\n\nnote\n\nThis is not a generic, but specialized, use of multiplexing. Individual\nmini-protocols have strict constraints on unacknowledged messages that can be in\nflight. The design avoids the conditions in which the use of general TCP over\nTCP multiplexing creates chaotic performance.\n\n## Data segments of the multiplexing protocol[​](#data-segments-of-the-multiplexing-protocol \"Direct link to Data segments of the multiplexing protocol\")\n\nMultiplexing data segments include the following details:\n\n* **Transmission time** ‒ a timestamp based on the lower 32 bits of the sender’s\n  monotonic clock with a resolution of one microsecond\n* **Mini-protocol ID** ‒ the unique ID of the mini-protocol\n* **Payload length** ‒ the size of the segment payload in bytes; the maximum\n  payload length supported by the multiplexing wire format is 216 − 1. Note that\n  an instance of the protocol can choose a smaller limit for the size of\n  segments it transmits\n* **Mode** ‒ the single bit M (the mode) is used to distinguish the dual\n  instances of a mini-protocol. The mode is set to 0 in segments from the\n  initiator (the side that initially has agency), and it is set to 1 in segments\n  from the responder.\n\n## Cardano node communication protocols[​](#cardano-node-communication-protocols \"Direct link to Cardano node communication protocols\")\n\nCardano uses inter-process communication (IPC) protocols to allow for the\nexchange of blocks and transactions between nodes, and to allow local\napplications to interact with the blockchain via the node.\n\n### Node-to-node IPC overview[​](#node-to-node-ipc-overview \"Direct link to Node-to-node IPC overview\")\n\nThe Node-to-node (NtN) protocol transfers transactions between full nodes. NtN\nincludes three mini-protocols (chain-sync, block-fetch, and tx-submission),\nwhich are multiplexed over a single TCP channel using a network-mux package.\n\nThe following diagram represents the NtN operational flow:\n\nNtN follows a pull-based strategy, where the initiator node queries for new\ntransactions and the responder node replies with the transactions if any exist.\nThis protocol perfectly suits a trustless setting where both sides need to be\nprotected against resource consumption attacks from the other side.\n\n**NtN mini-protocols explained**\n\nA brief explanation of the NtN mini-protocols:\n\n* **chain-sync**: a protocol that allows a node to reconstruct a chain of an\n  upstream node\n* **block-fetch**: a protocol that allows a node to download block bodies from\n  various peers\n* **tx-submission**: a protocol that allows submission of transactions. The\n  implementation of this protocol is based on a generic mini protocol framework,\n  with one peculiarity: the roles of the initiator and the responder are\n  reversed. The Server is the initiator that asks for new transactions, and the\n  Client is the responder that replies with the transactions. This role reversal\n  was designed thus for technical reasons.\n\nTo ensure optimal networking service, the team has also implemented an\nadditional protocol:\n\n* **keep-alive**: a protocol that ensures continuous connection between nodes\n  and minimizes performance faults.\n\n### Node-to-client IPC overview[​](#node-to-client-ipc-overview \"Direct link to Node-to-client IPC overview\")\n\nNode-to-client (NtC) is a connection between a full node and a client that\nconsumes data but does not take part in the Ouroboros protocol (a wallet, for\nexample.)\n\nThe purpose of the NtC IPC protocol is to allow local applications to interact\nwith the blockchain via the node. This includes applications such as wallet\nbackends or blockchain explorers. The NtC protocol enables these applications to\naccess the raw chain data and to query the current ledger state, and it also\nprovides the ability to submit new transactions to the system.\n\nThe NtC protocol uses the same design as the node-to-node (NtN) protocol, but\nwith a different set of mini-protocols, and using local pipes rather than TCP\nconnections. As such, it is a relatively low-level and narrow interface that\nexposes only what the node can provide natively. For example, the node provides\naccess to all the raw chain data but does not provide a way to query data on the\nchain. The job of providing data services and more convenient higher-level APIs\nis delegated to dedicated clients, such as cardano-db-sync and the wallet\nbackend.\n\n**NtC mini-protocols**\n\nThe NtC protocol consists of three mini-protocols:\n\n* **chain-sync** - used for following the chain and getting blocks\n* **local-tx-submission** - used for submitting transactions\n* **local-state-query** - used for querying the ledger state.\n\nThe NtC version of chain-sync uses full blocks, rather than just block headers.\nThis is why no separate block-fetch protocol is needed. The local-tx-submission\nprotocol is like the NtN tx-submission protocol but simpler, and it returns the\ndetails of transaction validation failures. The local-state-query protocol\nprovides query access to the current ledger state, which contains a lot of\ninteresting data that is not directly reflected on the chain itself.\n\n**How NtC works**\n\nIn NtC, the node runs the producer side of the chain-sync protocol only, and the\nclient runs the consumer side only.\n\nThis table shows which mini-protocols are enabled for NtC communication:\n\nOn this page\n\n* [Connection management](#connection-management)\n* [Multiplexing](#multiplexing)\n* [Data segments of the multiplexing protocol](#data-segments-of-the-multiplexing-protocol)\n* [Cardano node communication protocols](#cardano-node-communication-protocols)\n  + [Node-to-node IPC overview](#node-to-node-ipc-overview)\n  + [Node-to-client IPC overview](#node-to-client-ipc-overview)",
        "images": []
      },
      {
        "url": "https://docs.cardano.org/about-cardano/evolution/upgrades/allegra",
        "raw_content": "![Cardano logo](/assets/cardano-logo.svg)\n![Cardano logo](/assets/cardano-logo.svg)\n\n# Allegra\n\nAllegra was the Shelley protocol upgrade that introduced token locking support to enable various kinds of smart contract use cases.\n\nAllegra represented a relatively small technical change to the consensus protocol, with a slight impact on the actual ledger. However, it was significant since it prepared the platform for smart contracts and the creation of assets (in addition to ada) that run on Cardano. It also provided an important piece of Voltaire (governance) functionality, supporting a voting mechanism.\n\nToken locking is a way of recording that a specific token is being used for some purpose. Locking, in this case, means ‘reserving’ a certain number of tokens for a specified period of time so they cannot be disposed of to gain a benefit (such as voting, or running a smart contract).\n\nRead more about token locking [in this blog post.](https://iohk.io/en/blog/posts/2020/12/02/goguen-brings-token-locking-to-cardano/)\n\n## Token locking use cases[​](#token-locking-use-cases \"Direct link to Token locking use cases\")\n\nSupport for token locking is crucial to enable complex deal settlement and funds accounting.\n\nIt can be used in the following scenarios:\n\n![Cardano Logo](/assets/cardano-logo-blue.svg)\n![Cardano Logo](/assets/cardano-logo.svg)\n\nCardano is an open-source project. Cardano is a software platform ONLY and does not conduct any independent diligence on, or substantive review of, any blockchain asset, digital currency, cryptocurrency or associated funds. You are fully and solely responsible for evaluating your investments, for determining whether you will exchange blockchain assets based on your own judgement, and for all your decisions as to whether to exchange blockchain assets with Cardano. In many cases, blockchain assets you exchange on the basis of your research may not increase in value, and may decrease in value. Similarly, blockchain assets you exchange on the basis of your research may fall or rise in value after your exchange. Past performance is not indicative of future results. Any investment in blockchain assets involves the risk of loss of part or all of your investment. The value of the blockchain assets you exchange is subject to market and other investment risks.\n\nThis work is licensed under CC BY 4.0\n\n© IOHK 2015-2025 - IOHK Supported Project",
        "images": []
      },
      {
        "url": "https://docs.cardano.org/about-cardano/evolution/upgrades/alonzo",
        "raw_content": "![Cardano logo](/assets/cardano-logo.svg)\n![Cardano logo](/assets/cardano-logo.svg)\n\n# Alonzo\n\n*Alonzo* is the protocol upgrade implemented in September 2021, as part of the Goguen development phase. It built on top of transaction metadata, token locking, and native asset functionality to enable smart contract development.\n\nThis upgrade introduced a versatile platform opening up opportunities for businesses and developers, by allowing the creation of smart contracts and decentralized applications (DApps) for decentralized finance (DeFi).\n\nSuch capability was enabled by adding the necessary tools and the infrastructure using the Plutus platform. Applying a rigorous approach based on formal methods and verification, Alonzo extended the basic multi-signature scripting language (multisig) used in Cardano Shelley. Multisig was upgraded to the Plutus Core language for more powerful and secure scripting options. For this, Alonzo implemented the [extended unspent transaction output (EUTXO) accounting model](https://iohk.io/en/blog/posts/2021/03/12/cardanos-extended-utxo-accounting-model-part-2/).\n\nFurther reading:\n\n![Cardano Logo](/assets/cardano-logo-blue.svg)\n![Cardano Logo](/assets/cardano-logo.svg)\n\nCardano is an open-source project. Cardano is a software platform ONLY and does not conduct any independent diligence on, or substantive review of, any blockchain asset, digital currency, cryptocurrency or associated funds. You are fully and solely responsible for evaluating your investments, for determining whether you will exchange blockchain assets based on your own judgement, and for all your decisions as to whether to exchange blockchain assets with Cardano. In many cases, blockchain assets you exchange on the basis of your research may not increase in value, and may decrease in value. Similarly, blockchain assets you exchange on the basis of your research may fall or rise in value after your exchange. Past performance is not indicative of future results. Any investment in blockchain assets involves the risk of loss of part or all of your investment. The value of the blockchain assets you exchange is subject to market and other investment risks.\n\nThis work is licensed under CC BY 4.0\n\n© IOHK 2015-2025 - IOHK Supported Project",
        "images": []
      },
      {
        "url": "https://docs.cardano.org/about-cardano/evolution/upgrades/mary",
        "raw_content": "![Cardano logo](/assets/cardano-logo.svg)\n![Cardano logo](/assets/cardano-logo.svg)\n\n# Mary\n\n*Mary* is the Shelley protocol upgrade implemented in March 2021. It introduced\nnative token and multi-asset support on Cardano. Mary allowed users to create\nuniquely defined (custom) tokens and carry out transactions with them directly\non the Cardano blockchain.\n\nWith the Mary upgrade, the ledger’s accounting infrastructure processes not only\nada transactions but also transactions that simultaneously carry several asset\ntypes. Native support grants distinct advantages for developers as there is no\nneed to create smart contracts to handle custom token creation or transactions.\nInstead, the accounting ledger tracks the ownership and transfer of assets,\nremoving extra complexity and potential for manual errors, while ensuring\nsignificant cost efficiency.\n\nDevelopers, businesses, and applications can create general purpose (fungible)\nor specialized (non-fungible) tokens to achieve commercial or business\nobjectives. These might include the creation of custom payment tokens or rewards\nfor decentralized applications; stablecoins pegged to other currencies; or\nunique assets that represent intellectual property. All these assets can then be\ntraded, exchanged, or used as payment for products or services.\n\nFurther reading:\n\n![Cardano Logo](/assets/cardano-logo-blue.svg)\n![Cardano Logo](/assets/cardano-logo.svg)\n\nCardano is an open-source project. Cardano is a software platform ONLY and does not conduct any independent diligence on, or substantive review of, any blockchain asset, digital currency, cryptocurrency or associated funds. You are fully and solely responsible for evaluating your investments, for determining whether you will exchange blockchain assets based on your own judgement, and for all your decisions as to whether to exchange blockchain assets with Cardano. In many cases, blockchain assets you exchange on the basis of your research may not increase in value, and may decrease in value. Similarly, blockchain assets you exchange on the basis of your research may fall or rise in value after your exchange. Past performance is not indicative of future results. Any investment in blockchain assets involves the risk of loss of part or all of your investment. The value of the blockchain assets you exchange is subject to market and other investment risks.\n\nThis work is licensed under CC BY 4.0\n\n© IOHK 2015-2025 - IOHK Supported Project",
        "images": []
      },
      {
        "url": "https://docs.cardano.org/",
        "raw_content": "![Cardano logo](/assets/cardano-logo.svg)\n![Cardano logo](/assets/cardano-logo.svg)\n\n# Documentation\n\n## Cardano ecosystem\n\nCardano is a decentralized, third-generation, proof-of-stake blockchain, native home to the ada cryptocurrency.\n\n## You can do wonderful things with Cardano\n\nDive into Cardano's fundamentals, from beginner explainers to in-depth coverage of core concepts, architecture and networking, and the platform's evolution.\n\nLearn about Cardano’s features and find references to developer resources, including guides and tutorials, to kickstart your development journey.\n\nLearn about stake pool operation basics, including node connectivity, keys, operational certificates, maintenance, and more, with references to detailed developer tutorials.\n\nGet started with Cardano's testnet environments and explore how to engage with them effectively.\n\nExplore learning opportunities on Cardano, including details about the Plutus Pioneer program and other educational resources.\n\n## Browse more documentation websites\n\n![Cardano dev portal](/assets/websites-grid/dev-portal.svg)\n![Cardano node tests](/assets/websites-grid/node-tests.svg)\n![Plinth docs](/assets/websites-grid/plinth.svg)\n![Marlowe docs](/assets/websites-grid/marlowe.svg)\n![Aiken](/assets/websites-grid/aiken.png)\n![Cardano dev portal builder tools](/assets/websites-grid/builder-tools.svg)\n![Hydra docs](/assets/websites-grid/hydra.svg)\n![Mithril docs](/assets/websites-grid/mythril.svg)\n![Cardano Gov tool docs](/assets/websites-grid/gov-tool.svg)\n![Project catalyst](/assets/websites-grid/catalyst.svg)\n![Cardano Logo](/assets/cardano-logo.svg)\n![Cardano Logo](/assets/cardano-logo.svg)\n\nCardano is an open-source project. Cardano is a software platform ONLY and does not conduct any independent diligence on, or substantive review of, any blockchain asset, digital currency, cryptocurrency or associated funds. You are fully and solely responsible for evaluating your investments, for determining whether you will exchange blockchain assets based on your own judgement, and for all your decisions as to whether to exchange blockchain assets with Cardano. In many cases, blockchain assets you exchange on the basis of your research may not increase in value, and may decrease in value. Similarly, blockchain assets you exchange on the basis of your research may fall or rise in value after your exchange. Past performance is not indicative of future results. Any investment in blockchain assets involves the risk of loss of part or all of your investment. The value of the blockchain assets you exchange is subject to market and other investment risks.\n\nThis work is licensed under CC BY 4.0\n\n© IOHK 2015-2025 - IOHK Supported Project",
        "images": []
      },
      {
        "url": "https://docs.cardano.org/about-cardano/contributions",
        "raw_content": "![Cardano logo](/assets/cardano-logo.svg)\n![Cardano logo](/assets/cardano-logo.svg)\n\n# Contribution guidelines\n\nThe Cardano Docs site follows the principles of open-source collaboration,\ninclusiveness, and community-driven success. Contributing to Cardano Docs helps\ncreate a rich, accurate, and up-to-date resource for the entire Cardano\ncommunity. By sharing your knowledge and expertise, you ensure the documentation\nremains a valuable and reliable source of information for all.\n\nNote that Cardano Docs focuses on providing information about Cardano's\nfunctionalities and features, while the\n[Developer Portal](https://developers.cardano.org/) offers developer-related\ntutorials and guides. These two resources exist in tandem, ensuring a seamless\nuser experience for both general users and developers.\n\nBy using this website and contributing to Cardano Docs, you agree to be bound by\nand comply with the CC BY 4.0 license.\n\n## What to contribute?[​](#what-to-contribute \"Direct link to What to contribute?\")\n\nYou can contribute in several ways, including:\n\n## How to contribute?[​](#how-to-contribute \"Direct link to How to contribute?\")\n\n### Creating a pull request[​](#creating-a-pull-request \"Direct link to Creating a pull request\")\n\nIf you prefer working with GitHub locally, follow these steps:\n\nSee more about\n[Docusaurus set up here](https://github.com/input-output-hk/cardano-documentation?tab=readme-ov-file#website).\n\n### Raising an issue[​](#raising-an-issue \"Direct link to Raising an issue\")\n\nBy raising an issue, you can identify areas for improvement, report problems, or\nsuggest new content.\n\nTo create an issue:\n\nYour contributions are vital to maintaining the quality and integrity of Cardano\nDocs. Whether you’re correcting a typo, adding new content, or suggesting\nimprovements, every contribution helps. Thank you for being an active Cardano\ncommunity member and helping make Cardano Docs an invaluable resource for\neveryone.\n\n## Style guide[​](#style-guide \"Direct link to Style guide\")\n\n### General notes[​](#general-notes \"Direct link to General notes\")\n\nEnsure simplicity, accuracy, and accessibility. Aim for a broad understanding,\neven for select audiences. Be concise – avoid unnecessary words.\n\n### Style principles[​](#style-principles \"Direct link to Style principles\")\n\n**Language**\n\n**Abbreviations and acronyms**\n\n**Legal and investment**\n\n**Punctuation**\n\n**Capitalization**\n\n**Numbers and time**\n\n**Bullet lists**\n\n**Links**\n\n**Headlines and titles**\n\n### Markdown features[​](#markdown-features \"Direct link to Markdown features\")\n\nCardano Docs uses Markdown for formatting. Below are the main Markdown features:\n\n**Headers**\n\n`#`\n`##`\n`# H1  \n  \n## H2  \n  \n### H3`\n\n**Emphasis**\n\n`*`\n`_`\n`**`\n`__`\n`_italic_ or _italic_  \n  \n**bold** or **bold**`\n\n**Lists**\n\n`-`\n`*`\n`1.`\n`- Item 1  \n  \n- Item 2  \n  \n* Item 3.  \n  \n1. First item  \n  \n2. Second item.`\n\n**Links**\n\n`[text](url)`\n`[Cardano Docs](https://docs.cardano.org/)`\n\n**Images**\n\n`![alt text](url)`\n\n**Code**\n\n**Blockquotes**\n\n`>`\n`> This is a blockquote.`\n\n**Tables**\n\n`|`\n`| Header 1 | Header 2 |  \n  \n|----------|----------|  \n  \n| Cell 1 | Cell 2 |`\n\nFor more details, see\n[MD features here](https://docusaurus.io/docs/next/markdown-features).\n\n![Cardano Logo](/assets/cardano-logo-blue.svg)\n![Cardano Logo](/assets/cardano-logo.svg)\n\nCardano is an open-source project. Cardano is a software platform ONLY and does not conduct any independent diligence on, or substantive review of, any blockchain asset, digital currency, cryptocurrency or associated funds. You are fully and solely responsible for evaluating your investments, for determining whether you will exchange blockchain assets based on your own judgement, and for all your decisions as to whether to exchange blockchain assets with Cardano. In many cases, blockchain assets you exchange on the basis of your research may not increase in value, and may decrease in value. Similarly, blockchain assets you exchange on the basis of your research may fall or rise in value after your exchange. Past performance is not indicative of future results. Any investment in blockchain assets involves the risk of loss of part or all of your investment. The value of the blockchain assets you exchange is subject to market and other investment risks.\n\nThis work is licensed under CC BY 4.0\n\n© IOHK 2015-2025 - IOHK Supported Project",
        "images": []
      }
    ],
    "failed_results": [],
    "response_time": 1.13,
    "request_id": "24cd98d9-7732-4e74-9d8e-13d629726c3a"
  }
}