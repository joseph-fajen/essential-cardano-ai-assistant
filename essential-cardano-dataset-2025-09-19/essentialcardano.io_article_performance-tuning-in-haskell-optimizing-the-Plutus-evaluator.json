{
  "url": "https://www.essentialcardano.io/article/performance-tuning-in-haskell-optimizing-the-Plutus-evaluator",
  "content": "# Performance tuning in Haskell: optimizing the Plutus evaluator\n\n![](https://avatars.githubusercontent.com/u/10480926?v=4)\n![](data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27800%27%20height=%27450%27/%3e)\n![Performance tuning in Haskell: optimizing the Plutus evaluator](/_next/image?url=https%3A%2F%2Fucarecdn.com%2F4852b04a-ad19-43ed-a437-cbb6db666d3a%2F&w=1920&q=75)\n\nPerformance optimization often comes down to identifying subtle inefficiencies in the generated code. While reviewing the Glasgow Haskell Compiler (GHC) Core of the production evaluator, the Input | Output (IO) Plutus team discovered that a key function, `safeIndexOne`, was not getting inlined and was introducing unnecessary laziness. By addressing strictness issues, eliminating redundant data structures, and leveraging the worker-wrapper transformation, the team achieved a **12% performance improvement**.\n\n`safeIndexOne`\n\nThis post, written by Roman Kireev – IO’s compiler engineer, describes the optimization process, detailing how the team turned recursive lookups into efficient jump-based execution.\n\n## Identifying optimization opportunities\n\nWhile analyzing the GHC Core output of the evaluator, the team noticed the following snippet:\n\n`case safeIndexOne env1_XW (W64# bx18_scPRb) of {\nNothing -> jump exit_X16 <...>\nJust val_acLQA -> jump returnCek_scPkh ctx1_X0 val_acLQA <...>\n}`\n\nThis code performs a variable lookup using `safeIndexOne`. If the lookup fails, the evaluator terminates via `jump exit_X16`. Otherwise, recursion continues with the looked-up value using `jump returnCek_scPkh`.\n\n`safeIndexOne`\n`jump exit_X16`\n`jump returnCek_scPkh`\n\nIn both cases, the `jump` keyword indicates that recursion compiles to an efficient jump to a label. For more details, see the ‘*Compiling without Continuations*’ [research paper](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf).\n\n`jump`\n\nSeveral optimization opportunities stood out:\n\n`safeIndexOne`\n`bx18_scPRb`\n`W64#`\n`safeIndexOne`\n`Maybe`\n`safeIndexOne`\n`Maybe`\n\n## Addressing strictness issues\n\nExamining `safeIndexOne`, we see:\n\n`safeIndexOne`\n`safeIndexOne :: RAList a -> Word64 -> Maybe a\nsafeIndexOne Nil _ = Nothing\nsafeIndexOne (BHead w t ts) !i =\nif i <= w\nthen indexTree w i t\nelse safeIndexOne ts (i-w)\nwhere\nindexTree :: Word64 -> Word64 -> Tree a -> Maybe a\nindexTree = <...>`\n\nThe first clause ignores the second argument, leading GHC to treat it as lazy. This causes the `W64#` wrapping seen earlier. To enforce strict evaluation, we modify the function:\n\n`W64#`\n`safeIndexOne Nil !_ = Nothing\nsafeIndexOne (BHead w t ts) i =`\n\nAfter recompiling, we see that the strictness issue is resolved:\n\n`case $wsafeIndexOne env1_XW bx18_swNG of {\nNothing -> jump exit_X16 <...>\nJust val_apny -> jump returnCek_sw4D ctx1_X0 val_apny <...>\n}`\n\nNow, `$wsafeIndexOne` (see *The Worker/Wrapper Transformation* [research paper](https://people.cs.nott.ac.uk/pszgmh/wrapper-extended.pdf)) operates directly on a machine word value, eliminating unnecessary boxing and unboxing.\n\n`$wsafeIndexOne`\n\n## Attempting inlining through worker-wrapper transformation\n\nHowever, `safeIndexOne` is still not inlined. Since it is recursive, GHC won’t inline it by default. We attempt a manual worker-wrapper transformation to create a non-recursive top-level function:\n\n`safeIndexOne`\n`safeIndexOne :: forall a. RAList a -> Word64 -> Maybe a\nsafeIndexOne = go\nwhere\ngo :: RAList a -> Word64 -> Maybe a\ngo Nil !_ = Nothing\ngo (BHead w t ts) !i =\nif i <= w\nthen indexTree w i t\nelse go ts (i-w)\nindexTree :: Word64 -> Word64 -> Tree a -> Maybe a\nindexTree = <...>`\n\nHowever, this does not solve the issue – GHC floats go to the top level, preventing inlining.\n\n## Ensuring inlining with Church encoding\n\nWe need to ensure that GHC retains `go` and `indexTree` as local definitions. When `safeIndexOne` is inlined, both appear in the generated Core at the call site, allowing GHC to optimize them. This could likely be achieved using something from `GHC.Magic`, but the simplest approach is to make `safeIndexOne` accept a term-level argument and use it within `go` and `indexTree`. To do this, we introduce a term-level argument by Church-encoding `Maybe`:\n\n`go`\n`indexTree`\n`safeIndexOne`\n`GHC.Magic`\n`safeIndexOne`\n`go`\n`indexTree`\n`Maybe`\n`safeIndexOne :: forall a b. b -> (a -> b) -> RAList a -> Word64 -> b\nsafeIndexOne z f = go\nwhere\ngo :: RAList a -> Word64 -> b\ngo Nil !_ = z\ngo (BHead w t ts) !i =\nif i <= w\nthen indexTree w i t\nelse go ts (i-w)\nindexTree :: Word64 -> Word64 -> Tree a -> Maybe a\nindexTree = <...>`\n\nNow, `z` replaces `Nothing`, and `f` replaces `Just`. The call site is adapted from:\n\n`z`\n`Nothing`\n`f`\n`Just`\n`case Env.safeIndexOne varEnv varIx of\nNothing -> throw <...>\nJust val -> pure val`\n\nto:\n\n`Env.safeIndexOne\n(throw <...>)\npure\nvarEnv\nvarIx`\n\nThis allows `safeIndexOne` to inline, along with its internals.\n\n`safeIndexOne`\n\n## Result: optimized Core output\n\nThe final Core output shows a recursive join point with efficient machine word operations and label jumps:\n\n`joinrec {\n$windexTree_swMk\n:: Word64#\n-> Word64#\n-> Tree (CekValue uni_swN8 fun_swN9 ann_swNa)\n-> (# State# RealWorld,\nEither\n(CekEvaluationException\nNamedDeBruijn uni_swN8 fun_swN9)\n(NTerm uni_swN8 fun_swN9 ()) #)\n$windexTree_swMk (ww2_swMc :: Word64#)\n(ww3_swMg :: Word64#)\n(ds28_swMi\n:: Tree\n(CekValue\nuni_swN8 fun_swN9 ann_swNa))\n= case ww3_swMg of wild14_X15 {\n__DEFAULT ->\ncase ww2_swMc of wild15_X1m {\n__DEFAULT ->\ncase ds28_swMi of {\nLeaf ds29_avEa -> jump exit14_X16;\nNode ipv13_avEc ipv14_avEd ipv15_avEe ->\ncase wild14_X15 of wild17_X1n {\n__DEFAULT ->\nlet {\noffset'_swtg :: Word64#\noffset'_swtg\n= subWord64#\nwild17_X1n 1#Word64 } in\nlet {\nhalfSize_sw7I :: Word64#\nhalfSize_sw7I\n= uncheckedShiftRL64#\nwild15_X1m 1# } in\ncase leWord64#\noffset'_swtg halfSize_sw7I\nof {\n__DEFAULT ->\njump $windexTree_swMk\nhalfSize_sw7I\n(subWord64#\noffset'_swtg halfSize_sw7I)\nipv15_avEe;\n1# ->\njump $windexTree_swMk\nhalfSize_sw7I\noffset'_swtg\nipv14_avEd\n};\n1#Word64 -> jump exit15_X17 ipv13_avEc\n}\n};\n1#Word64 ->\ncase wild14_X15 of wild16_X1n {\n__DEFAULT ->\ncase ds28_swMi of {\nLeaf ds29_avEa -> jump exit14_X16;\nNode ipv13_avEc ipv14_avEd ipv15_avEe ->\nlet! { __DEFAULT ~ wild18_X1o\n<- wild16_X1n } in\nlet {\noffset'_swtg :: Word64#\noffset'_swtg\n= subWord64#\nwild18_X1o 1#Word64 } in\ncase leWord64# offset'_swtg 0#Word64\nof {\n__DEFAULT ->\njump $windexTree_swMk\n0#Word64 offset'_swtg ipv15_avEe;\n1# ->\njump $windexTree_swMk\n0#Word64 offset'_swtg ipv14_avEd\n}\n};\n1#Word64 ->\ncase ds28_swMi of {\nLeaf x_avEC ->\njump returnCek_sw7q\nctx1_X0 x_avEC ipv12_swMu;\nNode ipv13_avEE ipv14_avEF ipv15_avEG ->\njump exit15_X17 ipv13_avEE\n}\n}\n};\n0#Word64 -> jump exit16_X18\n}; } in\njoinrec {\n$wgo_swMs\n:: RAList (CekValue uni_swN8 fun_swN9 ann_swNa)\n-> Word64#\n-> (# State# RealWorld,\nEither\n(CekEvaluationException\nNamedDeBruijn uni_swN8 fun_swN9)\n(NTerm uni_swN8 fun_swN9 ()) #)\n$wgo_swMs (ds28_swMm\n:: RAList\n(CekValue uni_swN8 fun_swN9 ann_swNa))\n(ww2_swMp :: Word64#)\n= case ds28_swMm of {\nBHead bx19_avEO t_avEP ts_avEQ ->\ncase leWord64# ww2_swMp bx19_avEO of {\n__DEFAULT ->\njump $wgo_swMs\nts_avEQ (subWord64# ww2_swMp bx19_avEO);\n1# ->\njump $windexTree_swMk bx19_avEO ww2_swMp t_avEP\n};\nNil -> jump exit13_X1l\n}; } in\njump $wgo_swMs env1_XW bx18_swRA }`\n\n## Conclusion\n\nBy enforcing strict evaluation, restructuring `safeIndexOne`, and leveraging Church encoding, we eliminated unnecessary boxing, ensured inlining, and improved evaluator performance by 12%.\n\n`safeIndexOne`\n\n*This article has been written in collaboration with Olga Hryniuk.*\n\n## 2 contributors\n\n![](https://ucarecdn.com/4f580f1c-e076-45b2-8a8d-af75d20c0cfd/)\n![](https://avatars.githubusercontent.com/u/10480926?v=4)\n\n## Would you like to suggest changes to this article?\n\nWe encourage you to actively participate in the creation and moderation of our content—your contributions are invaluable. All content is reviewed by another community member.\n\n##### Resources\n\n##### Legal\n\n##### Subscribe to our newsletter",
  "images": [],
  "extraction_metadata": {
    "batch_number": 10,
    "extraction_timestamp": "2025-09-19T10:02:36.504602",
    "extraction_time": 2.4268858432769775,
    "source": "tavily_api_raw"
  }
}