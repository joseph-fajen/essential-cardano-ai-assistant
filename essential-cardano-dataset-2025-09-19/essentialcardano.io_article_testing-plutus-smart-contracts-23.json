{
  "url": "https://www.essentialcardano.io/article/testing-plutus-smart-contracts-23",
  "content": "# Testing Plutus Smart Contracts (2/3)\n\n![](https://avatars.githubusercontent.com/u/68808993?v=4)\n![](data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271185%27%20height=%27558%27/%3e)\n![Testing Plutus Smart Contracts (2/3)](/_next/image?url=https%3A%2F%2Fucarecdn.com%2F54716b8e-797e-42d1-9648-d19b30543039%2F&w=3840&q=75)\n\nTo guarantee secure and high-quality smart contracts, rigorous testing strategies should be implemented. These will significantly differ from standard testing techniques typically used in low-risk web 2 applications.\n\nTesting in Plutus has been be thoroughly covered in the [8th lecture of the Plutus Pioneer Program](https://www.youtube.com/playlist?list=PLNEK_Ejlx3x0UIixvEQG2Y2mmFL6__pEJ).\n\n[My background](https://www.linkedin.com/in/oussama-benmahmoud-43693926/), which is largely in software quality in test automation, means I was ecstatic to discover the blockchain testing concepts, especially with Plutus.\n\nIn three Plutus Testing related articles, we will go over special techniques on how to test Plutus smart contracts using the emulator trace, calculate test coverage, the notion of optics and lenses, and Property Based Testing.\n\nIn the [last article](https://medium.com/peakchain/building-on-cardano-my-whole-journey-part-10-testing-plutus-smart-contracts-1-3-ee53a8127536), we covered “Manual” testing techniques of a Smart Contract in Plutus. After that, we presented “Tasty Framework” in Haskell and “[Plutus Contract Test](https://playground.plutus.iohkdev.io/doc/haddock/Plutus-contract/html/Plutus-Contract-Test.html)” (A special package in Plutus for testing Smart Contracts). Both are used for automated tests in Plutus.\n\nIn this article, we will present the following concepts:\n\nAssertions\n\nEmulator Trace Based Tests\n\nCode Coverage\n\nOptics and Lenses in Haskell\n\n# **1. Assertions in Plutus**\n\nWe begin our article by checking the different assertions available for use in our tests.\n\nYou can find below the Assertions available in the “*Plutus.Contract.Test*” Module.\n\n![](https://ucarecdn.com/9198ca61-5ab3-4e7e-aaec-7e449c51cf81/-/preview/-/format/auto/-/quality/smart/)\n\n![](https://ucarecdn.com/9198ca61-5ab3-4e7e-aaec-7e449c51cf81/-/preview/-/format/auto/-/quality/smart/)\n\n**Figure 1:** Assertions in the “Plutus.Contract.Test” Module\n\n# **2. Emulator Trace Based Tests:**\n\nIn Plutus, a number of test types are supported. This blog post will explain two categories mainly:\n\n- Emulator Trace based testing (covered in this article)\n\n- Property based testing (will be presented in the next article)\n\nNow, we will move on to covering the first Emulator Trace based testing\n\n# **2.1 Test implementation**\n\n## **2.1.1 “tests”: The TestTree function**\n\nAt this juncture, we go back to our code to implement our tests. We begin by coding the “tests” function from the type “TestTree”.\n\nFirst, we have used the “**checkPredicateOptions**”. These options are needed to configure the Emulator before running the tests.\n\nSecond, we indicate the name of our tests. Simple string: “token sale trace”\n\nThird, we specify the Predicate: This is the main assertion we should check after conducting the test\n\nFourth, we define the Trace, which we call “myTrace”\n\n![](https://ucarecdn.com/d4506ac5-6acd-4278-9da7-064ed7d14d70/-/preview/-/format/auto/-/quality/smart/)\n\n![](https://ucarecdn.com/d4506ac5-6acd-4278-9da7-064ed7d14d70/-/preview/-/format/auto/-/quality/smart/)\n\n**Figure 2:** “tests” function implementation\n\n## **2.1.2 “emCfg”: the EmulatorConfig Function**\n\nUsing the Emulator config, we can specify the initial wallet funds.\n\n![](https://ucarecdn.com/2eefdf79-c654-42c8-b6ae-0545d2d60db9/-/preview/-/format/auto/-/quality/smart/)\n\n![](https://ucarecdn.com/2eefdf79-c654-42c8-b6ae-0545d2d60db9/-/preview/-/format/auto/-/quality/smart/)\n\n**Figure 3:** EmulatorConfig implementation\n\n## **2.1.3 “myPredicate”: TracePredicate function**\n\nThis function has the main assertions regarding wallet balances in the Emulator Trace. So, we should check these after running the test.\n\nWe are using the (***.&&.***) combinator to check the wallet Funds after running our customized Token Sale use case.\n\nHere, we can see that we have implemented the same assertions as the manual test cases.\n\n# **2.2 Running the test:**\n\nMoving on, we can run the tests using repl after importing the Tasty Haskell Testing Framework and running the defaultMain tests. This is, of course, indicated by the Tasty framework.\n\n![](https://ucarecdn.com/0b93f55d-013d-4b65-9148-63d300ce9842/-/preview/-/format/auto/-/quality/smart/)\n\n![](https://ucarecdn.com/0b93f55d-013d-4b65-9148-63d300ce9842/-/preview/-/format/auto/-/quality/smart/)\n\n**Figure 4:** Running Plutus Automatic Tests in the repl using Tasty Framework\n\n# **2.3 Emulator Trace Based Test Execution Results**\n\nPreviously, all tests have passed successfully.\n\nMoving forward, we need to check how the test execution results look in case of Failed Tests. And we can manipulate test assertions to enforce test failure.\n\nHence, we change the expected funds in wallet 2 after running the tests from 20 to 19, which is obviously false.\n\n![](https://ucarecdn.com/3dcbef28-42b6-4b64-b5bd-e10ae27e1e1f/-/preview/-/format/auto/-/quality/smart/)\n\n![](https://ucarecdn.com/3dcbef28-42b6-4b64-b5bd-e10ae27e1e1f/-/preview/-/format/auto/-/quality/smart/)\n\n**Figure 5:** Changing the test assertions from the test predicate\n\n![](https://ucarecdn.com/9e7500ba-8eea-4512-a748-ef62e67a1255/-/preview/-/format/auto/-/quality/smart/)\n\n![](https://ucarecdn.com/9e7500ba-8eea-4512-a748-ef62e67a1255/-/preview/-/format/auto/-/quality/smart/)\n\n**Figure 6:** Running Plutus Automatic Tests in the repl using Tasty Framework — Case of failure\n\nWe notice that the test failed as expected.\n\nWe also get the logs offering details of the test execution results, along with a comparison between the Actual Results and Expected Results.\n\n# **3. Code Coverage**\n\n## **3.1 Implementation of the code coverage functionality**\n\nPlutus allows us to check the code coverage. Thus, how much code covered by our tests serves as a crucial indicator of our code quality.\n\nAs described in “**Figure 6:** Checking Predicates” ([Previous article](https://medium.com/peakchain/building-on-cardano-my-whole-journey-part-10-testing-plutus-smart-contracts-1-3-ee53a8127536)) of the “Plutus.Contract.Test” Module”, one of the checking predicates functions provided by the “Plutus.Contract.Test” module is the “checkPredicateCoverage” function.\n\n![](https://ucarecdn.com/57bbc3bb-0a1f-4ca3-a0c3-c9f453eb9608/-/preview/-/format/auto/-/quality/smart/)\n\n![](https://ucarecdn.com/57bbc3bb-0a1f-4ca3-a0c3-c9f453eb9608/-/preview/-/format/auto/-/quality/smart/)\n\n**Figure 7:** “checkPredicateOptionsCoverage” function implementation\n\nNow, we implement the “***testCoverage***” function by deploying the mentioned “***checkPredicateCoverage***” function.\n\n![](https://ucarecdn.com/6d612f72-6584-485e-a3b9-1f704fd760bf/-/preview/-/format/auto/-/quality/smart/)\n\n![](https://ucarecdn.com/6d612f72-6584-485e-a3b9-1f704fd760bf/-/preview/-/format/auto/-/quality/smart/)\n\n**Figure 8:** Implementation of the test coverage function\n\n## **3.2 Executing the coverageTest function and result checking:**\n\nAfter implementing the “testCoverage” function, we run it in the repl. Once executed, the “**testCoverage**” function will save the results in an HTML report.\n\n![](https://ucarecdn.com/3186f733-0251-4ce6-957f-d444cd3b1b4e/-/preview/-/format/auto/-/quality/smart/)\n\n![](https://ucarecdn.com/3186f733-0251-4ce6-957f-d444cd3b1b4e/-/preview/-/format/auto/-/quality/smart/)\n\n**Figure 9:** Running the test coverage function in repl\n\nOur test coverage report captures a range of meaningful indicators. This is especially true for the transition function, where we have the core business logic of our use case.\n\nFor example, the green color code means that the highlighted conditions were always true in our test.\n\nBut the “Nothing” is highlighted in Red, meaning our tests did not cover this condition.\n\n![](https://ucarecdn.com/058318bc-1d62-4f44-a5e6-754568a22c5e/-/preview/-/format/auto/-/quality/smart/)\n\n![](https://ucarecdn.com/058318bc-1d62-4f44-a5e6-754568a22c5e/-/preview/-/format/auto/-/quality/smart/)\n\n**Figure 10:** Html test coverage report\n\n# **4. Optics and lenses in Haskell:**\n\nOne critical concept in Haskell needed as part of our Testing framework is Optics and Lenses.\n\nVarious frameworks in Haskell implement these concepts. Still, the Plutus development team uses the [library “Lens” in Hackage](https://hackage.haskell.org/package/lens).\n\nOptics attempts to deal with hierarchical data types. Thus, in this way, we can either read specific data located in one particular hierarchical data type or update it.\n\n![](https://ucarecdn.com/31bd7ffc-fede-492d-be8a-673492a09171/-/preview/-/format/auto/-/quality/smart/)\n\n![](https://ucarecdn.com/31bd7ffc-fede-492d-be8a-673492a09171/-/preview/-/format/auto/-/quality/smart/)\n\n**Figure 11:** Example of a hierarchical data type\n\nLars created an example of a hierarchical data type he calls “company” in the Plutus pioneer lecture. The company includes a staff, which represents another data type called “Person”, which contains the person’s name and address.\n\nThe main challenge in a hierarchical data type is reading or changing the address of a specific person using a simple, straightforward function.\n\nBut, Lenses solve this issue. In fact, it provides a concept similar to “accessors”, which exist in other programming languages like Java, represented by the “.” symbol.\n\n![](https://ucarecdn.com/091705b8-d6f4-41aa-aff7-10dca00853f8/-/preview/-/format/auto/-/quality/smart/)\n\n![](https://ucarecdn.com/091705b8-d6f4-41aa-aff7-10dca00853f8/-/preview/-/format/auto/-/quality/smart/)\n\n**Figure 12:** Getting and Updating specific data using Lenses\n\n**In the next article about testing in Plutus, we will present the concept of Property Based Testing.**\n\n---------------------------------------------------------------------------\n\n**You can find the original article published in** [PeakChain](https://medium.com/peakchain) **Medium Publication under** [this link](https://medium.com/peakchain/building-on-cardano-my-whole-journey-part-11-testing-plutus-smart-contracts-2-3-4af6e04507f8)**.**\n\n**Support also our PeakChain Automotive Solutions in Project Catalyst Fund 9!**\n\n[1- PeakChain Car Wallet Device](https://cardano.ideascale.com/c/idea/414249)\n\n[2- PeakChain Uber on Cardano](https://cardano.ideascale.com/c/idea/414255)\n\n[3- PeakChain Fleet Management Platform](https://cardano.ideascale.com/c/idea/414216)\n\n[4- PeakChain Car-Sharing Platform](https://cardano.ideascale.com/c/idea/414199)\n\n**Author:** [Oussama Benmahmoud](https://twitter.com/@oussbenma), CEO of [PeakSoft GmbH](https://peak-soft.de/) and Founder of [PeakChain](https://peak-chain.com/)\n\n## 1 contributors\n\n![](https://avatars.githubusercontent.com/u/68808993?v=4)\n\n## Would you like to suggest changes to this article?\n\nWe encourage you to actively participate in the creation and moderation of our content—your contributions are invaluable. All content is reviewed by another community member.\n\n##### Resources\n\n##### Legal\n\n##### Subscribe to our newsletter",
  "images": [],
  "extraction_metadata": {
    "batch_number": 11,
    "extraction_timestamp": "2025-09-19T10:02:41.785460",
    "extraction_time": 2.2238550186157227,
    "source": "tavily_api_raw"
  }
}